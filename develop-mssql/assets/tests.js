define('dummy/tests/adapters/application-offline.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - adapters');
  test('adapters/application-offline.js should pass jscs', function () {
    ok(true, 'adapters/application-offline.js should pass jscs.');
  });
});
define('dummy/tests/adapters/application-offline.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - adapters/application-offline.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'adapters/application-offline.js should pass jshint.');
  });
});
define('dummy/tests/adapters/application.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - adapters');
  test('adapters/application.js should pass jscs', function () {
    ok(true, 'adapters/application.js should pass jscs.');
  });
});
define('dummy/tests/adapters/application.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - adapters/application.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'adapters/application.js should pass jshint.');
  });
});
define('dummy/tests/app.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - .');
  test('app.js should pass jscs', function () {
    ok(true, 'app.js should pass jscs.');
  });
});
define('dummy/tests/app.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - app.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'app.js should pass jshint.');
  });
});
define('dummy/tests/controllers/api-test-map.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - controllers');
  test('controllers/api-test-map.js should pass jscs', function () {
    ok(true, 'controllers/api-test-map.js should pass jscs.');
  });
});
define('dummy/tests/controllers/api-test-map.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - controllers/api-test-map.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'controllers/api-test-map.js should pass jshint.');
  });
});
define('dummy/tests/controllers/application.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - controllers');
  test('controllers/application.js should pass jscs', function () {
    ok(true, 'controllers/application.js should pass jscs.');
  });
});
define('dummy/tests/controllers/application.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - controllers/application.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'controllers/application.js should pass jshint.');
  });
});
define('dummy/tests/controllers/components-examples/flexberry-boundingbox/settings-example.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - controllers/components-examples/flexberry-boundingbox');
  test('controllers/components-examples/flexberry-boundingbox/settings-example.js should pass jscs', function () {
    ok(true, 'controllers/components-examples/flexberry-boundingbox/settings-example.js should pass jscs.');
  });
});
define('dummy/tests/controllers/components-examples/flexberry-boundingbox/settings-example.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - controllers/components-examples/flexberry-boundingbox/settings-example.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'controllers/components-examples/flexberry-boundingbox/settings-example.js should pass jshint.');
  });
});
define('dummy/tests/controllers/map.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - controllers');
  test('controllers/map.js should pass jscs', function () {
    ok(true, 'controllers/map.js should pass jscs.');
  });
});
define('dummy/tests/controllers/map.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - controllers/map.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'controllers/map.js should pass jshint.');
  });
});
define('dummy/tests/controllers/map/new.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - controllers/map');
  test('controllers/map/new.js should pass jscs', function () {
    ok(true, 'controllers/map/new.js should pass jscs.');
  });
});
define('dummy/tests/controllers/map/new.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - controllers/map/new.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'controllers/map/new.js should pass jshint.');
  });
});
define('dummy/tests/controllers/maps.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - controllers');
  test('controllers/maps.js should pass jscs', function () {
    ok(true, 'controllers/maps.js should pass jscs.');
  });
});
define('dummy/tests/controllers/maps.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - controllers/maps.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'controllers/maps.js should pass jshint.');
  });
});
define('dummy/tests/controllers/new-platform-flexberry-g-i-s-map-object-setting-e.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - controllers');
  test('controllers/new-platform-flexberry-g-i-s-map-object-setting-e.js should pass jscs', function () {
    ok(true, 'controllers/new-platform-flexberry-g-i-s-map-object-setting-e.js should pass jscs.');
  });
});
define('dummy/tests/controllers/new-platform-flexberry-g-i-s-map-object-setting-e.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - controllers/new-platform-flexberry-g-i-s-map-object-setting-e.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'controllers/new-platform-flexberry-g-i-s-map-object-setting-e.js should pass jshint.');
  });
});
define('dummy/tests/controllers/new-platform-flexberry-g-i-s-map-object-setting-e/new.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - controllers/new-platform-flexberry-g-i-s-map-object-setting-e');
  test('controllers/new-platform-flexberry-g-i-s-map-object-setting-e/new.js should pass jscs', function () {
    ok(true, 'controllers/new-platform-flexberry-g-i-s-map-object-setting-e/new.js should pass jscs.');
  });
});
define('dummy/tests/controllers/new-platform-flexberry-g-i-s-map-object-setting-e/new.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - controllers/new-platform-flexberry-g-i-s-map-object-setting-e/new.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'controllers/new-platform-flexberry-g-i-s-map-object-setting-e/new.js should pass jshint.');
  });
});
define('dummy/tests/controllers/new-platform-flexberry-g-i-s-map-object-setting-l.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - controllers');
  test('controllers/new-platform-flexberry-g-i-s-map-object-setting-l.js should pass jscs', function () {
    ok(true, 'controllers/new-platform-flexberry-g-i-s-map-object-setting-l.js should pass jscs.');
  });
});
define('dummy/tests/controllers/new-platform-flexberry-g-i-s-map-object-setting-l.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - controllers/new-platform-flexberry-g-i-s-map-object-setting-l.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'controllers/new-platform-flexberry-g-i-s-map-object-setting-l.js should pass jshint.');
  });
});
define('dummy/tests/controllers/sitemap-node.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - controllers');
  test('controllers/sitemap-node.js should pass jscs', function () {
    ok(true, 'controllers/sitemap-node.js should pass jscs.');
  });
});
define('dummy/tests/controllers/sitemap-node.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - controllers/sitemap-node.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'controllers/sitemap-node.js should pass jshint.');
  });
});
define('dummy/tests/helpers/destroy-app', ['exports', 'ember'], function (exports, _ember) {
  exports['default'] = destroyApp;

  function destroyApp(application) {
    _ember['default'].run(application, 'destroy');
  }
});
define('dummy/tests/helpers/destroy-app.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - helpers');
  test('helpers/destroy-app.js should pass jscs', function () {
    ok(true, 'helpers/destroy-app.js should pass jscs.');
  });
});
define('dummy/tests/helpers/destroy-app.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - helpers/destroy-app.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'helpers/destroy-app.js should pass jshint.');
  });
});
define('dummy/tests/helpers/ember-i18n/test-helpers', ['exports', 'ember'], function (exports, _ember) {

  // example usage: find(`.header:contains(${t('welcome_message')})`)
  _ember['default'].Test.registerHelper('t', function (app, key, interpolations) {
    var i18n = app.__container__.lookup('service:i18n');
    return i18n.t(key, interpolations);
  });

  // example usage: expectTranslation('.header', 'welcome_message');
  _ember['default'].Test.registerHelper('expectTranslation', function (app, element, key, interpolations) {
    var text = app.testHelpers.t(key, interpolations);

    assertTranslation(element, key, text);
  });

  var assertTranslation = (function () {
    if (typeof QUnit !== 'undefined' && typeof ok === 'function') {
      return function (element, key, text) {
        ok(find(element + ':contains(' + text + ')').length, 'Found translation key ' + key + ' in ' + element);
      };
    } else if (typeof expect === 'function') {
      return function (element, key, text) {
        var found = !!find(element + ':contains(' + text + ')').length;
        expect(found).to.equal(true);
      };
    } else {
      return function () {
        throw new Error("ember-i18n could not find a compatible test framework");
      };
    }
  })();
});
define('dummy/tests/helpers/module-for-acceptance', ['exports', 'qunit', 'dummy/tests/helpers/start-app', 'dummy/tests/helpers/destroy-app'], function (exports, _qunit, _dummyTestsHelpersStartApp, _dummyTestsHelpersDestroyApp) {
  exports['default'] = function (name) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    (0, _qunit.module)(name, {
      beforeEach: function beforeEach() {
        this.application = (0, _dummyTestsHelpersStartApp['default'])();

        if (options.beforeEach) {
          options.beforeEach.apply(this, arguments);
        }
      },

      afterEach: function afterEach() {
        if (options.afterEach) {
          options.afterEach.apply(this, arguments);
        }

        (0, _dummyTestsHelpersDestroyApp['default'])(this.application);
      }
    });
  };
});
define('dummy/tests/helpers/module-for-acceptance.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - helpers');
  test('helpers/module-for-acceptance.js should pass jscs', function () {
    ok(true, 'helpers/module-for-acceptance.js should pass jscs.');
  });
});
define('dummy/tests/helpers/module-for-acceptance.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - helpers/module-for-acceptance.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'helpers/module-for-acceptance.js should pass jshint.');
  });
});
define('dummy/tests/helpers/resolver', ['exports', 'dummy/resolver', 'dummy/config/environment'], function (exports, _dummyResolver, _dummyConfigEnvironment) {

  var resolver = _dummyResolver['default'].create();

  resolver.namespace = {
    modulePrefix: _dummyConfigEnvironment['default'].modulePrefix,
    podModulePrefix: _dummyConfigEnvironment['default'].podModulePrefix
  };

  exports['default'] = resolver;
});
define('dummy/tests/helpers/resolver.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - helpers');
  test('helpers/resolver.js should pass jscs', function () {
    ok(true, 'helpers/resolver.js should pass jscs.');
  });
});
define('dummy/tests/helpers/resolver.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - helpers/resolver.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'helpers/resolver.js should pass jshint.');
  });
});
define('dummy/tests/helpers/start-app', ['exports', 'ember', 'dummy/app', 'dummy/config/environment'], function (exports, _ember, _dummyApp, _dummyConfigEnvironment) {
  exports['default'] = startApp;

  function startApp(attrs) {
    var application = undefined;

    var attributes = _ember['default'].merge({}, _dummyConfigEnvironment['default'].APP);
    attributes = _ember['default'].merge(attributes, attrs); // use defaults, but you can override;

    _ember['default'].run(function () {
      application = _dummyApp['default'].create(attributes);
      application.setupForTesting();
      application.injectTestHelpers();
    });

    return application;
  }
});
define('dummy/tests/helpers/start-app.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - helpers');
  test('helpers/start-app.js should pass jscs', function () {
    ok(true, 'helpers/start-app.js should pass jscs.');
  });
});
define('dummy/tests/helpers/start-app.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - helpers/start-app.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'helpers/start-app.js should pass jshint.');
  });
});
define('dummy/tests/helpers/to-safe-string.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - helpers');
  test('helpers/to-safe-string.js should pass jscs', function () {
    ok(true, 'helpers/to-safe-string.js should pass jscs.');
  });
});
define('dummy/tests/helpers/to-safe-string.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - helpers/to-safe-string.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'helpers/to-safe-string.js should pass jshint.');
  });
});
define('dummy/tests/helpers/to-string.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - helpers');
  test('helpers/to-string.js should pass jscs', function () {
    ok(true, 'helpers/to-string.js should pass jscs.');
  });
});
define('dummy/tests/helpers/to-string.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - helpers/to-string.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'helpers/to-string.js should pass jshint.');
  });
});
define('dummy/tests/helpers/validate-properties', ['exports', 'ember', 'ember-qunit'], function (exports, _ember, _emberQunit) {
  exports.testValidPropertyValues = testValidPropertyValues;
  exports.testInvalidPropertyValues = testInvalidPropertyValues;

  var run = _ember['default'].run;

  function validateValues(object, propertyName, values, isTestForValid) {
    var promise = null;
    var validatedValues = [];

    values.forEach(function (value) {
      function handleValidation(errors) {
        var hasErrors = object.get('errors.' + propertyName + '.firstObject');
        if (hasErrors && !isTestForValid || !hasErrors && isTestForValid) {
          validatedValues.push(value);
        }
      }

      run(object, 'set', propertyName, value);

      var objectPromise = null;
      run(function () {
        objectPromise = object.validate().then(handleValidation, handleValidation);
      });

      // Since we are setting the values in a different run loop as we are validating them,
      // we need to chain the promises so that they run sequentially. The wrong value will
      // be validated if the promises execute concurrently
      promise = promise ? promise.then(objectPromise) : objectPromise;
    });

    return promise.then(function () {
      return validatedValues;
    });
  }

  function testPropertyValues(propertyName, values, isTestForValid, context) {
    var validOrInvalid = isTestForValid ? 'Valid' : 'Invalid';
    var testName = validOrInvalid + ' ' + propertyName;

    (0, _emberQunit.test)(testName, function (assert) {
      var object = this.subject();

      if (context && typeof context === 'function') {
        context(object);
      }

      // Use QUnit.dump.parse so null and undefined can be printed as literal 'null' and
      // 'undefined' strings in the assert message.
      var valuesString = QUnit.dump.parse(values).replace(/\n(\s+)?/g, '').replace(/,/g, ', ');
      var assertMessage = 'Expected ' + propertyName + ' to have ' + validOrInvalid.toLowerCase() + ' values: ' + valuesString;

      return validateValues(object, propertyName, values, isTestForValid).then(function (validatedValues) {
        assert.deepEqual(validatedValues, values, assertMessage);
      });
    });
  }

  function testValidPropertyValues(propertyName, values, context) {
    testPropertyValues(propertyName, values, true, context);
  }

  function testInvalidPropertyValues(propertyName, values, context) {
    testPropertyValues(propertyName, values, false, context);
  }
});
define('dummy/tests/integration/components/flexberry-boundingbox-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForComponent)('flexberry-boundingbox', 'Integration | Component | flexberry boundingbox', {
    integration: true
  });

  (0, _emberQunit.test)('temporary test', function (assert) {
    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.on('myAction', function(val) { ... });
    assert.equal('', '');
  });
});
define('dummy/tests/integration/components/flexberry-boundingbox-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components');
  test('integration/components/flexberry-boundingbox-test.js should pass jscs', function () {
    ok(true, 'integration/components/flexberry-boundingbox-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/flexberry-boundingbox-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/flexberry-boundingbox-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/flexberry-boundingbox-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/flexberry-dropdown-input-test', ['exports', 'ember', 'ember-qunit', 'ember-i18n/services/i18n', 'ember-flexberry/locales/ru/translations', 'ember-flexberry/locales/en/translations'], function (exports, _ember, _emberQunit, _emberI18nServicesI18n, _emberFlexberryLocalesRuTranslations, _emberFlexberryLocalesEnTranslations) {

  (0, _emberQunit.moduleForComponent)('flexberry-dropdown-input', 'Integration | Component | flexberry dropdown input', {
    beforeEach: function beforeEach(assert) {
      this.register('locale:ru/translations', _emberFlexberryLocalesRuTranslations['default']);
      this.register('locale:en/translations', _emberFlexberryLocalesEnTranslations['default']);
      this.register('service:i18n', _emberI18nServicesI18n['default']);

      this.inject.service('i18n', { as: 'i18n' });
      _ember['default'].Component.reopen({
        i18n: _ember['default'].inject.service('i18n')
      });

      this.set('i18n.locale', 'ru');
    },

    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {
    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.on('myAction', function(val) { ... });

    this.render(_ember['default'].HTMLBars.template((function () {
      return {
        meta: {
          'fragmentReason': {
            'name': 'missing-wrapper',
            'problems': ['wrong-type']
          },
          'revision': 'Ember@2.4.6',
          'loc': {
            'source': null,
            'start': {
              'line': 1,
              'column': 0
            },
            'end': {
              'line': 1,
              'column': 28
            }
          }
        },
        isEmpty: false,
        arity: 0,
        cachedFragment: null,
        hasRendered: false,
        buildFragment: function buildFragment(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment('');
          dom.appendChild(el0, el1);
          return el0;
        },
        buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
          var morphs = new Array(1);
          morphs[0] = dom.createMorphAt(fragment, 0, 0, contextualElement);
          dom.insertBoundary(fragment, 0);
          dom.insertBoundary(fragment, null);
          return morphs;
        },
        statements: [['content', 'flexberry-dropdown-input', ['loc', [null, [1, 0], [1, 28]]]]],
        locals: [],
        templates: []
      };
    })()));

    assert.equal(this.$().text().trim(), '(нет значения)');
  });
});
define('dummy/tests/integration/components/flexberry-dropdown-input-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components');
  test('integration/components/flexberry-dropdown-input-test.js should pass jscs', function () {
    ok(true, 'integration/components/flexberry-dropdown-input-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/flexberry-dropdown-input-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/flexberry-dropdown-input-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/flexberry-dropdown-input-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/flexberry-edit-crs-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForComponent)('flexberry-edit-crs', 'Integration | Component | flexberry edit crs', {
    integration: true
  });

  (0, _emberQunit.test)('temp test', function (assert) {
    assert.equal('', '');
  });
});
define('dummy/tests/integration/components/flexberry-edit-crs-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components');
  test('integration/components/flexberry-edit-crs-test.js should pass jscs', function () {
    ok(true, 'integration/components/flexberry-edit-crs-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/flexberry-edit-crs-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/flexberry-edit-crs-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/flexberry-edit-crs-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/flexberry-layers-attributes-panel-test', ['exports', 'ember-qunit', 'ember', 'ember-i18n/services/i18n', 'ember-flexberry-gis/locales/ru/translations', 'ember-flexberry-gis/locales/en/translations'], function (exports, _emberQunit, _ember, _emberI18nServicesI18n, _emberFlexberryGisLocalesRuTranslations, _emberFlexberryGisLocalesEnTranslations) {

  (0, _emberQunit.moduleForComponent)('flexberry-layers-attributes-panel', 'Integration | Component | flexberry layers attributes panel', {

    beforeEach: function beforeEach(assert) {
      this.register('locale:ru/translations', _emberFlexberryGisLocalesRuTranslations['default']);
      this.register('locale:en/translations', _emberFlexberryGisLocalesEnTranslations['default']);
      this.register('service:i18n', _emberI18nServicesI18n['default']);

      this.inject.service('i18n', { as: 'i18n' });
      _ember['default'].Component.reopen({
        i18n: _ember['default'].inject.service('i18n')
      });

      this.set('i18n.locale', 'en');
    },

    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {
    assert.equal(this.$().text().trim(), '');

    var geoJsonData = '\n    {\n      "type": "FeatureCollection",\n      "features": [{\n        "type": "Feature",\n        "geometry": {\n          "type": "Point",\n          "coordinates": [102.0, 0.5]\n        },\n        "properties": {\n          "prop0": "value0"\n        }\n      }\n    ]\n  }';
    var geoJson = L.geoJSON(JSON.parse(geoJsonData));
    _ember['default'].set(geoJson, 'readFormat', {
      featureType: {
        fieldTypes: { prop0: 'string' },
        fields: { prop0: function prop0(val) {
            return val;
          } }
      }
    });
    this.set('items', _ember['default'].A([{
      name: 'test layer',
      leafletObject: geoJson
    }]));

    this.render(_ember['default'].HTMLBars.template((function () {
      return {
        meta: {
          'fragmentReason': {
            'name': 'missing-wrapper',
            'problems': ['wrong-type']
          },
          'revision': 'Ember@2.4.6',
          'loc': {
            'source': null,
            'start': {
              'line': 1,
              'column': 0
            },
            'end': {
              'line': 3,
              'column': 2
            }
          }
        },
        isEmpty: false,
        arity: 0,
        cachedFragment: null,
        hasRendered: false,
        buildFragment: function buildFragment(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode('\n    ');
          dom.appendChild(el0, el1);
          var el1 = dom.createComment('');
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode('\n  ');
          dom.appendChild(el0, el1);
          return el0;
        },
        buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
          var morphs = new Array(1);
          morphs[0] = dom.createMorphAt(fragment, 1, 1, contextualElement);
          return morphs;
        },
        statements: [['inline', 'flexberry-layers-attributes-panel', [], ['items', ['subexpr', '@mut', [['get', 'items', ['loc', [null, [2, 46], [2, 51]]]]], [], []], 'folded', false], ['loc', [null, [2, 4], [2, 66]]]]],
        locals: [],
        templates: []
      };
    })()));

    var $tab = this.$().find('div[data-tab="test layer"]');

    assert.equal($tab.length, 1, 'Layer tab was rendered');
    assert.equal($tab.find('tbody td:last-child').text().trim(), 'value0', 'Property cell was rendered');
  });
});
define('dummy/tests/integration/components/flexberry-layers-attributes-panel-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components');
  test('integration/components/flexberry-layers-attributes-panel-test.js should pass jscs', function () {
    ok(true, 'integration/components/flexberry-layers-attributes-panel-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/flexberry-layers-attributes-panel-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/flexberry-layers-attributes-panel-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/flexberry-layers-attributes-panel-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/flexberry-layers-intersections-panel-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  // import hbs from 'htmlbars-inline-precompile';

  (0, _emberQunit.moduleForComponent)('flexberry-layers-intersections-panel', 'Integration | Component | flexberry layers intersections panel', {
    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {
    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.on('myAction', function(val) { ... });

    // this.render(hbs`{{flexberry-layers-intersections-panel}}`);

    assert.equal(this.$().text().trim(), '');

    // Template block usage:
    // this.render(hbs`
    //   {{#flexberry-layers-intersections-panel}}
    //     template block text
    //   {{/flexberry-layers-intersections-panel}}
    // `);

    // assert.equal(this.$().text().trim(), 'template block text');
  });
});
define('dummy/tests/integration/components/flexberry-layers-intersections-panel-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components');
  test('integration/components/flexberry-layers-intersections-panel-test.js should pass jscs', function () {
    ok(true, 'integration/components/flexberry-layers-intersections-panel-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/flexberry-layers-intersections-panel-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/flexberry-layers-intersections-panel-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/flexberry-layers-intersections-panel-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/flexberry-layers-test', ['exports', 'ember', 'ember-qunit'], function (exports, _ember, _emberQunit) {

  (0, _emberQunit.moduleForComponent)('flexberry-layers', 'Integration | Component | flexberry layers', {
    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {
    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.on('myAction', function(val) { ... });

    this.render(_ember['default'].HTMLBars.template((function () {
      return {
        meta: {
          'fragmentReason': {
            'name': 'missing-wrapper',
            'problems': ['wrong-type']
          },
          'revision': 'Ember@2.4.6',
          'loc': {
            'source': null,
            'start': {
              'line': 1,
              'column': 0
            },
            'end': {
              'line': 1,
              'column': 20
            }
          }
        },
        isEmpty: false,
        arity: 0,
        cachedFragment: null,
        hasRendered: false,
        buildFragment: function buildFragment(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment('');
          dom.appendChild(el0, el1);
          return el0;
        },
        buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
          var morphs = new Array(1);
          morphs[0] = dom.createMorphAt(fragment, 0, 0, contextualElement);
          dom.insertBoundary(fragment, 0);
          dom.insertBoundary(fragment, null);
          return morphs;
        },
        statements: [['content', 'flexberry-layers', ['loc', [null, [1, 0], [1, 20]]]]],
        locals: [],
        templates: []
      };
    })()));

    assert.equal(this.$().text().trim(), '');
  });

  (0, _emberQunit.test)('layer component sends actions', function (assert) {
    var geoJsonData = '\n    {\n      "type": "FeatureCollection",\n      "features": [{\n        "type": "Feature",\n        "geometry": {\n          "type": "Point",\n          "coordinates": [102.0, 0.5]\n        },\n        "properties": {\n          "prop0": "value0"\n        }\n      }\n    ]\n  }';
    var geoJson = L.geoJSON(JSON.parse(geoJsonData));
    this.set('items', _ember['default'].A([{
      name: 'test layer',
      type: 'geojson',
      leafletObject: geoJson
    }]));
    this.set('leafletContainer', L.layerGroup());

    this.on('onLayerInit', function (_ref) {
      var leafletObject = _ref.leafletObject;
      var layerModel = _ref.layerModel;

      assert.ok(!_ember['default'].isNone(leafletObject), 'leafletObject should not be null');
      assert.equal(_ember['default'].get(layerModel, 'name'), 'test layer');
    });

    this.on('onLayerDestroy', function (_ref2) {
      var leafletObject = _ref2.leafletObject;
      var layerModel = _ref2.layerModel;

      assert.ok(!_ember['default'].isNone(leafletObject), 'leafletObject should not be null');
      assert.equal(_ember['default'].get(layerModel, 'name'), 'test layer');
    });

    this.render(_ember['default'].HTMLBars.template((function () {
      return {
        meta: {
          'fragmentReason': {
            'name': 'missing-wrapper',
            'problems': ['wrong-type']
          },
          'revision': 'Ember@2.4.6',
          'loc': {
            'source': null,
            'start': {
              'line': 1,
              'column': 0
            },
            'end': {
              'line': 15,
              'column': 9
            }
          }
        },
        isEmpty: false,
        arity: 0,
        cachedFragment: null,
        hasRendered: false,
        buildFragment: function buildFragment(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode('\n    ');
          dom.appendChild(el0, el1);
          var el1 = dom.createComment('');
          dom.appendChild(el0, el1);
          return el0;
        },
        buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
          var morphs = new Array(1);
          morphs[0] = dom.createMorphAt(fragment, 1, 1, contextualElement);
          dom.insertBoundary(fragment, null);
          return morphs;
        },
        statements: [['inline', 'flexberry-layers', [], ['leafletContainer', ['subexpr', '@mut', [['get', 'leafletContainer', ['loc', [null, [3, 23], [3, 39]]]]], [], []], 'layers', ['subexpr', 'get-with-dynamic-actions', [['get', 'this', ['loc', [null, [4, 39], [4, 43]]]], 'items'], ['dynamicActions', ['subexpr', 'array', [['subexpr', 'hash', [], ['on', 'layerInit', 'actionName', 'onLayerInit'], ['loc', [null, [6, 10], [9, 11]]]], ['subexpr', 'hash', [], ['on', 'layerDestroy', 'actionName', 'onLayerDestroy'], ['loc', [null, [10, 10], [13, 11]]]]], [], ['loc', [null, [5, 23], [14, 9]]]]], ['loc', [null, [4, 13], [15, 7]]]]], ['loc', [null, [2, 4], [15, 9]]]]],
        locals: [],
        templates: []
      };
    })()));
  });
});
define('dummy/tests/integration/components/flexberry-layers-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components');
  test('integration/components/flexberry-layers-test.js should pass jscs', function () {
    ok(true, 'integration/components/flexberry-layers-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/flexberry-layers-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/flexberry-layers-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/flexberry-layers-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/flexberry-map-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForComponent)('flexberry-map', 'Integration | Component | flexberry map', {
    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {
    assert.expect(0);

    this.render(Ember.HTMLBars.template((function () {
      return {
        meta: {
          'fragmentReason': {
            'name': 'missing-wrapper',
            'problems': ['wrong-type']
          },
          'revision': 'Ember@2.4.6',
          'loc': {
            'source': null,
            'start': {
              'line': 1,
              'column': 0
            },
            'end': {
              'line': 1,
              'column': 17
            }
          }
        },
        isEmpty: false,
        arity: 0,
        cachedFragment: null,
        hasRendered: false,
        buildFragment: function buildFragment(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment('');
          dom.appendChild(el0, el1);
          return el0;
        },
        buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
          var morphs = new Array(1);
          morphs[0] = dom.createMorphAt(fragment, 0, 0, contextualElement);
          dom.insertBoundary(fragment, 0);
          dom.insertBoundary(fragment, null);
          return morphs;
        },
        statements: [['content', 'flexberry-map', ['loc', [null, [1, 0], [1, 17]]]]],
        locals: [],
        templates: []
      };
    })()));

    // Template block usage:
    this.render(Ember.HTMLBars.template((function () {
      var child0 = (function () {
        return {
          meta: {
            'fragmentReason': false,
            'revision': 'Ember@2.4.6',
            'loc': {
              'source': null,
              'start': {
                'line': 2,
                'column': 4
              },
              'end': {
                'line': 4,
                'column': 4
              }
            }
          },
          isEmpty: false,
          arity: 0,
          cachedFragment: null,
          hasRendered: false,
          buildFragment: function buildFragment(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode('      template block text\n');
            dom.appendChild(el0, el1);
            return el0;
          },
          buildRenderNodes: function buildRenderNodes() {
            return [];
          },
          statements: [],
          locals: [],
          templates: []
        };
      })();

      return {
        meta: {
          'fragmentReason': {
            'name': 'missing-wrapper',
            'problems': ['wrong-type']
          },
          'revision': 'Ember@2.4.6',
          'loc': {
            'source': null,
            'start': {
              'line': 1,
              'column': 0
            },
            'end': {
              'line': 5,
              'column': 2
            }
          }
        },
        isEmpty: false,
        arity: 0,
        cachedFragment: null,
        hasRendered: false,
        buildFragment: function buildFragment(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode('\n');
          dom.appendChild(el0, el1);
          var el1 = dom.createComment('');
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode('  ');
          dom.appendChild(el0, el1);
          return el0;
        },
        buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
          var morphs = new Array(1);
          morphs[0] = dom.createMorphAt(fragment, 1, 1, contextualElement);
          return morphs;
        },
        statements: [['block', 'flexberry-map', [], ['model', ['subexpr', '@mut', [['get', 'model', ['loc', [null, [2, 27], [2, 32]]]]], [], []]], 0, null, ['loc', [null, [2, 4], [4, 22]]]]],
        locals: [],
        templates: [child0]
      };
    })()));
  });
});
define('dummy/tests/integration/components/flexberry-map-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components');
  test('integration/components/flexberry-map-test.js should pass jscs', function () {
    ok(true, 'integration/components/flexberry-map-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/flexberry-map-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/flexberry-map-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/flexberry-map-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/flexberry-maptoolbar-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForComponent)('flexberry-maptoolbar', 'Integration | Component | flexberry maptoolbar', {
    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {
    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.on('myAction', function(val) { ... });

    this.render(Ember.HTMLBars.template((function () {
      return {
        meta: {
          'fragmentReason': {
            'name': 'missing-wrapper',
            'problems': ['wrong-type']
          },
          'revision': 'Ember@2.4.6',
          'loc': {
            'source': null,
            'start': {
              'line': 1,
              'column': 0
            },
            'end': {
              'line': 1,
              'column': 24
            }
          }
        },
        isEmpty: false,
        arity: 0,
        cachedFragment: null,
        hasRendered: false,
        buildFragment: function buildFragment(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment('');
          dom.appendChild(el0, el1);
          return el0;
        },
        buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
          var morphs = new Array(1);
          morphs[0] = dom.createMorphAt(fragment, 0, 0, contextualElement);
          dom.insertBoundary(fragment, 0);
          dom.insertBoundary(fragment, null);
          return morphs;
        },
        statements: [['content', 'flexberry-maptoolbar', ['loc', [null, [1, 0], [1, 24]]]]],
        locals: [],
        templates: []
      };
    })()));

    assert.equal(this.$().text().trim(), '');

    // Template block usage:
    this.render(Ember.HTMLBars.template((function () {
      var child0 = (function () {
        return {
          meta: {
            'fragmentReason': false,
            'revision': 'Ember@2.4.6',
            'loc': {
              'source': null,
              'start': {
                'line': 2,
                'column': 4
              },
              'end': {
                'line': 4,
                'column': 4
              }
            }
          },
          isEmpty: false,
          arity: 0,
          cachedFragment: null,
          hasRendered: false,
          buildFragment: function buildFragment(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode('      template block text\n');
            dom.appendChild(el0, el1);
            return el0;
          },
          buildRenderNodes: function buildRenderNodes() {
            return [];
          },
          statements: [],
          locals: [],
          templates: []
        };
      })();

      return {
        meta: {
          'fragmentReason': {
            'name': 'missing-wrapper',
            'problems': ['wrong-type']
          },
          'revision': 'Ember@2.4.6',
          'loc': {
            'source': null,
            'start': {
              'line': 1,
              'column': 0
            },
            'end': {
              'line': 5,
              'column': 2
            }
          }
        },
        isEmpty: false,
        arity: 0,
        cachedFragment: null,
        hasRendered: false,
        buildFragment: function buildFragment(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode('\n');
          dom.appendChild(el0, el1);
          var el1 = dom.createComment('');
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode('  ');
          dom.appendChild(el0, el1);
          return el0;
        },
        buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
          var morphs = new Array(1);
          morphs[0] = dom.createMorphAt(fragment, 1, 1, contextualElement);
          return morphs;
        },
        statements: [['block', 'flexberry-maptoolbar', [], [], 0, null, ['loc', [null, [2, 4], [4, 29]]]]],
        locals: [],
        templates: [child0]
      };
    })()));

    assert.equal(this.$().text().trim(), 'template block text');
  });
});
define('dummy/tests/integration/components/flexberry-maptoolbar-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components');
  test('integration/components/flexberry-maptoolbar-test.js should pass jscs', function () {
    ok(true, 'integration/components/flexberry-maptoolbar-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/flexberry-maptoolbar-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/flexberry-maptoolbar-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/flexberry-maptoolbar-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/flexberry-multiple-select-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForComponent)('flexberry-multiple-select', 'Integration | Component | flexberry multiple select', {
    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {
    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.on('myAction', function(val) { ... });

    this.render(Ember.HTMLBars.template((function () {
      return {
        meta: {
          'fragmentReason': {
            'name': 'missing-wrapper',
            'problems': ['wrong-type']
          },
          'revision': 'Ember@2.4.6',
          'loc': {
            'source': null,
            'start': {
              'line': 1,
              'column': 0
            },
            'end': {
              'line': 1,
              'column': 46
            }
          }
        },
        isEmpty: false,
        arity: 0,
        cachedFragment: null,
        hasRendered: false,
        buildFragment: function buildFragment(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment('');
          dom.appendChild(el0, el1);
          return el0;
        },
        buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
          var morphs = new Array(1);
          morphs[0] = dom.createMorphAt(fragment, 0, 0, contextualElement);
          dom.insertBoundary(fragment, 0);
          dom.insertBoundary(fragment, null);
          return morphs;
        },
        statements: [['inline', 'flexberry-multiple-select', [], ['title', 'testHead'], ['loc', [null, [1, 0], [1, 46]]]]],
        locals: [],
        templates: []
      };
    })()));

    assert.equal(this.$('.default.text').text().trim(), 'testHead');
  });
});
define('dummy/tests/integration/components/flexberry-multiple-select-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components');
  test('integration/components/flexberry-multiple-select-test.js should pass jscs', function () {
    ok(true, 'integration/components/flexberry-multiple-select-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/flexberry-multiple-select-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/flexberry-multiple-select-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/flexberry-multiple-select-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/flexberry-table-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForComponent)('flexberry-table', 'Integration | Component | flexberry table', {
    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {
    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.on('myAction', function(val) { ... });
    this.set('header', { name: 'gis-search-form.layer-metadata.header.name' });

    this.render(Ember.HTMLBars.template((function () {
      return {
        meta: {
          'fragmentReason': {
            'name': 'missing-wrapper',
            'problems': ['wrong-type']
          },
          'revision': 'Ember@2.4.6',
          'loc': {
            'source': null,
            'start': {
              'line': 1,
              'column': 0
            },
            'end': {
              'line': 1,
              'column': 33
            }
          }
        },
        isEmpty: false,
        arity: 0,
        cachedFragment: null,
        hasRendered: false,
        buildFragment: function buildFragment(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment('');
          dom.appendChild(el0, el1);
          return el0;
        },
        buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
          var morphs = new Array(1);
          morphs[0] = dom.createMorphAt(fragment, 0, 0, contextualElement);
          dom.insertBoundary(fragment, 0);
          dom.insertBoundary(fragment, null);
          return morphs;
        },
        statements: [['inline', 'flexberry-table', [], ['header', ['subexpr', '@mut', [['get', 'header', ['loc', [null, [1, 25], [1, 31]]]]], [], []]], ['loc', [null, [1, 0], [1, 33]]]]],
        locals: [],
        templates: []
      };
    })()));

    assert.notEqual(this.$().text().indexOf('No data'), -1, 'Should contain "No data"');

    // Template block usage:
    // this.render(hbs`
    //   {{#flexberry-table}}
    //     template block text
    //   {{/flexberry-table}}
    // `);

    // assert.equal(this.$().text().trim(), 'template block text');
  });
});
define('dummy/tests/integration/components/flexberry-table-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components');
  test('integration/components/flexberry-table-test.js should pass jscs', function () {
    ok(true, 'integration/components/flexberry-table-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/flexberry-table-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/flexberry-table-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/flexberry-table-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/flexberry-wfs-filter-test', ['exports', 'ember', 'ember-qunit', 'ember-i18n/services/i18n', 'ember-flexberry-gis/locales/ru/translations', 'ember-flexberry-gis/locales/en/translations'], function (exports, _ember, _emberQunit, _emberI18nServicesI18n, _emberFlexberryGisLocalesRuTranslations, _emberFlexberryGisLocalesEnTranslations) {

  (0, _emberQunit.moduleForComponent)('flexberry-wfs-filter', 'Integration | Component | flexberry wfs filter', {
    beforeEach: function beforeEach(assert) {
      this.register('locale:ru/translations', _emberFlexberryGisLocalesRuTranslations['default']);
      this.register('locale:en/translations', _emberFlexberryGisLocalesEnTranslations['default']);
      this.register('service:i18n', _emberI18nServicesI18n['default']);

      this.inject.service('i18n', { as: 'i18n' });
      _ember['default'].Component.reopen({
        i18n: _ember['default'].inject.service('i18n')
      });

      this.set('i18n.locale', 'en');
    },

    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {
    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.on('myAction', function(val) { ... });

    this.render(_ember['default'].HTMLBars.template((function () {
      return {
        meta: {
          'fragmentReason': {
            'name': 'missing-wrapper',
            'problems': ['wrong-type']
          },
          'revision': 'Ember@2.4.6',
          'loc': {
            'source': null,
            'start': {
              'line': 1,
              'column': 0
            },
            'end': {
              'line': 1,
              'column': 24
            }
          }
        },
        isEmpty: false,
        arity: 0,
        cachedFragment: null,
        hasRendered: false,
        buildFragment: function buildFragment(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment('');
          dom.appendChild(el0, el1);
          return el0;
        },
        buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
          var morphs = new Array(1);
          morphs[0] = dom.createMorphAt(fragment, 0, 0, contextualElement);
          dom.insertBoundary(fragment, 0);
          dom.insertBoundary(fragment, null);
          return morphs;
        },
        statements: [['content', 'flexberry-wfs-filter', ['loc', [null, [1, 0], [1, 24]]]]],
        locals: [],
        templates: []
      };
    })()));

    assert.notEqual(this.$().text().indexOf('Fields isn\'t loaded'), -1, 'Should contain "Fields isn\'t loaded"');
  });
});
define('dummy/tests/integration/components/flexberry-wfs-filter-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components');
  test('integration/components/flexberry-wfs-filter-test.js should pass jscs', function () {
    ok(true, 'integration/components/flexberry-wfs-filter-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/flexberry-wfs-filter-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/flexberry-wfs-filter-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/flexberry-wfs-filter-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/geometry-add-modes/draw-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  // import hbs from 'htmlbars-inline-precompile';

  (0, _emberQunit.moduleForComponent)('geometry-add-modes/draw', 'Integration | Component | geometry add modes/draw', {
    integration: true
  });

  (0, _emberQunit.test)('empty test', function (assert) {
    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.on('myAction', function(val) { ... });

    assert.equal('', '');

    // this.render(hbs`{{geometry-add-modes/draw}}`);

    // assert.equal(this.$().text().trim(), '');

    // Template block usage:
    // this.render(hbs`
    //   {{#geometry-add-modes/draw}}
    //     template block text
    //   {{/geometry-add-modes/draw}}
    // `);

    // assert.equal(this.$().text().trim(), 'template block text');
  });
});
define('dummy/tests/integration/components/geometry-add-modes/draw-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components/geometry-add-modes');
  test('integration/components/geometry-add-modes/draw-test.js should pass jscs', function () {
    ok(true, 'integration/components/geometry-add-modes/draw-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/geometry-add-modes/draw-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/geometry-add-modes/draw-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/geometry-add-modes/draw-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/geometry-add-modes/geoprovider-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  // import hbs from 'htmlbars-inline-precompile';

  (0, _emberQunit.moduleForComponent)('geometry-add-modes/geoprovider', 'Integration | Component | geometry add modes/geoprovider', {
    integration: true
  });

  (0, _emberQunit.test)('empty test', function (assert) {
    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.on('myAction', function(val) { ... });

    // this.render(hbs`{{geometry-add-modes/geoprovider}}`);

    // assert.equal(this.$().text().trim(), '');

    assert.equal('', '');

    // Template block usage:
    // this.render(hbs`
    //   {{#geometry-add-modes/geoprovider}}
    //     template block text
    //   {{/geometry-add-modes/geoprovider}}
    // `);

    // assert.equal(this.$().text().trim(), 'template block text');
  });
});
define('dummy/tests/integration/components/geometry-add-modes/geoprovider-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components/geometry-add-modes');
  test('integration/components/geometry-add-modes/geoprovider-test.js should pass jscs', function () {
    ok(true, 'integration/components/geometry-add-modes/geoprovider-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/geometry-add-modes/geoprovider-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/geometry-add-modes/geoprovider-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/geometry-add-modes/geoprovider-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/geometry-add-modes/manual-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  // import hbs from 'htmlbars-inline-precompile';

  (0, _emberQunit.moduleForComponent)('geometry-add-modes/manual', 'Integration | Component | geometry add modes/manual', {
    integration: true
  });

  (0, _emberQunit.test)('empty test', function (assert) {
    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.on('myAction', function(val) { ... });

    // this.render(hbs`{{geometry-add-modes/manual}}`);

    // assert.equal(this.$().text().trim(), '');

    assert.equal('', '');

    // Template block usage:
    // this.render(hbs`
    //   {{#geometry-add-modes/manual}}
    //     template block text
    //   {{/geometry-add-modes/manual}}
    // `);

    // assert.equal(this.$().text().trim(), 'template block text');
  });
});
define('dummy/tests/integration/components/geometry-add-modes/manual-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components/geometry-add-modes');
  test('integration/components/geometry-add-modes/manual-test.js should pass jscs', function () {
    ok(true, 'integration/components/geometry-add-modes/manual-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/geometry-add-modes/manual-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/geometry-add-modes/manual-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/geometry-add-modes/manual-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/layers-dialogs/attributes/edit-test', ['exports', 'ember', 'ember-qunit', 'ember-i18n/services/i18n', 'ember-flexberry-gis/locales/ru/translations', 'ember-flexberry-gis/locales/en/translations'], function (exports, _ember, _emberQunit, _emberI18nServicesI18n, _emberFlexberryGisLocalesRuTranslations, _emberFlexberryGisLocalesEnTranslations) {

  (0, _emberQunit.moduleForComponent)('layers-dialogs/attributes/edit', 'Integration | Component | layers dialogs/attributes/edit', {
    integration: true,

    beforeEach: function beforeEach() {
      this.register('locale:ru/translations', _emberFlexberryGisLocalesRuTranslations['default']);
      this.register('locale:en/translations', _emberFlexberryGisLocalesEnTranslations['default']);
      this.register('service:i18n', _emberI18nServicesI18n['default']);

      this.inject.service('i18n', { as: 'i18n' });
      _ember['default'].Component.reopen({
        i18n: _ember['default'].inject.service('i18n')
      });

      // Set 'ru' as initial locale.
      this.set('i18n.locale', 'ru');
    }
  });

  (0, _emberQunit.test)('it renders', function (assert) {
    assert.expect(1);

    this.set('fieldNames', {
      field: 'field'
    });
    this.set('fieldTypes', {
      field: 'string'
    });
    this.set('fieldParsers', {
      field: function field(text) {
        return text;
      }
    });
    this.set('fieldValidators', {
      field: function field(value) {
        return true;
      }
    });
    this.set('data', {
      field: 'test field'
    });

    this.set('visible', true);

    this.render(_ember['default'].HTMLBars.template((function () {
      return {
        meta: {
          'fragmentReason': {
            'name': 'missing-wrapper',
            'problems': ['wrong-type']
          },
          'revision': 'Ember@2.4.6',
          'loc': {
            'source': null,
            'start': {
              'line': 1,
              'column': 0
            },
            'end': {
              'line': 9,
              'column': 6
            }
          }
        },
        isEmpty: false,
        arity: 0,
        cachedFragment: null,
        hasRendered: false,
        buildFragment: function buildFragment(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode('\n    ');
          dom.appendChild(el0, el1);
          var el1 = dom.createComment('');
          dom.appendChild(el0, el1);
          return el0;
        },
        buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
          var morphs = new Array(1);
          morphs[0] = dom.createMorphAt(fragment, 1, 1, contextualElement);
          dom.insertBoundary(fragment, null);
          return morphs;
        },
        statements: [['inline', 'layers-dialogs/attributes/edit', [], ['visible', ['subexpr', '@mut', [['get', 'visible', ['loc', [null, [3, 14], [3, 21]]]]], [], []], 'fieldNames', ['subexpr', '@mut', [['get', 'fieldNames', ['loc', [null, [4, 17], [4, 27]]]]], [], []], 'fieldTypes', ['subexpr', '@mut', [['get', 'fieldTypes', ['loc', [null, [5, 17], [5, 27]]]]], [], []], 'fieldParsers', ['subexpr', '@mut', [['get', 'fieldParsers', ['loc', [null, [6, 19], [6, 31]]]]], [], []], 'fieldValidators', ['subexpr', '@mut', [['get', 'fieldValidators', ['loc', [null, [7, 22], [7, 37]]]]], [], []], 'data', ['subexpr', '@mut', [['get', 'data', ['loc', [null, [8, 11], [8, 15]]]]], [], []]], ['loc', [null, [2, 4], [9, 6]]]]],
        locals: [],
        templates: []
      };
    })()));

    // Component is rendered outside of the testing container.
    var $dialog = this.$().closest('#ember-testing-container').siblings('.ui.modals').find('.flexberry-edit-layer-attributes-dialog');

    assert.ok($dialog.find('.flexberry-dialog-content .field input').length === 1, 'It renders one input');
  });
});
define('dummy/tests/integration/components/layers-dialogs/attributes/edit-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components/layers-dialogs/attributes');
  test('integration/components/layers-dialogs/attributes/edit-test.js should pass jscs', function () {
    ok(true, 'integration/components/layers-dialogs/attributes/edit-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/layers-dialogs/attributes/edit-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/layers-dialogs/attributes/edit-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/layers-dialogs/attributes/edit-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/layers-dialogs/tabs/identification-settings-test', ['exports', 'ember', 'ember-qunit', 'ember-i18n/services/i18n', 'ember-flexberry-gis/locales/ru/translations', 'ember-flexberry-gis/locales/en/translations'], function (exports, _ember, _emberQunit, _emberI18nServicesI18n, _emberFlexberryGisLocalesRuTranslations, _emberFlexberryGisLocalesEnTranslations) {

  (0, _emberQunit.moduleForComponent)('identification-settings', 'Integration | Component | identification settings', {
    beforeEach: function beforeEach(assert) {
      this.register('locale:ru/translations', _emberFlexberryGisLocalesRuTranslations['default']);
      this.register('locale:en/translations', _emberFlexberryGisLocalesEnTranslations['default']);
      this.register('service:i18n', _emberI18nServicesI18n['default']);

      this.inject.service('i18n', { as: 'i18n' });
      _ember['default'].Component.reopen({
        i18n: _ember['default'].inject.service('i18n')
      });

      this.set('i18n.locale', 'ru');

      var obj = {
        settings: {
          displaySettings: {
            canBeIdentified: true
          }
        }
      };

      this.set('_layer', obj);
    },
    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {

    this.render(_ember['default'].HTMLBars.template((function () {
      return {
        meta: {
          'fragmentReason': {
            'name': 'missing-wrapper',
            'problems': ['wrong-type']
          },
          'revision': 'Ember@2.4.6',
          'loc': {
            'source': null,
            'start': {
              'line': 1,
              'column': 0
            },
            'end': {
              'line': 1,
              'column': 85
            }
          }
        },
        isEmpty: false,
        arity: 0,
        cachedFragment: null,
        hasRendered: false,
        buildFragment: function buildFragment(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment('');
          dom.appendChild(el0, el1);
          return el0;
        },
        buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
          var morphs = new Array(1);
          morphs[0] = dom.createMorphAt(fragment, 0, 0, contextualElement);
          dom.insertBoundary(fragment, 0);
          dom.insertBoundary(fragment, null);
          return morphs;
        },
        statements: [['inline', 'layers-dialogs/tabs/identification-settings', [], ['value', ['subexpr', '@mut', [['get', '_layer.settings.displaySettings', ['loc', [null, [1, 52], [1, 83]]]]], [], []]], ['loc', [null, [1, 0], [1, 85]]]]],
        locals: [],
        templates: []
      };
    })()));

    assert.equal(this.$().text().trim(), 'Может быть идентифицирован');
  });
});
define('dummy/tests/integration/components/layers-dialogs/tabs/identification-settings-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components/layers-dialogs/tabs');
  test('integration/components/layers-dialogs/tabs/identification-settings-test.js should pass jscs', function () {
    ok(true, 'integration/components/layers-dialogs/tabs/identification-settings-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/layers-dialogs/tabs/identification-settings-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/layers-dialogs/tabs/identification-settings-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/layers-dialogs/tabs/identification-settings-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/layers-dialogs/tabs/legend-settings-test', ['exports', 'ember', 'ember-qunit', 'ember-i18n/services/i18n', 'ember-flexberry-gis/locales/ru/translations', 'ember-flexberry-gis/locales/en/translations'], function (exports, _ember, _emberQunit, _emberI18nServicesI18n, _emberFlexberryGisLocalesRuTranslations, _emberFlexberryGisLocalesEnTranslations) {

  (0, _emberQunit.moduleForComponent)('layers-dialogs/tabs/legend-settings', 'Integration | Component | layers dialogs/tabs/legend settings', {
    beforeEach: function beforeEach(assert) {
      this.register('locale:ru/translations', _emberFlexberryGisLocalesRuTranslations['default']);
      this.register('locale:en/translations', _emberFlexberryGisLocalesEnTranslations['default']);
      this.register('service:i18n', _emberI18nServicesI18n['default']);

      this.inject.service('i18n', { as: 'i18n' });
      _ember['default'].Component.reopen({
        i18n: _ember['default'].inject.service('i18n')
      });

      this.set('i18n.locale', 'ru');

      var obj = {
        settings: {
          legendSettings: {
            legendCanBeDisplayed: true
          }
        }
      };
      this.set('_layer', obj);
    },
    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {
    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.on('myAction', function(val) { ... });

    this.render(_ember['default'].HTMLBars.template((function () {
      return {
        meta: {
          'fragmentReason': {
            'name': 'missing-wrapper',
            'problems': ['wrong-type']
          },
          'revision': 'Ember@2.4.6',
          'loc': {
            'source': null,
            'start': {
              'line': 1,
              'column': 0
            },
            'end': {
              'line': 4,
              'column': 20
            }
          }
        },
        isEmpty: false,
        arity: 0,
        cachedFragment: null,
        hasRendered: false,
        buildFragment: function buildFragment(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment('');
          dom.appendChild(el0, el1);
          return el0;
        },
        buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
          var morphs = new Array(1);
          morphs[0] = dom.createMorphAt(fragment, 0, 0, contextualElement);
          dom.insertBoundary(fragment, 0);
          dom.insertBoundary(fragment, null);
          return morphs;
        },
        statements: [['inline', 'layers-dialogs/tabs/legend-settings', [], ['value', ['subexpr', '@mut', [['get', '_layer.settings.legendSettings', ['loc', [null, [2, 26], [2, 56]]]]], [], []], 'type', ['subexpr', '@mut', [['get', '_layer.type', ['loc', [null, [3, 25], [3, 36]]]]], [], []]], ['loc', [null, [1, 0], [4, 20]]]]],
        locals: [],
        templates: []
      };
    })()));

    assert.equal(this.$().text().trim(), 'Отображать легенду');
  });
});
define('dummy/tests/integration/components/layers-dialogs/tabs/legend-settings-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components/layers-dialogs/tabs');
  test('integration/components/layers-dialogs/tabs/legend-settings-test.js should pass jscs', function () {
    ok(true, 'integration/components/layers-dialogs/tabs/legend-settings-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/layers-dialogs/tabs/legend-settings-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/layers-dialogs/tabs/legend-settings-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/layers-dialogs/tabs/legend-settings-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/layers/group-layer-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForComponent)('layers/group-layer', 'Integration | Component | layers/group layer', {
    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {
    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.on('myAction', function(val) { ... });
    this.set('leafletContainer', L.layerGroup());

    this.render(Ember.HTMLBars.template((function () {
      return {
        meta: {
          'fragmentReason': {
            'name': 'missing-wrapper',
            'problems': ['wrong-type']
          },
          'revision': 'Ember@2.4.6',
          'loc': {
            'source': null,
            'start': {
              'line': 1,
              'column': 0
            },
            'end': {
              'line': 1,
              'column': 56
            }
          }
        },
        isEmpty: false,
        arity: 0,
        cachedFragment: null,
        hasRendered: false,
        buildFragment: function buildFragment(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment('');
          dom.appendChild(el0, el1);
          return el0;
        },
        buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
          var morphs = new Array(1);
          morphs[0] = dom.createMorphAt(fragment, 0, 0, contextualElement);
          dom.insertBoundary(fragment, 0);
          dom.insertBoundary(fragment, null);
          return morphs;
        },
        statements: [['inline', 'layers/group-layer', [], ['leafletContainer', ['subexpr', '@mut', [['get', 'leafletContainer', ['loc', [null, [1, 38], [1, 54]]]]], [], []]], ['loc', [null, [1, 0], [1, 56]]]]],
        locals: [],
        templates: []
      };
    })()));

    assert.equal(this.$().text().trim(), '');
  });
});
define('dummy/tests/integration/components/layers/group-layer-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components/layers');
  test('integration/components/layers/group-layer-test.js should pass jscs', function () {
    ok(true, 'integration/components/layers/group-layer-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/layers/group-layer-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/layers/group-layer-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/layers/group-layer-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/layers/osm-layer-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForComponent)('layers/osm-layer', 'Integration | Component | layers/osm layer', {
    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {
    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.on('myAction', function(val) { ... });

    this.render(Ember.HTMLBars.template((function () {
      return {
        meta: {
          'fragmentReason': {
            'name': 'missing-wrapper',
            'problems': ['wrong-type']
          },
          'revision': 'Ember@2.4.6',
          'loc': {
            'source': null,
            'start': {
              'line': 1,
              'column': 0
            },
            'end': {
              'line': 1,
              'column': 20
            }
          }
        },
        isEmpty: false,
        arity: 0,
        cachedFragment: null,
        hasRendered: false,
        buildFragment: function buildFragment(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment('');
          dom.appendChild(el0, el1);
          return el0;
        },
        buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
          var morphs = new Array(1);
          morphs[0] = dom.createMorphAt(fragment, 0, 0, contextualElement);
          dom.insertBoundary(fragment, 0);
          dom.insertBoundary(fragment, null);
          return morphs;
        },
        statements: [['content', 'layers/osm-layer', ['loc', [null, [1, 0], [1, 20]]]]],
        locals: [],
        templates: []
      };
    })()));

    assert.equal(this.$().text().trim(), '');

    // Template block usage:
    this.render(Ember.HTMLBars.template((function () {
      var child0 = (function () {
        return {
          meta: {
            'fragmentReason': false,
            'revision': 'Ember@2.4.6',
            'loc': {
              'source': null,
              'start': {
                'line': 2,
                'column': 4
              },
              'end': {
                'line': 4,
                'column': 4
              }
            }
          },
          isEmpty: false,
          arity: 0,
          cachedFragment: null,
          hasRendered: false,
          buildFragment: function buildFragment(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode('      template block text\n');
            dom.appendChild(el0, el1);
            return el0;
          },
          buildRenderNodes: function buildRenderNodes() {
            return [];
          },
          statements: [],
          locals: [],
          templates: []
        };
      })();

      return {
        meta: {
          'fragmentReason': {
            'name': 'missing-wrapper',
            'problems': ['wrong-type']
          },
          'revision': 'Ember@2.4.6',
          'loc': {
            'source': null,
            'start': {
              'line': 1,
              'column': 0
            },
            'end': {
              'line': 5,
              'column': 2
            }
          }
        },
        isEmpty: false,
        arity: 0,
        cachedFragment: null,
        hasRendered: false,
        buildFragment: function buildFragment(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode('\n');
          dom.appendChild(el0, el1);
          var el1 = dom.createComment('');
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode('  ');
          dom.appendChild(el0, el1);
          return el0;
        },
        buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
          var morphs = new Array(1);
          morphs[0] = dom.createMorphAt(fragment, 1, 1, contextualElement);
          return morphs;
        },
        statements: [['block', 'layers/osm-layer', [], [], 0, null, ['loc', [null, [2, 4], [4, 25]]]]],
        locals: [],
        templates: [child0]
      };
    })()));

    assert.equal(this.$().text().trim(), 'template block text');
  });
});
define('dummy/tests/integration/components/layers/osm-layer-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components/layers');
  test('integration/components/layers/osm-layer-test.js should pass jscs', function () {
    ok(true, 'integration/components/layers/osm-layer-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/layers/osm-layer-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/layers/osm-layer-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/layers/osm-layer-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/legends/wms-legend-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForComponent)('legends/wms-legend', 'Integration | Component | legends/wms legend', {
    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {
    assert.expect(2);

    this.set('testLayer', {
      settingsAsObject: {
        url: 'http://212.192.76.235:8080/geoserver/wms',
        layers: 'lesonas1969:goszem,lesonas1969:river,lesonas1969:kvartal'
      }
    });

    this.render(Ember.HTMLBars.template((function () {
      return {
        meta: {
          'fragmentReason': {
            'name': 'missing-wrapper',
            'problems': ['wrong-type']
          },
          'revision': 'Ember@2.4.6',
          'loc': {
            'source': null,
            'start': {
              'line': 1,
              'column': 0
            },
            'end': {
              'line': 1,
              'column': 38
            }
          }
        },
        isEmpty: false,
        arity: 0,
        cachedFragment: null,
        hasRendered: false,
        buildFragment: function buildFragment(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment('');
          dom.appendChild(el0, el1);
          return el0;
        },
        buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
          var morphs = new Array(1);
          morphs[0] = dom.createMorphAt(fragment, 0, 0, contextualElement);
          dom.insertBoundary(fragment, 0);
          dom.insertBoundary(fragment, null);
          return morphs;
        },
        statements: [['inline', 'legends/wms-legend', [], ['layer', ['subexpr', '@mut', [['get', 'testLayer', ['loc', [null, [1, 27], [1, 36]]]]], [], []]], ['loc', [null, [1, 0], [1, 38]]]]],
        locals: [],
        templates: []
      };
    })()));

    var $images = this.$('img');
    var expectedSrc = 'http://212.192.76.235:8080/geoserver/wms?service=WMS&request=GetLegendGraphic&version=1.1.0&format=image%2Fpng&layer=lesonas1969%3Agoszem';

    assert.equal($images.size(), 3, 'Images for all defined layers are rendered');
    assert.equal($images.first().attr('src'), expectedSrc, 'Image\'s \'src\' attribute computed as expected');
  });
});
define('dummy/tests/integration/components/legends/wms-legend-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components/legends');
  test('integration/components/legends/wms-legend-test.js should pass jscs', function () {
    ok(true, 'integration/components/legends/wms-legend-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/legends/wms-legend-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/legends/wms-legend-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/legends/wms-legend-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/minimap-control-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForComponent)('minimap-control', 'Integration | Component | minimap control', {
    integration: true
  });

  (0, _emberQunit.test)('template return L.layerGroup', function (assert) {

    assert.expect(1);

    this.set('layerGroupClass', L.LayerGroup);

    this.render(Ember.HTMLBars.template((function () {
      var child0 = (function () {
        return {
          meta: {
            'fragmentReason': false,
            'revision': 'Ember@2.4.6',
            'loc': {
              'source': null,
              'start': {
                'line': 2,
                'column': 4
              },
              'end': {
                'line': 4,
                'column': 4
              }
            }
          },
          isEmpty: false,
          arity: 1,
          cachedFragment: null,
          hasRendered: false,
          buildFragment: function buildFragment(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode('       ');
            dom.appendChild(el0, el1);
            var el1 = dom.createElement('div');
            dom.setAttribute(el1, 'class', 'layerG-body');
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode('\n');
            dom.appendChild(el0, el1);
            return el0;
          },
          buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
            var element0 = dom.childAt(fragment, [1]);
            var morphs = new Array(1);
            morphs[0] = dom.createAttrMorph(element0, 'is-layergroup');
            return morphs;
          },
          statements: [['attribute', 'is-layergroup', ['concat', [['subexpr', 'instance-of', [['get', 'layerG', ['loc', [null, [3, 61], [3, 67]]]], ['get', 'layerGroupClass', ['loc', [null, [3, 68], [3, 83]]]]], [], ['loc', [null, [3, 47], [3, 85]]]]]]]],
          locals: ['layerG'],
          templates: []
        };
      })();

      return {
        meta: {
          'fragmentReason': {
            'name': 'missing-wrapper',
            'problems': ['wrong-type']
          },
          'revision': 'Ember@2.4.6',
          'loc': {
            'source': null,
            'start': {
              'line': 1,
              'column': 0
            },
            'end': {
              'line': 5,
              'column': 2
            }
          }
        },
        isEmpty: false,
        arity: 0,
        cachedFragment: null,
        hasRendered: false,
        buildFragment: function buildFragment(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode('\n');
          dom.appendChild(el0, el1);
          var el1 = dom.createComment('');
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode('  ');
          dom.appendChild(el0, el1);
          return el0;
        },
        buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
          var morphs = new Array(1);
          morphs[0] = dom.createMorphAt(fragment, 1, 1, contextualElement);
          return morphs;
        },
        statements: [['block', 'minimap-control', [], [], 0, null, ['loc', [null, [2, 4], [4, 24]]]]],
        locals: [],
        templates: [child0]
      };
    })()));

    assert.ok(this.$('div.layerG-body').attr('is-layergroup'));
  });
});
define('dummy/tests/integration/components/minimap-control-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components');
  test('integration/components/minimap-control-test.js should pass jscs', function () {
    ok(true, 'integration/components/minimap-control-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/minimap-control-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/minimap-control-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/minimap-control-test.js should pass jshint.');
  });
});
define('dummy/tests/integration/components/spatial-bookmark-test', ['exports', 'ember', 'ember-qunit', 'ember-flexberry-gis/services/local-storage', 'ember-i18n/services/i18n', 'ember-flexberry-gis/locales/ru/translations', 'ember-flexberry-gis/locales/en/translations'], function (exports, _ember, _emberQunit, _emberFlexberryGisServicesLocalStorage, _emberI18nServicesI18n, _emberFlexberryGisLocalesRuTranslations, _emberFlexberryGisLocalesEnTranslations) {

  (0, _emberQunit.moduleForComponent)('spatial-bookmark', 'Integration | Component | spatial bookmark', {
    beforeEach: function beforeEach(assert) {
      this.register('locale:ru/translations', _emberFlexberryGisLocalesRuTranslations['default']);
      this.register('locale:en/translations', _emberFlexberryGisLocalesEnTranslations['default']);
      this.register('service:i18n', _emberI18nServicesI18n['default']);

      this.inject.service('i18n', { as: 'i18n' });
      _ember['default'].Component.reopen({
        i18n: _ember['default'].inject.service('i18n')
      });

      this.set('i18n.locale', 'ru');

      this.register('service:local-storage', _emberFlexberryGisServicesLocalStorage['default']);

      this.inject.service('local-storage', { as: 'local-storage-service' });
      _ember['default'].Component.reopen({
        'local-storage-service': _ember['default'].inject.service('local-storage')
      });
    },

    afterEach: function afterEach() {
      _ember['default'].Component.reopen({
        'local-storage-service': undefined
      });
    },

    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {
    this.render(_ember['default'].HTMLBars.template((function () {
      return {
        meta: {
          'fragmentReason': {
            'name': 'missing-wrapper',
            'problems': ['wrong-type']
          },
          'revision': 'Ember@2.4.6',
          'loc': {
            'source': null,
            'start': {
              'line': 1,
              'column': 0
            },
            'end': {
              'line': 1,
              'column': 20
            }
          }
        },
        isEmpty: false,
        arity: 0,
        cachedFragment: null,
        hasRendered: false,
        buildFragment: function buildFragment(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment('');
          dom.appendChild(el0, el1);
          return el0;
        },
        buildRenderNodes: function buildRenderNodes(dom, fragment, contextualElement) {
          var morphs = new Array(1);
          morphs[0] = dom.createMorphAt(fragment, 0, 0, contextualElement);
          dom.insertBoundary(fragment, 0);
          dom.insertBoundary(fragment, null);
          return morphs;
        },
        statements: [['content', 'spatial-bookmark', ['loc', [null, [1, 0], [1, 20]]]]],
        locals: [],
        templates: []
      };
    })()));
    assert.equal(this.$().text().trim(), 'Добавить в закладки');
  });
});
define('dummy/tests/integration/components/spatial-bookmark-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - integration/components');
  test('integration/components/spatial-bookmark-test.js should pass jscs', function () {
    ok(true, 'integration/components/spatial-bookmark-test.js should pass jscs.');
  });
});
define('dummy/tests/integration/components/spatial-bookmark-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - integration/components/spatial-bookmark-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/components/spatial-bookmark-test.js should pass jshint.');
  });
});
define('dummy/tests/locales/en/forms.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/en');
  test('locales/en/forms.js should pass jscs', function () {
    ok(true, 'locales/en/forms.js should pass jscs.');
  });
});
define('dummy/tests/locales/en/forms.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/en/forms.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/en/forms.js should pass jshint.');
  });
});
define('dummy/tests/locales/en/forms/application.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/en/forms');
  test('locales/en/forms/application.js should pass jscs', function () {
    ok(true, 'locales/en/forms/application.js should pass jscs.');
  });
});
define('dummy/tests/locales/en/forms/application.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/en/forms/application.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/en/forms/application.js should pass jshint.');
  });
});
define('dummy/tests/locales/en/forms/application/footer.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/en/forms/application');
  test('locales/en/forms/application/footer.js should pass jscs', function () {
    ok(true, 'locales/en/forms/application/footer.js should pass jscs.');
  });
});
define('dummy/tests/locales/en/forms/application/footer.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/en/forms/application/footer.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/en/forms/application/footer.js should pass jshint.');
  });
});
define('dummy/tests/locales/en/forms/application/header.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/en/forms/application');
  test('locales/en/forms/application/header.js should pass jscs', function () {
    ok(true, 'locales/en/forms/application/header.js should pass jscs.');
  });
});
define('dummy/tests/locales/en/forms/application/header.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/en/forms/application/header.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/en/forms/application/header.js should pass jshint.');
  });
});
define('dummy/tests/locales/en/forms/application/sitemap.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/en/forms/application');
  test('locales/en/forms/application/sitemap.js should pass jscs', function () {
    ok(true, 'locales/en/forms/application/sitemap.js should pass jscs.');
  });
});
define('dummy/tests/locales/en/forms/application/sitemap.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/en/forms/application/sitemap.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/en/forms/application/sitemap.js should pass jshint.');
  });
});
define('dummy/tests/locales/en/forms/components-examples.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/en/forms');
  test('locales/en/forms/components-examples.js should pass jscs', function () {
    ok(true, 'locales/en/forms/components-examples.js should pass jscs.');
  });
});
define('dummy/tests/locales/en/forms/components-examples.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/en/forms/components-examples.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/en/forms/components-examples.js should pass jshint.');
  });
});
define('dummy/tests/locales/en/forms/edit-form.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/en/forms');
  test('locales/en/forms/edit-form.js should pass jscs', function () {
    ok(true, 'locales/en/forms/edit-form.js should pass jscs.');
  });
});
define('dummy/tests/locales/en/forms/edit-form.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/en/forms/edit-form.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/en/forms/edit-form.js should pass jshint.');
  });
});
define('dummy/tests/locales/en/forms/index.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/en/forms');
  test('locales/en/forms/index.js should pass jscs', function () {
    ok(true, 'locales/en/forms/index.js should pass jscs.');
  });
});
define('dummy/tests/locales/en/forms/index.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/en/forms/index.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/en/forms/index.js should pass jshint.');
  });
});
define('dummy/tests/locales/en/forms/loading.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/en/forms');
  test('locales/en/forms/loading.js should pass jscs', function () {
    ok(true, 'locales/en/forms/loading.js should pass jscs.');
  });
});
define('dummy/tests/locales/en/forms/loading.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/en/forms/loading.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/en/forms/loading.js should pass jshint.');
  });
});
define('dummy/tests/locales/en/forms/map.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/en/forms');
  test('locales/en/forms/map.js should pass jscs', function () {
    ok(true, 'locales/en/forms/map.js should pass jscs.');
  });
});
define('dummy/tests/locales/en/forms/map.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/en/forms/map.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/en/forms/map.js should pass jshint.');
  });
});
define('dummy/tests/locales/en/forms/maps.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/en/forms');
  test('locales/en/forms/maps.js should pass jscs', function () {
    ok(true, 'locales/en/forms/maps.js should pass jscs.');
  });
});
define('dummy/tests/locales/en/forms/maps.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/en/forms/maps.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/en/forms/maps.js should pass jshint.');
  });
});
define('dummy/tests/locales/en/forms/new-platform-flexberry-g-i-s-map-object-setting-e.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/en/forms');
  test('locales/en/forms/new-platform-flexberry-g-i-s-map-object-setting-e.js should pass jscs', function () {
    ok(true, 'locales/en/forms/new-platform-flexberry-g-i-s-map-object-setting-e.js should pass jscs.');
  });
});
define('dummy/tests/locales/en/forms/new-platform-flexberry-g-i-s-map-object-setting-e.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/en/forms/new-platform-flexberry-g-i-s-map-object-setting-e.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/en/forms/new-platform-flexberry-g-i-s-map-object-setting-e.js should pass jshint.');
  });
});
define('dummy/tests/locales/en/forms/new-platform-flexberry-g-i-s-map-object-setting-l.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/en/forms');
  test('locales/en/forms/new-platform-flexberry-g-i-s-map-object-setting-l.js should pass jscs', function () {
    ok(true, 'locales/en/forms/new-platform-flexberry-g-i-s-map-object-setting-l.js should pass jscs.');
  });
});
define('dummy/tests/locales/en/forms/new-platform-flexberry-g-i-s-map-object-setting-l.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/en/forms/new-platform-flexberry-g-i-s-map-object-setting-l.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/en/forms/new-platform-flexberry-g-i-s-map-object-setting-l.js should pass jshint.');
  });
});
define('dummy/tests/locales/en/translations.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/en');
  test('locales/en/translations.js should pass jscs', function () {
    ok(true, 'locales/en/translations.js should pass jscs.');
  });
});
define('dummy/tests/locales/en/translations.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/en/translations.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/en/translations.js should pass jshint.');
  });
});
define('dummy/tests/locales/ru/forms.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/ru');
  test('locales/ru/forms.js should pass jscs', function () {
    ok(true, 'locales/ru/forms.js should pass jscs.');
  });
});
define('dummy/tests/locales/ru/forms.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/ru/forms.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/ru/forms.js should pass jshint.');
  });
});
define('dummy/tests/locales/ru/forms/application.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/ru/forms');
  test('locales/ru/forms/application.js should pass jscs', function () {
    ok(true, 'locales/ru/forms/application.js should pass jscs.');
  });
});
define('dummy/tests/locales/ru/forms/application.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/ru/forms/application.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/ru/forms/application.js should pass jshint.');
  });
});
define('dummy/tests/locales/ru/forms/application/footer.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/ru/forms/application');
  test('locales/ru/forms/application/footer.js should pass jscs', function () {
    ok(true, 'locales/ru/forms/application/footer.js should pass jscs.');
  });
});
define('dummy/tests/locales/ru/forms/application/footer.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/ru/forms/application/footer.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/ru/forms/application/footer.js should pass jshint.');
  });
});
define('dummy/tests/locales/ru/forms/application/header.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/ru/forms/application');
  test('locales/ru/forms/application/header.js should pass jscs', function () {
    ok(true, 'locales/ru/forms/application/header.js should pass jscs.');
  });
});
define('dummy/tests/locales/ru/forms/application/header.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/ru/forms/application/header.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/ru/forms/application/header.js should pass jshint.');
  });
});
define('dummy/tests/locales/ru/forms/application/sitemap.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/ru/forms/application');
  test('locales/ru/forms/application/sitemap.js should pass jscs', function () {
    ok(true, 'locales/ru/forms/application/sitemap.js should pass jscs.');
  });
});
define('dummy/tests/locales/ru/forms/application/sitemap.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/ru/forms/application/sitemap.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/ru/forms/application/sitemap.js should pass jshint.');
  });
});
define('dummy/tests/locales/ru/forms/components-examples.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/ru/forms');
  test('locales/ru/forms/components-examples.js should pass jscs', function () {
    ok(true, 'locales/ru/forms/components-examples.js should pass jscs.');
  });
});
define('dummy/tests/locales/ru/forms/components-examples.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/ru/forms/components-examples.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/ru/forms/components-examples.js should pass jshint.');
  });
});
define('dummy/tests/locales/ru/forms/edit-form.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/ru/forms');
  test('locales/ru/forms/edit-form.js should pass jscs', function () {
    ok(true, 'locales/ru/forms/edit-form.js should pass jscs.');
  });
});
define('dummy/tests/locales/ru/forms/edit-form.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/ru/forms/edit-form.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/ru/forms/edit-form.js should pass jshint.');
  });
});
define('dummy/tests/locales/ru/forms/index.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/ru/forms');
  test('locales/ru/forms/index.js should pass jscs', function () {
    ok(true, 'locales/ru/forms/index.js should pass jscs.');
  });
});
define('dummy/tests/locales/ru/forms/index.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/ru/forms/index.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/ru/forms/index.js should pass jshint.');
  });
});
define('dummy/tests/locales/ru/forms/loading.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/ru/forms');
  test('locales/ru/forms/loading.js should pass jscs', function () {
    ok(true, 'locales/ru/forms/loading.js should pass jscs.');
  });
});
define('dummy/tests/locales/ru/forms/loading.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/ru/forms/loading.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/ru/forms/loading.js should pass jshint.');
  });
});
define('dummy/tests/locales/ru/forms/map.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/ru/forms');
  test('locales/ru/forms/map.js should pass jscs', function () {
    ok(true, 'locales/ru/forms/map.js should pass jscs.');
  });
});
define('dummy/tests/locales/ru/forms/map.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/ru/forms/map.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/ru/forms/map.js should pass jshint.');
  });
});
define('dummy/tests/locales/ru/forms/maps.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/ru/forms');
  test('locales/ru/forms/maps.js should pass jscs', function () {
    ok(true, 'locales/ru/forms/maps.js should pass jscs.');
  });
});
define('dummy/tests/locales/ru/forms/maps.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/ru/forms/maps.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/ru/forms/maps.js should pass jshint.');
  });
});
define('dummy/tests/locales/ru/forms/new-platform-flexberry-g-i-s-map-object-setting-e.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/ru/forms');
  test('locales/ru/forms/new-platform-flexberry-g-i-s-map-object-setting-e.js should pass jscs', function () {
    ok(true, 'locales/ru/forms/new-platform-flexberry-g-i-s-map-object-setting-e.js should pass jscs.');
  });
});
define('dummy/tests/locales/ru/forms/new-platform-flexberry-g-i-s-map-object-setting-e.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/ru/forms/new-platform-flexberry-g-i-s-map-object-setting-e.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/ru/forms/new-platform-flexberry-g-i-s-map-object-setting-e.js should pass jshint.');
  });
});
define('dummy/tests/locales/ru/forms/new-platform-flexberry-g-i-s-map-object-setting-l.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/ru/forms');
  test('locales/ru/forms/new-platform-flexberry-g-i-s-map-object-setting-l.js should pass jscs', function () {
    ok(true, 'locales/ru/forms/new-platform-flexberry-g-i-s-map-object-setting-l.js should pass jscs.');
  });
});
define('dummy/tests/locales/ru/forms/new-platform-flexberry-g-i-s-map-object-setting-l.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/ru/forms/new-platform-flexberry-g-i-s-map-object-setting-l.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/ru/forms/new-platform-flexberry-g-i-s-map-object-setting-l.js should pass jshint.');
  });
});
define('dummy/tests/locales/ru/translations.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - locales/ru');
  test('locales/ru/translations.js should pass jscs', function () {
    ok(true, 'locales/ru/translations.js should pass jscs.');
  });
});
define('dummy/tests/locales/ru/translations.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - locales/ru/translations.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'locales/ru/translations.js should pass jshint.');
  });
});
define('dummy/tests/models/components-examples/flexberry-ddau-checkbox/settings-example/base.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - models/components-examples/flexberry-ddau-checkbox/settings-example');
  test('models/components-examples/flexberry-ddau-checkbox/settings-example/base.js should pass jscs', function () {
    ok(true, 'models/components-examples/flexberry-ddau-checkbox/settings-example/base.js should pass jscs.');
  });
});
define('dummy/tests/models/components-examples/flexberry-ddau-checkbox/settings-example/base.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - models/components-examples/flexberry-ddau-checkbox/settings-example/base.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'models/components-examples/flexberry-ddau-checkbox/settings-example/base.js should pass jshint.');
  });
});
define('dummy/tests/models/custom-inflector-rules.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - models');
  test('models/custom-inflector-rules.js should pass jscs', function () {
    ok(true, 'models/custom-inflector-rules.js should pass jscs.');
  });
});
define('dummy/tests/models/custom-inflector-rules.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - models/custom-inflector-rules.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'models/custom-inflector-rules.js should pass jshint.');
  });
});
define('dummy/tests/resolver.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - .');
  test('resolver.js should pass jscs', function () {
    ok(true, 'resolver.js should pass jscs.');
  });
});
define('dummy/tests/resolver.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - resolver.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'resolver.js should pass jshint.');
  });
});
define('dummy/tests/router.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - .');
  test('router.js should pass jscs', function () {
    ok(true, 'router.js should pass jscs.');
  });
});
define('dummy/tests/router.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - router.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'router.js should pass jshint.');
  });
});
define('dummy/tests/routes/api-test-map.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - routes');
  test('routes/api-test-map.js should pass jscs', function () {
    ok(true, 'routes/api-test-map.js should pass jscs.');
  });
});
define('dummy/tests/routes/api-test-map.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - routes/api-test-map.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'routes/api-test-map.js should pass jshint.');
  });
});
define('dummy/tests/routes/application.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - routes');
  test('routes/application.js should pass jscs', function () {
    ok(true, 'routes/application.js should pass jscs.');
  });
});
define('dummy/tests/routes/application.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - routes/application.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'routes/application.js should pass jshint.');
  });
});
define('dummy/tests/routes/components-examples/flexberry-boundingbox/settings-example.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - routes/components-examples/flexberry-boundingbox');
  test('routes/components-examples/flexberry-boundingbox/settings-example.js should pass jscs', function () {
    ok(true, 'routes/components-examples/flexberry-boundingbox/settings-example.js should pass jscs.');
  });
});
define('dummy/tests/routes/components-examples/flexberry-boundingbox/settings-example.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - routes/components-examples/flexberry-boundingbox/settings-example.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'routes/components-examples/flexberry-boundingbox/settings-example.js should pass jshint.');
  });
});
define('dummy/tests/routes/index.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - routes');
  test('routes/index.js should pass jscs', function () {
    ok(true, 'routes/index.js should pass jscs.');
  });
});
define('dummy/tests/routes/index.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - routes/index.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'routes/index.js should pass jshint.');
  });
});
define('dummy/tests/routes/map.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - routes');
  test('routes/map.js should pass jscs', function () {
    ok(true, 'routes/map.js should pass jscs.');
  });
});
define('dummy/tests/routes/map.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - routes/map.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'routes/map.js should pass jshint.');
  });
});
define('dummy/tests/routes/map/new.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - routes/map');
  test('routes/map/new.js should pass jscs', function () {
    ok(true, 'routes/map/new.js should pass jscs.');
  });
});
define('dummy/tests/routes/map/new.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - routes/map/new.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'routes/map/new.js should pass jshint.');
  });
});
define('dummy/tests/routes/maps.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - routes');
  test('routes/maps.js should pass jscs', function () {
    ok(true, 'routes/maps.js should pass jscs.');
  });
});
define('dummy/tests/routes/maps.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - routes/maps.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'routes/maps.js should pass jshint.');
  });
});
define('dummy/tests/routes/new-platform-flexberry-g-i-s-map-object-setting-e.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - routes');
  test('routes/new-platform-flexberry-g-i-s-map-object-setting-e.js should pass jscs', function () {
    ok(true, 'routes/new-platform-flexberry-g-i-s-map-object-setting-e.js should pass jscs.');
  });
});
define('dummy/tests/routes/new-platform-flexberry-g-i-s-map-object-setting-e.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - routes/new-platform-flexberry-g-i-s-map-object-setting-e.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'routes/new-platform-flexberry-g-i-s-map-object-setting-e.js should pass jshint.');
  });
});
define('dummy/tests/routes/new-platform-flexberry-g-i-s-map-object-setting-e/new.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - routes/new-platform-flexberry-g-i-s-map-object-setting-e');
  test('routes/new-platform-flexberry-g-i-s-map-object-setting-e/new.js should pass jscs', function () {
    ok(true, 'routes/new-platform-flexberry-g-i-s-map-object-setting-e/new.js should pass jscs.');
  });
});
define('dummy/tests/routes/new-platform-flexberry-g-i-s-map-object-setting-e/new.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - routes/new-platform-flexberry-g-i-s-map-object-setting-e/new.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'routes/new-platform-flexberry-g-i-s-map-object-setting-e/new.js should pass jshint.');
  });
});
define('dummy/tests/routes/new-platform-flexberry-g-i-s-map-object-setting-l.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - routes');
  test('routes/new-platform-flexberry-g-i-s-map-object-setting-l.js should pass jscs', function () {
    ok(true, 'routes/new-platform-flexberry-g-i-s-map-object-setting-l.js should pass jscs.');
  });
});
define('dummy/tests/routes/new-platform-flexberry-g-i-s-map-object-setting-l.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - routes/new-platform-flexberry-g-i-s-map-object-setting-l.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'routes/new-platform-flexberry-g-i-s-map-object-setting-l.js should pass jshint.');
  });
});
define('dummy/tests/serializers/application-offline.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - serializers');
  test('serializers/application-offline.js should pass jscs', function () {
    ok(true, 'serializers/application-offline.js should pass jscs.');
  });
});
define('dummy/tests/serializers/application-offline.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - serializers/application-offline.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'serializers/application-offline.js should pass jshint.');
  });
});
define('dummy/tests/serializers/application.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - serializers');
  test('serializers/application.js should pass jscs', function () {
    ok(true, 'serializers/application.js should pass jscs.');
  });
});
define('dummy/tests/serializers/application.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - serializers/application.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'serializers/application.js should pass jshint.');
  });
});
define('dummy/tests/services/store.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - services');
  test('services/store.js should pass jscs', function () {
    ok(true, 'services/store.js should pass jscs.');
  });
});
define('dummy/tests/services/store.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - services/store.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'services/store.js should pass jshint.');
  });
});
define('dummy/tests/services/user-settings.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - services');
  test('services/user-settings.js should pass jscs', function () {
    ok(true, 'services/user-settings.js should pass jscs.');
  });
});
define('dummy/tests/services/user-settings.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - services/user-settings.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'services/user-settings.js should pass jshint.');
  });
});
define('dummy/tests/test-helper', ['exports', 'dummy/tests/helpers/resolver', 'ember-qunit'], function (exports, _dummyTestsHelpersResolver, _emberQunit) {

  (0, _emberQunit.setResolver)(_dummyTestsHelpersResolver['default']);
});
define('dummy/tests/test-helper.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - .');
  test('test-helper.js should pass jscs', function () {
    ok(true, 'test-helper.js should pass jscs.');
  });
});
define('dummy/tests/test-helper.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - test-helper.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'test-helper.js should pass jshint.');
  });
});
define('dummy/tests/unit/components/base-control-test', ['exports', 'ember-qunit', 'sinon'], function (exports, _emberQunit, _sinon) {

  (0, _emberQunit.moduleForComponent)('base-control', 'Unit | Component | base control', {
    unit: true
  });

  (0, _emberQunit.test)('it should call leafletMap.addControl method on initControl', function (assert) {
    var addControl = _sinon['default'].spy();
    var component = this.subject({ leafletMap: { addControl: addControl } });

    component.initControl();

    assert.ok(addControl.calledOnce);
  });
});
define('dummy/tests/unit/components/base-control-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/components');
  test('unit/components/base-control-test.js should pass jscs', function () {
    ok(true, 'unit/components/base-control-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/components/base-control-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/components/base-control-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/components/base-control-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/components/base-layer-test', ['exports', 'ember-qunit', 'sinon'], function (exports, _emberQunit, _sinon) {

  (0, _emberQunit.moduleForComponent)('base-layer', 'Unit | Component | base layer', {
    unit: true,
    needs: ['service:map-api', 'config:environment']
  });

  // stubs for createLayer method
  var layer = {};
  var createLayer = function createLayer() {
    return layer;
  };

  (0, _emberQunit.test)('it should throw at init', function (assert) {
    var _this = this;

    assert.throws(function () {
      _this.subject();
    });
  });

  (0, _emberQunit.test)('it should call layer.setZIndex on _setLayerZIndex', function (assert) {
    assert.expect(1);

    var setZIndex = _sinon['default'].spy();
    var component = this.subject({
      createLayer: function createLayer() {
        return {
          setZIndex: setZIndex
        };
      }
    });

    var leafletLayerPromiseResolved = assert.async();
    component.get('_leafletLayerPromise').then(function (leafletLayer) {
      component._setLayerZIndex();
      assert.ok(setZIndex.called);
    })['finally'](function () {
      leafletLayerPromiseResolved();
    });
  });

  (0, _emberQunit.test)('should call _setLayerVisibility and _setLayerZIndex on render', function (assert) {
    assert.expect(1);

    var setLayerVisibility = _sinon['default'].spy();

    var component = this.subject({
      createLayer: createLayer,
      _setLayerVisibility: setLayerVisibility
    });

    this.render();

    var leafletLayerPromiseResolved = assert.async();
    component.get('_leafletLayerPromise').then(function (leafletLayer) {
      assert.ok(setLayerVisibility.called, 'should call visibilityDidChange');
    })['finally'](function () {
      leafletLayerPromiseResolved();
    });
  });

  (0, _emberQunit.test)('should call container addLayer/removeLayer based on visibility property', function (assert) {
    assert.expect(4);

    var addLayer = _sinon['default'].spy();
    var removeLayer = _sinon['default'].spy();

    var leafletContainerHasLayer = false;
    var hasLayer = function hasLayer() {
      return leafletContainerHasLayer;
    };

    var component = this.subject({
      createLayer: createLayer,

      leafletContainer: {
        addLayer: addLayer,
        removeLayer: removeLayer,
        hasLayer: hasLayer
      }
    });

    var leafletLayerPromiseResolved = assert.async();
    component.get('_leafletLayerPromise').then(function (leafletLayer) {
      component.set('visibility', true);

      assert.ok(addLayer.calledOnce, 'addLayer should be called once');
      assert.ok(addLayer.calledWith(layer), 'addLayer should be called with layer instance');

      leafletContainerHasLayer = true;
      component.set('visibility', false);

      assert.ok(removeLayer.calledOnce, 'removeLayer should be called once');
      assert.ok(removeLayer.calledWith(layer), 'removeLayer should be called with layer instance');
    })['finally'](function () {
      leafletLayerPromiseResolved();
    });
  });
});
define('dummy/tests/unit/components/base-layer-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/components');
  test('unit/components/base-layer-test.js should pass jscs', function () {
    ok(true, 'unit/components/base-layer-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/components/base-layer-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/components/base-layer-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/components/base-layer-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/components/base-vector-layer-test', ['exports', 'ember', 'ember-qunit', 'sinon', 'dummy/tests/helpers/start-app'], function (exports, _ember, _emberQunit, _sinon, _dummyTestsHelpersStartApp) {

  var app = undefined;

  (0, _emberQunit.moduleForComponent)('base-vector-layer', 'Unit | Component | base-vector-layer', {
    unit: true,
    needs: ['service:map-api', 'config:environment', 'component:base-vector-layer', 'model:new-platform-flexberry-g-i-s-map'],
    beforeEach: function beforeEach() {
      app = (0, _dummyTestsHelpersStartApp['default'])();
    },
    afterEach: function afterEach() {
      _ember['default'].run(app, 'destroy');
    }
  });

  (0, _emberQunit.test)('it identify on \'geojson\' layer', function (assert) {
    var _this = this;

    assert.expect(3);
    var done = assert.async(3);
    _ember['default'].run(function () {
      /*
        9  . . . . . . . . .
        8 MPMP . .CpCp .MLML
        7 MP .MP . . . . . .
        6  .MPMP . P P .MLML
        5  . . . . P P . . .
        4  .CPCP . . . . L .
        3  . .CP . . . p . L
        2 CLCL . . . . . L .
        1 CL . .MpMp . . . .
        0  1 2 3 4 5 6 7 8 9
      */
      var component = _this.subject({
        _createLayer: function _createLayer() {
          this.set('_leafletObject', L.geoJson([{
            type: 'Feature',
            geometry: { type: 'Point', coordinates: [3, 7] }
          }, {
            type: 'Feature',
            geometry: { type: 'MultiPoint', coordinates: [[1, 4], [1, 5]] }
          }, {
            type: 'Feature',
            geometry: { type: 'LineString', coordinates: [[2, 8], [3, 9], [4, 8]] }
          }, {
            type: 'Feature',
            geometry: { type: 'MultiLineString', coordinates: [[[6, 8], [6, 9]], [[8, 8], [8, 9]]] }
          }, {
            type: 'Feature',
            geometry: { type: 'Polygon', coordinates: [[[5, 5], [5, 6], [6, 6], [6, 5]]] }
          }, {
            type: 'Feature',
            geometry: { type: 'MultiPolygon', coordinates: [[[[7, 1], [8, 1], [8, 2]]], [[[6, 2], [6, 3], [7, 3]]]] }
          }, {
            type: 'GeometryCollection',
            geometries: [{ type: 'Polygon', coordinates: [[[3, 3], [4, 3], [4, 2]]] }, { type: 'LineString', coordinates: [[1, 1], [2, 1], [2, 2]] }]
          }, {
            type: 'FeatureCollection',
            features: [{ type: 'Feature', geometry: { type: 'Point', coordinates: [8, 5] } }, { type: 'Feature', geometry: { type: 'Point', coordinates: [8, 6] } }]
          }]));
          this.set('_leafletObject.options', { crs: L.CRS.EPSG4326 });
        }
      });

      var select = function select(ar) {
        return {
          polygonLayer: {
            toGeoJSON: function toGeoJSON() {
              return {
                type: 'Feature',
                geometry: { type: 'Polygon', coordinates: ar }
              };
            }
          }
        };
      };

      var store = app.__container__.lookup('service:store');
      var mapModel = store.createRecord('new-platform-flexberry-g-i-s-map');
      var getmapApiStub = _sinon['default'].stub(component.get('mapApi'), 'getFromApi');
      getmapApiStub.returns(mapModel);

      component.identify(select([[[4, 4], [2, 4], [2, 6], [4, 6], [4, 4]]])).then(function (results) {
        assert.equal(results.length, 0, 'Empty area is selected.');
      })['finally'](done);

      component.identify(select([[[9, 5], [8, 8], [6, 6], [9, 5]]])).then(function (results) {
        assert.equal(results.length, 3, 'Point (from FeatureCollection), MultiLineString and Polygon.');
      })['finally'](done);

      component.identify(select([[[9, 1], [1, 1], [1, 9], [9, 9], [9, 1]]])).then(function (results) {
        assert.equal(results.length, 10, 'All geometries is selected.');
      })['finally'](done);
    });
  });
});
define('dummy/tests/unit/components/base-vector-layer-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/components');
  test('unit/components/base-vector-layer-test.js should pass jscs', function () {
    ok(true, 'unit/components/base-vector-layer-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/components/base-vector-layer-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/components/base-vector-layer-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/components/base-vector-layer-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/components/flexberry-map-test', ['exports', 'ember', 'ember-qunit', 'sinon'], function (exports, _ember, _emberQunit, _sinon) {

  (0, _emberQunit.moduleForComponent)('flexberry-map', 'Unit | Component | flexberry map', {
    unit: true,
    needs: ['component:flexberry-layers', 'service:map-api', 'service:i18n', 'map-tool:drag', 'config:environment']
  });

  (0, _emberQunit.test)('it should create leaflet map on didInsertElement', function (assert) {
    var component = this.subject();
    this.render();
    assert.ok(component.get('_leafletObject') instanceof L.Map);
  });

  (0, _emberQunit.test)('test function queryToMap', function (assert) {
    assert.expect(8);
    var leafletMap = L.map(document.createElement('div'), {
      center: [51.505, -0.09],
      zoom: 13
    });
    var querySpy = _sinon['default'].stub(leafletMap, 'fire', function (st, e) {
      e.results.push({ features: _ember['default'].RSVP.resolve([{ id: '1' }]) });
    });
    var component = this.subject({
      _leafletObject: leafletMap
    });
    var done = assert.async(2);

    var res = component._queryToMap('1', '2');

    assert.ok(res instanceof _ember['default'].RSVP.Promise, 'Является ли результат работы функции Promise');
    res.then(function (e) {
      assert.equal(e.results.length, 1, 'Length results equals 1');
      assert.equal(e.queryFilter, '1', 'Check parameter queryFilter');
      assert.equal(e.mapObjectSetting, '2', 'Check parameter mapObjectSetting');
      assert.equal(querySpy.callCount, 1, 'Count call method fire');
      assert.equal(querySpy.args[0][0], 'flexberry-map:query', 'Check call first arg to method fire');
      assert.deepEqual(querySpy.args[0][1], e, 'Check call second arg to method fire');
      e.results[0].features.then(function (result) {
        assert.equal(result[0].id, 1, 'Cherck result id');
        done(1);
      });
      done(1);
    });
  });

  (0, _emberQunit.test)('should compute center from lat/lng', function (assert) {
    var lat = 10;
    var lng = 10;

    var component = this.subject({ lat: lat, lng: lng });

    var center = component.get('center');
    assert.ok(center instanceof L.LatLng);
    assert.ok(center.equals([10, 10]));
  });

  (0, _emberQunit.test)('should pass center/zoom from properties to leaflet map', function (assert) {
    assert.expect(4);

    var component = this.subject({
      lat: 10,
      lng: 10,
      zoom: 10
    });

    this.render();

    var leafletMap = component.get('_leafletObject');

    assert.equal(leafletMap.getZoom(), 10);
    assert.ok(leafletMap.getCenter().equals([10, 10]));

    _ember['default'].run(function () {
      component.set('zoom', 0);
    });

    assert.equal(leafletMap.getZoom(), 0);

    // After update to leaflet-1.0.0 panTo not directly change center,
    // it will changed after animation will trigger 'moveend' event.
    var promise = new _ember['default'].Test.promise(function (resolve) {
      leafletMap.on('moveend', function () {
        setTimeout(resolve, 500);
      });
    });

    _ember['default'].run(function () {
      component.setProperties({
        'lat': 0,
        'lng': 0
      });
    });

    return promise.then(function () {
      assert.ok(leafletMap.getCenter().equals([0, 0]));
    });
  });

  (0, _emberQunit.test)('should pass zoomSnap/zoomDelta options to leaflet map', function (assert) {
    var component = this.subject({
      zoomSnap: 0.5,
      zoomDelta: 0.1
    });

    this.render();

    var leafletMap = component.get('_leafletObject');

    assert.equal(leafletMap.options.zoomSnap, 0.5);
    assert.equal(leafletMap.options.zoomDelta, 0.1);
  });
});
define('dummy/tests/unit/components/flexberry-map-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/components');
  test('unit/components/flexberry-map-test.js should pass jscs', function () {
    ok(true, 'unit/components/flexberry-map-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/components/flexberry-map-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/components/flexberry-map-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/components/flexberry-map-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/components/layers/group-layer-test', ['exports', 'ember-qunit', 'sinon'], function (exports, _emberQunit, _sinon) {

  (0, _emberQunit.moduleForComponent)('layers/group-layer', 'Unit | Component | layers/group layer', {
    unit: true
  });

  (0, _emberQunit.test)('it return L.LayerGroup on createLayer', function (assert) {
    assert.expect(1);

    var component = this.subject();
    var layer = component.createLayer();
    assert.ok(layer instanceof L.LayerGroup, 'Expected L.LayerGroup instance');
  });

  (0, _emberQunit.test)('it not call _leafletObject.setZIndex on setZIndex', function (assert) {
    assert.expect(1);

    var component = this.subject();
    var leafletLayerPromiseResolved = assert.async();
    component.get('_leafletLayerPromise').then(function (leafletLayer) {
      var layer = component.get('_leafletObject');
      var spy = _sinon['default'].spy(layer, 'setZIndex');

      component.setZIndex(0);

      assert.equal(spy.callCount, 0);
    })['finally'](function () {
      leafletLayerPromiseResolved();
    });
  });
});
define('dummy/tests/unit/components/layers/group-layer-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/components/layers');
  test('unit/components/layers/group-layer-test.js should pass jscs', function () {
    ok(true, 'unit/components/layers/group-layer-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/components/layers/group-layer-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/components/layers/group-layer-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/components/layers/group-layer-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/components/layers/odata-vector-layer-test', ['exports', 'ember', 'ember-data', 'ember-qunit', 'dummy/tests/helpers/start-app', 'ember-flexberry-data', 'sinon', 'ember-flexberry-gis/coordinate-reference-systems/epsg-4326'], function (exports, _ember, _emberData, _emberQunit, _dummyTestsHelpersStartApp, _emberFlexberryData, _sinon, _emberFlexberryGisCoordinateReferenceSystemsEpsg4326) {

  var app = undefined;
  var options = undefined;
  var param = undefined;
  var odataServerFake = undefined;
  var bounds = undefined;
  var store = undefined;
  var responseBatchUpdate = undefined;

  (0, _emberQunit.moduleForComponent)('layers/odata-vector-layer', 'Unit | Component | layers/odata vector layer', {
    unit: true,
    needs: ['service:map-api', 'service:layers-styles-renderer', 'config:environment', 'model:new-platform-flexberry-g-i-s-link-parameter', 'model:new-platform-flexberry-g-i-s-map', 'model:new-platform-flexberry-g-i-s-map-layer', 'adapter:application', 'layer:odata-vector'],
    beforeEach: function beforeEach() {
      app = (0, _dummyTestsHelpersStartApp['default'])();

      var testModelMixin = _ember['default'].Mixin.create({
        name: _emberData['default'].attr('string', { defaultValue: '' }),
        shape: _emberData['default'].attr('json')
      });

      var testModel = _emberFlexberryData.Projection.Model.extend(testModelMixin);
      testModel.defineProjection('TestModelL', 'test-model', {
        name: _emberFlexberryData.Projection.attr(''),
        shape: _emberFlexberryData.Projection.attr('')
      });

      var testSerializer = _emberFlexberryData.Serializer.Odata.extend({
        primaryKey: '__PrimaryKey'
      });

      this.register('model:test-model', testModel);
      this.register('mixin:test-model', testModelMixin);
      this.register('serializer:test-model', testSerializer);

      app.register('model:test-model', testModel);
      app.register('mixin:test-model', testModelMixin);
      app.register('serializer:test-model', testSerializer);

      options = {
        geometryField: 'shape',
        showExisting: false,
        withCredentials: false,
        crs: L.CRS.EPSG3857,
        continueLoading: false
      };

      var leafletOptions = ['geometryField', 'crs', 'maxFeatures', 'showExisting', 'style', 'forceMulti', 'withCredentials', 'continueLoading'];

      param = {
        format: 'GeoJSON',
        leafletOptions: leafletOptions
      };
      param = _ember['default'].$.extend(param, options);

      bounds = L.latLngBounds(L.latLng(58.4436454695997, 56.369991302490234), L.latLng(58.46793791815783, 56.53478622436524));
      var getBounds = function getBounds() {
        return bounds;
      };

      var getPane = function getPane() {
        return undefined;
      };

      var createPane = function createPane() {
        return {};
      };

      var hasLayer = function hasLayer() {
        return true;
      };

      var removeLayer = function removeLayer() {
        return {};
      };

      store = app.__container__.lookup('service:store');
      var layerModel = store.createRecord('test-model');
      layerModel.type = 'odata-vector';
      layerModel.visibility = true;
      _ember['default'].$.extend(param, {
        'geometryType': 'MultiPolygonPropertyType',
        'modelName': 'test-model',
        'projectionName': 'TestModelL',
        'geometryField': 'shape',
        'typeName': 'test-model',
        'odataClass': 'TestModel',
        'continueLoading': true,
        'store': store,
        'layerModel': layerModel,
        'leafletMap': {
          getBounds: getBounds,
          getPane: getPane,
          createPane: createPane,
          hasLayer: hasLayer,
          removeLayer: removeLayer
        }
      });

      odataServerFake = _sinon['default'].fakeServer.create();
      odataServerFake.autoRespond = true;

      var responseText = '--batchresponse_97a87974-3baf-4a2d-a8d4-bc7af540b74f\n    Content-Type: application/http\n    Content-Transfer-Encoding: binary\n\n    HTTP/1.1 200 OK\n    Content-Type: application/json; charset=utf-8; odata.metadata=minimal\n    OData-Version: 4.0\n\n    {\n      "@odata.context":"http://dh.ics.perm.ru:8085/map/odata/$metadata#TestModel(__PrimaryKey,ID,Name,Shape)","value":[\n        {\n          "__PrimaryKey":"13681407-924d-4d2f-9c0d-f3059830a79b", "Name":null,"Shape":{\n            "type":"MultiPolygon","coordinates":[\n              [\n                [\n                  [468709.463318981,6478884.81118851],\n            [468578.508624007,6478880.73565037],\n            [468541.567377907,6478925.23599015],\n            [468533.564191116,6478946.2331571],\n            [468614.492922407,6478979.21144234],\n            [468657.52589005,6478981.2057549],\n            [468672.503518996,6478963.71619159],\n            [468717.482394432,6478946.21010284],\n            [468709.463318981,6478884.81118851]\n                ]\n              ]\n            ],"crs":{\n              "type":"name","properties":{\n                "name":"EPSG:32640"\n              }\n            }\n          }\n      },\n\n      {\n          "__PrimaryKey":"5b969764-acc2-4b48-8d6a-33b395c811ce", "Name":null,"Shape":{\n            "type":"MultiPolygon","coordinates":[\n              [\n                [\n                  [468709.463318981,6478884.81118851],\n            [468578.508624007,6478880.73565037],\n            [468541.567377907,6478925.23599015],\n            [468533.564191116,6478946.2331571],\n            [468614.492922407,6478979.21144234],\n            [468657.52589005,6478981.2057549],\n            [468672.503518996,6478963.71619159],\n            [468717.482394432,6478946.21010284],\n            [468709.463318981,6478884.81118851]\n                ]\n              ]\n            ],"crs":{\n              "type":"name","properties":{\n                "name":"EPSG:32640"\n              }\n            }\n          }\n      }\n      ]\n    }\n    --batchresponse_97a87974-3baf-4a2d-a8d4-bc7af540b74f--';

      responseBatchUpdate = '--batchresponse_36948c8f-1a0a-46f7-b66d-6692dc185197\n    Content-Type: multipart/mixed; boundary=changesetresponse_80ff11bf-cdeb-4dd0-9654-e316dc4bd7a0\n\n    --changesetresponse_80ff11bf-cdeb-4dd0-9654-e316dc4bd7a0\n    Content-Type: application/http\n    Content-Transfer-Encoding: binary\n    Content-ID: 1\n\n    HTTP/1.1 204 No Content\n\n\n    --changesetresponse_80ff11bf-cdeb-4dd0-9654-e316dc4bd7a0\n    Content-Type: application/http\n    Content-Transfer-Encoding: binary\n    Content-ID: 2\n\n    HTTP/1.1 200 OK\n    Preference-Applied: return=representation\n    Content-Type: application/json; charset=utf-8; odata.metadata=minimal\n    OData-Version: 4.0\n\n    {\n      "@odata.context":"http://dh.ics.perm.ru:8085/map/odata/$metadata#TestModel/$entity","Shape":{\n        "type":"MultiPolygon","coordinates":[\n          [\n            [\n              [\n                436033.67676677159,6495840.3180785989\n              ],[\n                436363.34399267368,6496168.5915842094\n              ],[\n                436698.1414727,6495894.2219982184\n              ],[\n                436423.43417282181,6495569.9820099371\n              ],[\n                436033.67676677159,6495840.3180785989\n              ]\n            ]\n          ]\n        ],"crs":{\n          "type":"name","properties":{\n            "name":"EPSG:32640"\n          }\n        }\n      },"Name":"test","__PrimaryKey":"13681407-924d-4d2f-9c0d-f3059830a79b"\n    }\n    --changesetresponse_80ff11bf-cdeb-4dd0-9654-e316dc4bd7a0\n    Content-Type: application/http\n    Content-Transfer-Encoding: binary\n    Content-ID: 3\n\n    HTTP/1.1 201 Created\n    Preference-Applied: return=representation\n    Content-Type: application/json; charset=utf-8; odata.metadata=minimal\n    OData-Version: 4.0\n\n    {\n      "@odata.context":"http://dh.ics.perm.ru:8085/map/odata/$metadata#TestModel/$entity","Shape":{\n        "type":"MultiPolygon","coordinates":[\n          [\n            [\n              [\n                437417.96742371243,6495668.4535367191\n              ],[\n                437838.01481024339,6495726.4829143463\n              ],[\n                437685.16544237174,6495215.9105252894\n              ],[\n                437417.96742371243,6495668.4535367191\n              ]\n            ]\n          ]\n        ],"crs":{\n          "type":"name","properties":{\n            "name":"EPSG:32640"\n          }\n        }\n      },"Name":null,"__PrimaryKey":"a5532858-dbdc-4d3c-9eaf-3d71d097ceb0"\n    }\n    --changesetresponse_80ff11bf-cdeb-4dd0-9654-e316dc4bd7a0--\n    --batchresponse_36948c8f-1a0a-46f7-b66d-6692dc185197\n    Content-Type: application/http\n    Content-Transfer-Encoding: binary\n\n    HTTP/1.1 200 OK\n    Content-Type: application/json; charset=utf-8; odata.metadata=minimal\n    OData-Version: 4.0\n\n    {\n      "@odata.context":"http://dh.ics.perm.ru:8085/map/odata/$metadata#TestModel/$entity","Shape":{\n        "type":"MultiPolygon","coordinates":[\n          [\n            [\n              [\n                436033.676766772,6495840.3180786\n              ],[\n                436363.343992674,6496168.59158421\n              ],[\n                436698.1414727,6495894.22199822\n              ],[\n                436423.434172822,6495569.98200994\n              ],[\n                436033.676766772,6495840.3180786\n              ]\n            ]\n          ]\n        ],"crs":{\n          "type":"name","properties":{\n            "name":"EPSG:32640"\n          }\n        }\n      },"Name":"test","__PrimaryKey":"13681407-924d-4d2f-9c0d-f3059830a79b"\n    }\n    --batchresponse_36948c8f-1a0a-46f7-b66d-6692dc185197\n    Content-Type: application/http\n    Content-Transfer-Encoding: binary\n\n    HTTP/1.1 200 OK\n    Content-Type: application/json; charset=utf-8; odata.metadata=minimal\n    OData-Version: 4.0\n\n    {\n      "@odata.context":"http://dh.ics.perm.ru:8085/map/odata/$metadata#TestModel/$entity","Shape":{\n        "type":"MultiPolygon","coordinates":[\n          [\n            [\n              [\n                437417.967423712,6495668.45353672\n              ],[\n                437838.014810243,6495726.48291435\n              ],[\n                437685.165442372,6495215.91052529\n              ],[\n                437417.967423712,6495668.45353672\n              ]\n            ]\n          ]\n        ],"crs":{\n          "type":"name","properties":{\n            "name":"EPSG:32640"\n          }\n        }\n      },"Name":null,"__PrimaryKey":"a5532858-dbdc-4d3c-9eaf-3d71d097ceb0"\n    }\n    --batchresponse_36948c8f-1a0a-46f7-b66d-6692dc185197--';

      odataServerFake.respondWith('POST', 'http://134.209.30.115:1818/odata/$batch', function (request) {
        if (request.requestBody.indexOf('POST') !== -1) {
          request.respond(200, { 'content-type': 'multipart/mixed; boundary=batchresponse_36948c8f-1a0a-46f7-b66d-6692dc185197' }, responseBatchUpdate);
        } else {
          request.respond(200, { 'content-type': 'multipart/mixed; boundary=batchresponse_97a87974-3baf-4a2d-a8d4-bc7af540b74f' }, responseText);
        }
      });
    },
    afterEach: function afterEach() {
      _ember['default'].run(app, 'destroy');
      odataServerFake.restore();
    }
  });

  var jsonModel = {
    name: 'TestModel',
    modelName: 'test-model',
    className: 'TestModel',
    nameSpace: 'nm',
    parentModelName: null,
    parentClassName: null,
    attrs: [{
      name: 'shape',
      type: 'json',
      flexberryType: 'polygon32640',
      notNull: false,
      defaultValue: '',
      stored: true,
      ordered: false
    }, {
      name: 'nomer',
      type: 'string',
      flexberryType: 'Строка250',
      notNull: false,
      defaultValue: '',
      stored: true,
      ordered: false
    }],
    belongsTo: [],
    hasMany: [],
    projections: [{
      name: 'AuditView',
      modelName: 'test-model',
      attrs: [{
        name: 'shape',
        caption: '',
        hidden: false,
        index: 0
      }, {
        name: 'nomer',
        caption: '',
        hidden: false,
        index: 1
      }],
      belongsTo: [],
      hasMany: []
    }, {
      name: 'TestModel_L',
      modelName: 'test-model',
      attrs: [{
        name: 'shape',
        caption: '',
        hidden: false,
        index: 0
      }, {
        name: 'nomer',
        caption: '',
        hidden: false,
        index: 1
      }],
      belongsTo: [],
      hasMany: []
    }],
    stored: true,
    offline: true,
    external: false
  };

  var realCountArr = function realCountArr(arr) {
    return arr.filter(function (item) {
      if (item) {
        return item;
      }
    }).length;
  };

  (0, _emberQunit.test)('getFilterParameters return SimplePredicate on single value in array', function (assert) {
    var _this = this;

    assert.expect(2);
    var done = assert.async(1);
    _ember['default'].run(function () {
      // arrange
      var component = _this.subject();
      var linkParameter = _ember['default'].Object.create({
        'queryKey': 'PK',
        'layerField': 'testField'
      });

      // act
      var result = component.getFilterParameters([linkParameter], { 'PK': ['id1'] });

      // assert
      var firstValue = result[0];
      assert.ok(firstValue instanceof _emberFlexberryData.Query.SimplePredicate);
      assert.equal(firstValue.toString(), '(testField eq id1)');
      done();
    });
  });

  (0, _emberQunit.test)('loadLayerFeatures() with featureIds=null', function (assert) {
    var _this2 = this;

    assert.expect(2);
    var done = assert.async(3);
    _ember['default'].run(function () {
      var component = _this2.subject(param);

      var mapModel = store.createRecord('new-platform-flexberry-g-i-s-map');
      var getmapApiStub = _sinon['default'].stub(component.get('mapApi'), 'getFromApi');
      getmapApiStub.returns(mapModel);

      var getPkFieldStub = _sinon['default'].stub(mapModel, '_getLayerFeatureId');
      getPkFieldStub.returns('123');

      var e = {
        featureIds: null,
        layer: 'f34ea73d-9f00-4f02-b02d-675d459c972b',
        results: _ember['default'].A()
      };

      component.get('_leafletLayerPromise').then(function (leafletLayer) {
        component.set('_leafletObject', leafletLayer);

        component.loadLayerFeatures(e).then(function (layers) {
          assert.ok(layers, 'Load with null featureIds');
          done();
        });
      })['finally'](function () {
        done();
        getmapApiStub.restore();
        getPkFieldStub.restore();
      });

      assert.ok(component, 'Create odata-layer');
      done();
    });
  });

  (0, _emberQunit.test)('getLayerFeatures() with featureIds=null', function (assert) {
    var _this3 = this;

    assert.expect(2);
    var done = assert.async(3);
    _ember['default'].run(function () {
      var component = _this3.subject(param);

      var getCountFeaturesStub = _sinon['default'].stub(component, 'getCountFeatures');
      getCountFeaturesStub.returns(_ember['default'].run(function () {
        return _ember['default'].RSVP.resolve(123);
      }));

      var e = {
        featureIds: null,
        layer: 'f34ea73d-9f00-4f02-b02d-675d459c972b',
        results: _ember['default'].A()
      };

      component.get('_leafletLayerPromise').then(function (leafletLayer) {
        component.set('_leafletObject', leafletLayer);

        component.getLayerFeatures(e).then(function (layers) {
          assert.ok(layers, 'Get with null featureIds');
          done();
        });
      })['finally'](function () {
        done();
        getCountFeaturesStub.restore();
      });

      assert.ok(component, 'Create odata-layer');
      done();
    });
  });

  (0, _emberQunit.test)('continueLoad()', function (assert) {
    var _this4 = this;

    assert.expect(7);
    var done = assert.async(3);

    _ember['default'].run(function () {
      var component = _this4.subject(param);
      _ember['default'].run(function () {
        component.get('_leafletLayerPromise').then(function (leafletLayer) {
          component.set('_leafletObject', leafletLayer);
          leafletLayer.promiseLoadLayer.then(_ember['default'].run(function () {
            var loadedBounds = component.get('loadedBounds');
            assert.ok(loadedBounds, 'loadedBounds');
            assert.ok(loadedBounds.getBounds() instanceof L.LatLngBounds, 'loadedBounds.getBounds() is L.LatLngBounds');
            assert.ok(JSON.stringify(loadedBounds.getBounds()) === JSON.stringify(bounds), 'loadedBounds get from map');

            bounds = L.latLngBounds(L.latLng(58.46807257997011, 56.61014556884766), L.latLng(58.443780224452524, 56.44535064697266));

            var load = component.continueLoad();
            load.then(_ember['default'].run(function () {
              loadedBounds = component.get('loadedBounds');
              assert.ok(loadedBounds, 'loadedBounds');
              assert.ok(loadedBounds.getBounds() instanceof L.LatLngBounds, 'loadedBounds.getBounds() is L.LatLngBounds');
              var strBounds = '{"_southWest":{"lat":58.4436454695997,"lng":56.369991302490234},"_northEast":{"lat":58.46807257997011,"lng":56.61014556884766}}';
              assert.ok(JSON.stringify(loadedBounds.getBounds()) === strBounds, 'loadedBounds get from map');

              done();
            }));
          }));
        })['finally'](function () {
          done();
        });
      });

      assert.ok(component, 'Create odata-layer');
      done();
    });
  });

  (0, _emberQunit.test)('test methos identify()', function (assert) {
    var _this5 = this;

    assert.expect(3);
    var done = assert.async(1);
    _ember['default'].run(function () {
      var latlngs = [[L.latLng(30, 10), L.latLng(40, 40), L.latLng(20, 40), L.latLng(10, 20)]];
      var layer = L.polygon(latlngs);
      var e = {
        polygonLayer: layer
      };
      _ember['default'].$.extend(param, {
        crs: _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default'].create(),
        _getFeature: function _getFeature() {
          return _ember['default'].RSVP.resolve(['1']);
        },
        _addLayersOnMap: function _addLayersOnMap() {
          return null;
        }
      });
      var component = _this5.subject(param);
      var spyGetFeature = _sinon['default'].spy(component, '_getFeature');

      component.identify(e);

      assert.ok(spyGetFeature.getCall(0).args[0] instanceof _emberFlexberryData.Query.GeometryPredicate);
      assert.equal(spyGetFeature.getCall(0).args[0]._attributePath, 'shape');
      assert.equal(spyGetFeature.getCall(0).args[0]._intersectsValue, 'SRID=4326;POLYGON((10 30, 40 40, 40 20, 20 10, 10 30))');
      done();
      spyGetFeature.restore();
    });
  });

  (0, _emberQunit.test)('test method createAdapterForModel() with odataUrl', function (assert) {
    assert.expect(1);
    _ember['default'].$.extend(param, {
      'odataUrl': 'http://localhost:6500/odata/'
    });
    var component = this.subject(param);

    var adapterModel = component.createAdapterForModel();

    assert.ok(adapterModel);
  });

  (0, _emberQunit.test)('test method createAdapterForModel() without odataUrl', function (assert) {
    assert.expect(1);
    var component = this.subject(param);

    var adapterModel = component.createAdapterForModel();

    assert.notOk(adapterModel);
  });

  (0, _emberQunit.test)('test method createDynamicModel() with json', function (assert) {
    assert.expect(24);
    var done = assert.async(1);
    _ember['default'].$.extend(param, {
      'odataUrl': 'http://localhost:6500/odata/',
      'namespace': 'NS',
      'metadataUrl': 'assert/felxberry/models/'
    });
    jsonModel.parentModelName = null;
    var component = this.subject(param);
    var spyUnregister = _sinon['default'].spy(_ember['default'].getOwner(this), 'unregister');
    var spyRegister = _sinon['default'].spy(_ember['default'].getOwner(this), 'register');
    var spyCreateAdapterForModel = _sinon['default'].spy(component, 'createAdapterForModel');
    var spyCreateModel = _sinon['default'].spy(component, 'createModel');
    var spyCreateProjection = _sinon['default'].spy(component, 'createProjection');
    var spyCreateMixin = _sinon['default'].spy(component, 'createMixin');
    var spyCreateSerializer = _sinon['default'].spy(component, 'createSerializer');
    var spyCreateModelHierarchy = _sinon['default'].spy(component, 'сreateModelHierarchy');
    var stubAjax = _sinon['default'].stub(_ember['default'].$, 'ajax');
    stubAjax.yieldsTo('success', jsonModel);

    component.createDynamicModel().then(function () {
      assert.equal(spyCreateAdapterForModel.callCount, 1);
      assert.equal(spyCreateModel.callCount, 1);
      assert.equal(spyCreateProjection.callCount, 1);
      assert.equal(spyCreateMixin.callCount, 1);
      assert.equal(spyCreateSerializer.callCount, 1);

      assert.equal(spyUnregister.callCount, 4);
      assert.equal(spyUnregister.firstCall.args[0], 'model:test-model');
      assert.equal(spyUnregister.secondCall.args[0], 'mixin:test-model');
      assert.equal(spyUnregister.thirdCall.args[0], 'serializer:test-model');
      assert.equal(spyUnregister.lastCall.args[0], 'adapter:test-model');

      assert.equal(spyRegister.callCount, 4);
      assert.equal(spyRegister.firstCall.args[0], 'model:test-model');
      assert.ok(spyRegister.firstCall.args[1].ClassMixin.mixins[1].properties.hasOwnProperty('namespace'));
      assert.equal(spyRegister.firstCall.args[1].ClassMixin.mixins[1].properties.namespace, 'NS');
      assert.ok(spyRegister.firstCall.args[1].ClassMixin.mixins[2].properties.projections.hasOwnProperty('TestModelL'));
      assert.equal(spyRegister.secondCall.args[0], 'mixin:test-model');
      assert.equal(Object.values(spyRegister.secondCall.args[1].mixins[0].properties).length, 2);
      assert.ok(spyRegister.secondCall.args[1].mixins[0].properties.hasOwnProperty('nomer'));
      assert.ok(spyRegister.secondCall.args[1].mixins[0].properties.hasOwnProperty('shape'));
      assert.equal(spyRegister.thirdCall.args[0], 'serializer:test-model');
      assert.equal(spyRegister.lastCall.args[0], 'adapter:test-model');
      assert.ok(spyRegister.lastCall.args[1].PrototypeMixin.mixins[2].properties.hasOwnProperty('host'));
      assert.equal(spyRegister.lastCall.args[1].PrototypeMixin.mixins[2].properties.host, 'http://localhost:6500/odata/');

      assert.equal(spyCreateModelHierarchy.callCount, 1);

      done();
      spyRegister.restore();
      spyUnregister.restore();
      spyCreateAdapterForModel.restore();
      spyCreateModel.restore();
      spyCreateProjection.restore();
      spyCreateMixin.restore();
      spyCreateSerializer.restore();
      spyCreateModelHierarchy.restore();
      stubAjax.restore();
    });
  });

  (0, _emberQunit.test)('test method createDynamicModel() with json with parent', function (assert) {
    assert.expect(27);
    var done = assert.async(1);
    _ember['default'].$.extend(param, {
      'odataUrl': 'http://localhost:6500/odata/',
      'namespace': 'NS',
      'metadataUrl': 'assert/felxberry/models/'
    });

    var component = this.subject(param);
    var spyUnregister = _sinon['default'].spy(_ember['default'].getOwner(this), 'unregister');
    var spyRegister = _sinon['default'].spy(_ember['default'].getOwner(this), 'register');
    var spyCreateAdapterForModel = _sinon['default'].spy(component, 'createAdapterForModel');
    var spyCreateModel = _sinon['default'].spy(component, 'createModel');
    var spyCreateProjection = _sinon['default'].spy(component, 'createProjection');
    var spyCreateMixin = _sinon['default'].spy(component, 'createMixin');
    var spyCreateSerializer = _sinon['default'].spy(component, 'createSerializer');
    var spyCreateModelHierarchy = _sinon['default'].spy(component, 'сreateModelHierarchy');

    jsonModel.parentModelName = 'Polygon32640';
    var parentJsonModel = {
      name: 'Polygon32640',
      modelName: 'Polygon32640',
      className: 'Polygon32640',
      nameSpace: 'NS1',
      parentModelName: null,
      parentClassName: null,
      attrs: [{
        name: 'name',
        type: 'string',
        flexberryType: 'Строка250',
        notNull: false,
        defaultValue: '',
        stored: true,
        ordered: false
      }],
      belongsTo: [],
      hasMany: [],
      projections: [],
      stored: false,
      offline: true,
      external: false
    };

    var stubAjax = _sinon['default'].stub(_ember['default'].$, 'ajax');
    stubAjax.onCall(0).yieldsTo('success', jsonModel).onCall(1).yieldsTo('success', parentJsonModel);

    component.createDynamicModel().then(function () {
      assert.equal(spyCreateAdapterForModel.callCount, 1);
      assert.equal(spyCreateModel.callCount, 1);
      assert.equal(spyCreateProjection.callCount, 1);
      assert.equal(spyCreateMixin.callCount, 2);
      assert.equal(spyCreateSerializer.callCount, 1);
      assert.equal(stubAjax.callCount, 2);
      assert.equal(stubAjax.getCall(0).args[0].url, 'assert/felxberry/models/test-model.json');
      assert.equal(stubAjax.getCall(1).args[0].url, 'assert/felxberry/models/Polygon32640.json');

      assert.equal(spyUnregister.callCount, 4);
      assert.equal(spyUnregister.firstCall.args[0], 'model:test-model');
      assert.equal(spyUnregister.secondCall.args[0], 'mixin:test-model');
      assert.equal(spyUnregister.thirdCall.args[0], 'serializer:test-model');
      assert.equal(spyUnregister.lastCall.args[0], 'adapter:test-model');

      assert.equal(spyRegister.callCount, 4);
      assert.equal(spyRegister.firstCall.args[0], 'model:test-model');
      assert.ok(spyRegister.firstCall.args[1].ClassMixin.mixins[1].properties.hasOwnProperty('namespace'));
      assert.equal(spyRegister.firstCall.args[1].ClassMixin.mixins[1].properties.namespace, 'NS');
      assert.ok(spyRegister.firstCall.args[1].ClassMixin.mixins[2].properties.projections.hasOwnProperty('TestModelL'));
      assert.equal(spyRegister.secondCall.args[0], 'mixin:test-model');
      assert.equal(Object.values(spyRegister.secondCall.args[1].mixins[0].properties).length, 2);
      assert.ok(spyRegister.secondCall.args[1].mixins[0].properties.hasOwnProperty('nomer'));
      assert.ok(spyRegister.secondCall.args[1].mixins[0].properties.hasOwnProperty('shape'));
      assert.equal(spyRegister.thirdCall.args[0], 'serializer:test-model');
      assert.equal(spyRegister.lastCall.args[0], 'adapter:test-model');
      assert.ok(spyRegister.lastCall.args[1].PrototypeMixin.mixins[2].properties.hasOwnProperty('host'));
      assert.equal(spyRegister.lastCall.args[1].PrototypeMixin.mixins[2].properties.host, 'http://localhost:6500/odata/');

      assert.equal(spyCreateModelHierarchy.callCount, 2);

      done();
      spyRegister.restore();
      spyUnregister.restore();
      spyCreateAdapterForModel.restore();
      spyCreateModel.restore();
      spyCreateProjection.restore();
      spyCreateMixin.restore();
      spyCreateSerializer.restore();
      stubAjax.restore();
      spyCreateModelHierarchy.restore();
    });
  });

  (0, _emberQunit.test)('test method createDynamicModel() without json', function (assert) {
    assert.expect(1);
    var done = assert.async(1);
    var component = this.subject(param);

    component.createDynamicModel()['catch'](function (error) {
      assert.equal(error, 'Can\'t create dynamic model: test-model. Error: ModelName and metadataUrl is empty');
      done();
    });
  });

  (0, _emberQunit.test)('test method _createVectorLayer()', function (assert) {
    assert.expect(3);
    param.layerModel.visibility = false;
    var component = this.subject(param);
    var spyContinueLoad = _sinon['default'].spy(component, 'continueLoad');

    var layerResult = component._createVectorLayer();

    assert.ok(layerResult);
    assert.equal(spyContinueLoad.callCount, 1);
    assert.equal(spyContinueLoad.getCall(0).args[0], layerResult);

    spyContinueLoad.restore();
  });

  (0, _emberQunit.test)('test method createVectorLayer() without dynamicModel', function (assert) {
    assert.expect(7);
    var done = assert.async(1);
    param.layerModel.visibility = false;
    var component = this.subject(param);
    var spyContinueLoad = _sinon['default'].spy(component, 'continueLoad');
    var _createVectorLayerSpy = _sinon['default'].spy(component, '_createVectorLayer');
    var spyCreateDynamicModel = _sinon['default'].spy(component, 'createDynamicModel');
    var spyAjax = _sinon['default'].spy(_ember['default'].$, 'ajax');
    var spyCreateModelHierarchy = _sinon['default'].spy(component, 'сreateModelHierarchy');

    component.createVectorLayer().then(function (layer) {
      assert.ok(layer);
      assert.equal(spyContinueLoad.callCount, 1);
      assert.equal(spyContinueLoad.getCall(0).args[0], layer);
      assert.equal(_createVectorLayerSpy.callCount, 1);
      assert.equal(spyAjax.callCount, 0);
      assert.equal(spyCreateDynamicModel.callCount, 0);
      assert.equal(spyCreateModelHierarchy.callCount, 0);
      done();
      spyContinueLoad.restore();
      _createVectorLayerSpy.restore();
      spyAjax.restore();
      spyCreateDynamicModel.restore();
      spyCreateModelHierarchy.restore();
    });
  });

  (0, _emberQunit.test)('test method createVectorLayer() with dynamicModel=true', function (assert) {
    assert.expect(8);
    var done = assert.async(1);
    param.layerModel.visibility = false;
    param.dynamicModel = true;
    param.metadataUrl = 'assert/felxberry/models/';
    param.odataUrl = 'http://localhost:6500/odata/';
    jsonModel.parentModelName = null;
    var component = this.subject(param);
    var spyContinueLoad = _sinon['default'].spy(component, 'continueLoad');
    var _createVectorLayerSpy = _sinon['default'].spy(component, '_createVectorLayer');
    var spyCreateDynamicModel = _sinon['default'].spy(component, 'createDynamicModel');
    var stubAjax = _sinon['default'].stub(_ember['default'].$, 'ajax');
    stubAjax.yieldsTo('success', jsonModel);
    var spyCreateModelHierarchy = _sinon['default'].spy(component, 'сreateModelHierarchy');

    component.createVectorLayer().then(function (layer) {
      assert.ok(layer);
      assert.equal(spyContinueLoad.callCount, 1);
      assert.equal(spyContinueLoad.getCall(0).args[0], layer);
      assert.equal(_createVectorLayerSpy.callCount, 1);
      assert.equal(stubAjax.callCount, 1);
      assert.equal(stubAjax.getCall(0).args[0].url, 'assert/felxberry/models/test-model.json');
      assert.equal(spyCreateDynamicModel.callCount, 1);
      assert.equal(spyCreateModelHierarchy.callCount, 1);
      done();
      spyContinueLoad.restore();
      _createVectorLayerSpy.restore();
      spyCreateDynamicModel.restore();
      stubAjax.restore();
      spyCreateModelHierarchy.restore();
    });
  });

  (0, _emberQunit.test)('test method save() no modified objects', function (assert) {
    assert.expect(5);
    var done = assert.async(1);
    var component = this.subject(param);

    component.get('_leafletLayerPromise').then(function (leafletLayer) {
      component.set('_leafletObject', leafletLayer);
      leafletLayer.promiseLoadLayer.then(function () {
        var leafletObject = component.get('_leafletObject');
        var obj = component.get('_adapterStoreModelProjectionGeom');
        var spyBatchUpdate = _sinon['default'].spy(obj.adapter, 'batchUpdate');

        assert.equal(realCountArr(leafletObject.models), 0);
        assert.equal(leafletObject.getLayers().length, 2);

        component.save();

        assert.equal(realCountArr(leafletObject.models), 0);
        assert.equal(leafletObject.getLayers().length, 2);
        assert.equal(spyBatchUpdate.callCount, 0);
        done();

        spyBatchUpdate.restore();
      });
    });
  });

  (0, _emberQunit.test)('test method save() with objects', function (assert) {
    assert.expect(15);
    var done = assert.async(1);
    var component = this.subject(param);

    component.get('_leafletLayerPromise').then(function (leafletLayer) {
      component.set('_leafletObject', leafletLayer);
      leafletLayer.promiseLoadLayer.then(function () {
        var leafletObject = component.get('_leafletObject');
        var obj = component.get('_adapterStoreModelProjectionGeom');
        var spyBatchUpdate = _sinon['default'].spy(obj.adapter, 'batchUpdate');

        assert.equal(realCountArr(leafletObject.models), 0);
        assert.equal(leafletObject.getLayers().length, 2);

        var layerUpdate = leafletObject.getLayers()[0];
        layerUpdate.feature.properties.name = 'test';
        leafletObject.editLayer(layerUpdate);

        assert.equal(realCountArr(leafletObject.models), 1);
        assert.equal(leafletObject.getLayers().length, 2);

        var layerRemove = leafletObject.getLayers()[1];
        leafletObject.removeLayer(layerRemove);

        assert.equal(realCountArr(leafletObject.models), 2);
        assert.equal(leafletObject.getLayers().length, 1);

        var feature = {
          type: 'Polygon',
          coordinates: [[[10, 30], [40, 40], [40, 20], [20, 10], [10, 30]]]
        };
        var layerAdd = L.geoJSON(feature).getLayers()[0];
        layerAdd._label = {
          _leaflet_id: 1000
        };
        leafletObject.addLayer(layerAdd);
        leafletObject._labelsLayer = {
          1000: {}
        };
        var pk = layerAdd.feature.properties.primarykey;
        responseBatchUpdate.replace('a5532858-dbdc-4d3c-9eaf-3d71d097ceb0', pk);

        assert.equal(realCountArr(leafletObject.models), 3);
        assert.equal(leafletObject.getLayers().length, 2);

        var mapModel = store.createRecord('new-platform-flexberry-g-i-s-map');
        var stubGetmapApi = _sinon['default'].stub(component.get('mapApi'), 'getFromApi');
        stubGetmapApi.returns(mapModel);

        var _getModelLayerFeatureStub = _sinon['default'].stub(mapModel, '_getModelLayerFeature');
        _getModelLayerFeatureStub.returns(_ember['default'].RSVP.resolve([null, null, [layerAdd]]));

        var saveSuccess = function saveSuccess(data) {
          assert.equal(_getModelLayerFeatureStub.callCount, 1);
          assert.deepEqual(_getModelLayerFeatureStub.getCall(0).args[1], [pk]);
          assert.equal(data.layers.length, 1);
          assert.equal(realCountArr(leafletObject.models), 0);
          assert.equal(leafletObject.getLayers().length, 1);
          assert.equal(leafletObject.getLayers()[0].state, 'exist');
          done();

          spyBatchUpdate.restore();
          stubGetmapApi.restore();
          _getModelLayerFeatureStub.restore();
        };

        leafletObject.once('save:success', saveSuccess);
        component.save();

        assert.equal(spyBatchUpdate.callCount, 1);
      });
    });
  });

  (0, _emberQunit.test)('test method createModelHierarchy() with 3 parent', function (assert) {
    assert.expect(11);
    var done = assert.async(1);
    _ember['default'].$.extend(param, {
      'odataUrl': 'http://localhost:6500/odata/',
      'namespace': 'ns',
      'metadataUrl': 'assert/felxberry/models/'
    });

    var component = this.subject(param);

    jsonModel.parentModelName = 'parent1';
    var parent1JsonModel = {
      name: 'parent1',
      parentModelName: 'parent2',
      modelName: 'parent1',
      className: 'parent1',
      nameSpace: 'NS1',
      attrs: [{
        name: 'name',
        type: 'string',
        flexberryType: 'Строка250',
        notNull: false,
        defaultValue: '',
        stored: true,
        ordered: false
      }],
      belongsTo: [],
      hasMany: [],
      projections: [],
      stored: false,
      offline: true,
      external: false
    };

    var parent2JsonModel = {
      name: 'parent2',
      parentModelName: 'parent3',
      modelName: 'parent2',
      className: 'parent2',
      nameSpace: 'NS2',
      attrs: [{
        name: 'name2',
        type: 'string',
        flexberryType: 'Строка250',
        notNull: false,
        defaultValue: '',
        stored: true,
        ordered: false
      }],
      belongsTo: [],
      hasMany: [],
      projections: [],
      stored: false,
      offline: true,
      external: false
    };

    var parent3JsonModel = {
      name: 'parent3',
      parentModelName: null,
      modelName: 'parent3',
      className: 'parent3',
      nameSpace: 'NS3',
      attrs: [{
        name: 'name3',
        type: 'string',
        flexberryType: 'Строка250',
        notNull: false,
        defaultValue: '',
        stored: true,
        ordered: false
      }],
      belongsTo: [],
      hasMany: [],
      projections: [],
      stored: false,
      offline: true,
      external: false
    };
    var stubAjax = _sinon['default'].stub(_ember['default'].$, 'ajax');
    stubAjax.onCall(0).yieldsTo('success', jsonModel).onCall(1).yieldsTo('success', parent1JsonModel).onCall(2).yieldsTo('success', parent2JsonModel).onCall(3).yieldsTo('success', parent3JsonModel);

    var spyCreateModel = _sinon['default'].spy(component, 'createModel');
    var spyCreateMixin = _sinon['default'].spy(component, 'createMixin');
    var spyCreateModelHierarchy = _sinon['default'].spy(component, 'сreateModelHierarchy');

    component.сreateModelHierarchy(param.metadataUrl, param.modelName).then(function (_ref) {
      var model = _ref.model;
      var dataModel = _ref.dataModel;
      var modelMixin = _ref.modelMixin;

      assert.equal(stubAjax.callCount, 4);
      assert.equal(spyCreateModel.callCount, 1);
      assert.equal(spyCreateMixin.callCount, 4);
      assert.equal(spyCreateModelHierarchy.callCount, 4);
      assert.equal(spyCreateModelHierarchy.getCall(0).args[1], 'test-model');
      assert.equal(spyCreateModelHierarchy.getCall(1).args[1], 'parent1');
      assert.equal(spyCreateModelHierarchy.getCall(2).args[1], 'parent2');
      assert.equal(spyCreateModelHierarchy.getCall(3).args[1], 'parent3');
      assert.ok(model);
      assert.ok(dataModel);
      assert.ok(modelMixin);
      done();
      stubAjax.restore();
      spyCreateModel.restore();
      spyCreateMixin.restore();
      spyCreateModelHierarchy.restore();
    });
  });

  (0, _emberQunit.test)('test method clearLayers()', function (assert) {
    assert.expect(4);
    var done = assert.async(1);
    var component = this.subject(param);

    component.get('_leafletLayerPromise').then(function (leafletLayer) {
      component.set('_leafletObject', leafletLayer);
      leafletLayer.promiseLoadLayer.then(function () {
        var leafletObject = component.get('_leafletObject');

        assert.equal(realCountArr(leafletObject.models), 0);
        assert.equal(leafletObject.getLayers().length, 2);
        leafletObject.clearLayers();
        assert.equal(realCountArr(leafletObject.models), 0);
        assert.equal(leafletObject.getLayers().length, 0);
        done();
      });
    });
  });
});
define('dummy/tests/unit/components/layers/odata-vector-layer-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/components/layers');
  test('unit/components/layers/odata-vector-layer-test.js should pass jscs', function () {
    ok(true, 'unit/components/layers/odata-vector-layer-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/components/layers/odata-vector-layer-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/components/layers/odata-vector-layer-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/components/layers/odata-vector-layer-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/components/layers/tile-layer-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForComponent)('layers/tile-layer', 'Unit | Component | layers/tile layer', {
    unit: true
  });

  (0, _emberQunit.test)('it return L.TileLayer on createLayer', function (assert) {
    var component = this.subject({
      requiredOptions: ['']
    });
    var layer = component.createLayer();
    assert.ok(layer instanceof L.TileLayer, 'Expected L.TileLayer instance');
  });
});
define('dummy/tests/unit/components/layers/tile-layer-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/components/layers');
  test('unit/components/layers/tile-layer-test.js should pass jscs', function () {
    ok(true, 'unit/components/layers/tile-layer-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/components/layers/tile-layer-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/components/layers/tile-layer-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/components/layers/tile-layer-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/components/layers/wfs-layer-test', ['exports', 'ember', 'ember-qunit', 'sinon', 'dummy/tests/helpers/start-app'], function (exports, _ember, _emberQunit, _sinon, _dummyTestsHelpersStartApp) {

  var app = undefined;
  var geoserverFake = undefined;
  var options = undefined;
  var param = undefined;

  (0, _emberQunit.moduleForComponent)('layers/wfs-layer', 'Unit | Component | layers/wfs layer', {
    unit: true,
    needs: ['service:map-api', 'config:environment', 'component:base-vector-layer', 'model:new-platform-flexberry-g-i-s-map'],
    beforeEach: function beforeEach() {
      app = (0, _dummyTestsHelpersStartApp['default'])();

      options = {
        url: 'http://geoserverFake/geoserver/ows',
        geometryField: 'shape',
        showExisting: false,
        withCredentials: false,
        crs: L.CRS.EPSG3857,
        typeNSName: 'rgisperm',
        filter: null,
        version: '1.1.0',
        continueLoading: true
      };

      var leafletOptions = ['url', 'version', 'namespaceUri', 'typeNS', 'typeName', 'typeNSName', 'geometryField', 'crs', 'maxFeatures', 'showExisting', 'style', 'filter', 'forceMulti', 'withCredentials', 'continueLoading'];

      param = {
        format: 'GeoJSON',
        leafletOptions: leafletOptions
      };
      param = _ember['default'].$.extend(param, options);

      geoserverFake = _sinon['default'].fakeServer.create();
      geoserverFake.autoRespond = true;

      geoserverFake.respondWith('POST', 'http://geoserverFake/geoserver/ows?', function (request) {
        if (request.requestBody === '<wfs:GetFeature xmlns:wfs="http://www.opengis.net/wfs" service="WFS" version="1.1.0" outputFormat="application/json">' + '<wfs:Query typeName="les:povorottochkipoint32640" srsName="EPSG:3857"><ogc:Filter xmlns:ogc="http://www.opengis.net/ogc"><Not><Or>' + '<ogc:PropertyIsEqualTo matchCase="false"><ogc:PropertyName>primarykey</ogc:PropertyName><ogc:Literal>475adc5b-fee4-4e8c-bed0-93746a9f00f0' + '</ogc:Literal></ogc:PropertyIsEqualTo></Or></Not></ogc:Filter></wfs:Query></wfs:GetFeature>') {
          request.respond(200, { 'Content-Type': 'application/json' }, '{"type":"FeatureCollection","features":[],"totalFeatures":0,"numberMatched":0,"numberReturned":0,"timeStamp":"2020-02-27T04:44:49.909Z",' + '"crs":null}');
        }

        if (request.requestBody.indexOf('<wfs:GetFeature') !== -1) {
          request.respond(200, { 'Content-Type': 'application/json' }, '{"type":"FeatureCollection","features":[{"type":"Feature","id":"vydel_utverzhdeno_polygon.06350c71-ec5c-431e-a5ab-e423cf662128",' + '"geometry":{"type":"MultiPolygon","coordinates":[[[[6215353.89391635,8117916.10977998],[6215317.82640125,8117408.36954415],' + '[6215322.83577823,8116959.81224657],[6213934.34777038,8117228.98625252],[6213930.67422719,8117229.84351009],' + '[6214007.26203691,8117650.34021493],[6214045.44462228,8117860.38311881],[6214113.79478966,8118235.47443556],' + '[6214237.35942438,8118229.9015124],[6214247.82345653,8118288.63175866],[6215053.10865244,8118087.57903733],' + '[6215031.95794919,8118033.35145873],[6215042.3106618,8117957.47637766],[6215353.89391635,8117916.10977998]]]]},' + '"geometry_name":"shape","properties":' + '{"id":"000","lesnichestvo":"-","uchastkovoelesnichestvo":"-","nomerkvartala":"141","urochishe":null,"nomer":10,"ploshad":200,"kategoriyazemel":' + '"Эксплуатационные леса","preobladayushayaporoda":"Сосна","bonitet":"2","gruppavozrasta":"Молодняки I гр.","klassvozrasta":"1","klasstovarnosti":' + 'null,"area":373798.7024302,"length":null,"primarykey":"06350c71-ec5c-431e-a5ab-e423cf662128","createtime":null,"creator":null,' + '"edittime":null,"editor":null}}],"totalFeatures":1,"numberMatched":1,"numberReturned":1,"timeStamp":"2020-02-27T04:44:49.909Z",' + '"crs":{"type":"name","properties":{"name":"urn:ogc:def:crs:EPSG::3857"}}}');
        }

        if (request.requestBody.indexOf('<wfs:DescribeFeatureType') !== -1) {
          request.respond(200, { 'Content-Type': 'text/plain;charset=utf-8' }, '<?xml version="1.0" encoding="UTF-8"?><xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:gml="http://www.opengis.net/gml" ' + 'xmlns:rgisperm="http://rgis.permkrai.ru" elementFormDefault="qualified" targetNamespace="http://rgis.permkrai.ru">' + '<xsd:import namespace="http://www.opengis.net/gml" schemaLocation="http://rgispk.wdepo.ru:80/geoserver/schemas/gml/3.1.1/base/gml.xsd"/>' + '<xsd:complexType name="vydel_utverzhdeno_polygonType">' + '<xsd:complexContent>' + '<xsd:extension base="gml:AbstractFeatureType">' + '<xsd:sequence>' + '<xsd:element maxOccurs="1" minOccurs="1" name="primarykey" nillable="false" type="xsd:string"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="shape" nillable="true" type="gml:MultiSurfacePropertyType"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="id" nillable="true" type="xsd:string"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="lesnichestvo" nillable="true" type="xsd:string"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="uchastkovoelesnichestvo" nillable="true" type="xsd:string"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="nomerkvartala" nillable="true" type="xsd:string"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="urochishe" nillable="true" type="xsd:string"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="nomer" nillable="true" type="xsd:int"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="ploshad" nillable="true" type="xsd:decimal"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="kategoriyazemel" nillable="true" type="xsd:string"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="preobladayushayaporoda" nillable="true" type="xsd:string"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="bonitet" nillable="true" type="xsd:string"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="gruppavozrasta" nillable="true" type="xsd:string"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="klassvozrasta" nillable="true" type="xsd:int"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="klasstovarnosti" nillable="true" type="xsd:int"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="area" nillable="true" type="xsd:decimal"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="length" nillable="true" type="xsd:decimal"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="createtime" nillable="true" type="xsd:dateTime"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="creator" nillable="true" type="xsd:string"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="edittime" nillable="true" type="xsd:dateTime"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="editor" nillable="true" type="xsd:string"/>' + '<xsd:element maxOccurs="1" minOccurs="0" name="kl" nillable="true" type="xsd:string"/>' + '</xsd:sequence>' + '</xsd:extension>' + '</xsd:complexContent>' + '</xsd:complexType>' + '<xsd:element name="vydel_utverzhdeno_polygon" substitutionGroup="gml:_Feature" type="rgisperm:vydel_utverzhdeno_polygonType"/>' + '</xsd:schema>');
        }
      });
    },
    afterEach: function afterEach() {
      _ember['default'].run(app, 'destroy');
      geoserverFake.restore();
    }
  });

  (0, _emberQunit.test)('getLayerFeatures() with options showExisting = false and continueLoading = true', function (assert) {
    var _this = this;

    assert.expect(2);
    var done = assert.async(2);
    _ember['default'].run(function () {
      var component = _this.subject(param);

      var store = app.__container__.lookup('service:store');
      var mapModel = store.createRecord('new-platform-flexberry-g-i-s-map');
      var getmapApiStub = _sinon['default'].stub(component.get('mapApi'), 'getFromApi');
      getmapApiStub.returns(mapModel);

      var getPkFieldStub = _sinon['default'].stub(mapModel, '_getPkField');
      getPkFieldStub.returns('primarykey');

      L.wfst(options, component.getFeaturesReadFormat()).once('load', function (res) {
        var e = {
          featureIds: ['06350c71-ec5c-431e-a5ab-e423cf662128'],
          layer: 'f34ea73d-9f00-4f02-b02d-675d459c972b',
          results: _ember['default'].A()
        };
        component._leafletObject = res.target;

        component.getLayerFeatures(e).then(function (layers) {
          assert.ok(layers, 'Get feature of layers with showExisting = false and continueLoading = true');
          done();
        });
      });

      assert.ok(component, 'Create wfs-layer with showExisting = false');
      done();
    });
  });

  (0, _emberQunit.test)('getLayerFeatures() with options showExisting = true', function (assert) {
    var _this2 = this;

    assert.expect(2);
    var done = assert.async(2);
    _ember['default'].run(function () {
      param.showExisting = true;

      var component = _this2.subject(param);

      var store = app.__container__.lookup('service:store');
      var mapModel = store.createRecord('new-platform-flexberry-g-i-s-map');
      var getmapApiStub = _sinon['default'].stub(component.get('mapApi'), 'getFromApi');
      getmapApiStub.returns(mapModel);

      var getLayerFeatureIdStub = _sinon['default'].stub(mapModel, '_getLayerFeatureId');
      getLayerFeatureIdStub.returns('06350c71-ec5c-431e-a5ab-e423cf662128');

      options.showExisting = true;
      L.wfst(options, component.getFeaturesReadFormat()).once('load', function (res) {
        var e = {
          featureIds: ['06350c71-ec5c-431e-a5ab-e423cf662128'],
          layer: 'f34ea73d-9f00-4f02-b02d-675d459c972b',
          results: _ember['default'].A()
        };

        component._leafletObject = res.target;

        component.getLayerFeatures(e).then(function (layers) {
          assert.ok(layers, 'Get feature of layers with showExisting = true');
          done();
        });
      });

      assert.ok(component, 'Create wfs-layer with showExisting = true');
      done();
    });
  });

  (0, _emberQunit.test)('loadLayerFeatures() with options showExisting = false', function (assert) {
    var _this3 = this;

    assert.expect(2);
    var done = assert.async(2);
    _ember['default'].run(function () {
      var component = _this3.subject(param);

      var store = app.__container__.lookup('service:store');
      var mapModel = store.createRecord('new-platform-flexberry-g-i-s-map');
      var getmapApiStub = _sinon['default'].stub(component.get('mapApi'), 'getFromApi');
      getmapApiStub.returns(mapModel);

      var getPkFieldStub = _sinon['default'].stub(mapModel, '_getPkField');
      getPkFieldStub.returns('primarykey');

      L.wfst(options, component.getFeaturesReadFormat()).once('load', function (res) {
        var e = {
          featureIds: ['06350c71-ec5c-431e-a5ab-e423cf662128'],
          layer: 'f34ea73d-9f00-4f02-b02d-675d459c972b',
          results: _ember['default'].A()
        };
        component._leafletObject = res.target;

        component.loadLayerFeatures(e).then(function (layers) {
          assert.ok(layers, 'Load feature of layers with showExisting = false');
          done();
        });
      });

      assert.ok(component, 'Create wfs-layer with showExisting = false');
      done();
    });
  });

  (0, _emberQunit.test)('loadLayerFeatures() with options showExisting = true', function (assert) {
    var _this4 = this;

    assert.expect(2);
    var done = assert.async(2);
    _ember['default'].run(function () {
      param.showExisting = true;

      var component = _this4.subject(param);

      var store = app.__container__.lookup('service:store');
      var mapModel = store.createRecord('new-platform-flexberry-g-i-s-map');
      var getmapApiStub = _sinon['default'].stub(component.get('mapApi'), 'getFromApi');
      getmapApiStub.returns(mapModel);

      var getPkFieldStub = _sinon['default'].stub(mapModel, '_getPkField');
      getPkFieldStub.returns('primarykey');

      options.showExisting = true;
      L.wfst(options, component.getFeaturesReadFormat()).once('load', function (res) {
        var e = {
          featureIds: ['06350c71-ec5c-431e-a5ab-e423cf662128'],
          layer: 'f34ea73d-9f00-4f02-b02d-675d459c972b',
          results: _ember['default'].A()
        };

        component._leafletObject = res.target;

        component.loadLayerFeatures(e).then(function (layers) {
          assert.ok(layers, 'Load feature of layers with showExisting = true');
          done();
        });
      });

      assert.ok(component, 'Create wfs-layer with showExisting = true');
      done();
    });
  });

  (0, _emberQunit.test)('loadLayerFeatures() with options showExisting = false, call 2 times', function (assert) {
    var _this5 = this;

    assert.expect(3);
    var done = assert.async(3);
    _ember['default'].run(function () {
      param.continueLoading = false;
      var component = _this5.subject(param);

      var store = app.__container__.lookup('service:store');
      var mapModel = store.createRecord('new-platform-flexberry-g-i-s-map');
      var getmapApiStub = _sinon['default'].stub(component.get('mapApi'), 'getFromApi');
      getmapApiStub.returns(mapModel);

      var getPkFieldStub = _sinon['default'].stub(mapModel, '_getPkField');
      getPkFieldStub.returns('primarykey');

      options.continueLoading = false;
      L.wfst(options, component.getFeaturesReadFormat()).once('load', function (res) {
        var e = {
          featureIds: null,
          layer: 'f34ea73d-9f00-4f02-b02d-675d459c972b',
          results: _ember['default'].A()
        };
        component._leafletObject = res.target;

        component.loadLayerFeatures(e).then(function (layers) {
          assert.equal(layers.getLayers().length, 1, 'Load feature of layers with showExisting = false, 1 times');
          done();
          component.loadLayerFeatures(e).then(function (layers) {
            assert.equal(layers.getLayers().length, 1, 'Load feature of layers with showExisting = false, 2 times');
            done();
          });
        });
      });

      assert.ok(component, 'Create wfs-layer with showExisting = false');
      done();
    });
  });
});
define('dummy/tests/unit/components/layers/wfs-layer-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/components/layers');
  test('unit/components/layers/wfs-layer-test.js should pass jscs', function () {
    ok(true, 'unit/components/layers/wfs-layer-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/components/layers/wfs-layer-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/components/layers/wfs-layer-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/components/layers/wfs-layer-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/components/layers/wms-layer-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForComponent)('layers/wms-layer', 'Unit | Component | layers/wms layer', {
    unit: true
  });

  (0, _emberQunit.test)('it return L.TileLayer.wms on createLayer', function (assert) {
    var component = this.subject({
      requiredOptions: ['']
    });
    var layer = component.createLayer();
    assert.ok(layer instanceof L.TileLayer.WMS, 'Expected L.TileLayer.wms instance');
  });
});
define('dummy/tests/unit/components/layers/wms-layer-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/components/layers');
  test('unit/components/layers/wms-layer-test.js should pass jscs', function () {
    ok(true, 'unit/components/layers/wms-layer-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/components/layers/wms-layer-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/components/layers/wms-layer-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/components/layers/wms-layer-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/components/minimap-control-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForComponent)('minimap-control', 'Unit | Component | minimap control', {
    unit: true
  });

  (0, _emberQunit.test)('it should return L.Control.MiniMap from createControl', function (assert) {
    var component = this.subject();

    // Renders the component to the page.
    var control = component.createControl();

    assert.ok(control instanceof L.Control.MiniMap);
  });

  (0, _emberQunit.test)('it should return L.LayerGroup from layerGroup', function (assert) {
    var component = this.subject();

    var lGroup = component.get('layerGroup');

    assert.ok(lGroup instanceof L.LayerGroup);
  });
});
define('dummy/tests/unit/components/minimap-control-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/components');
  test('unit/components/minimap-control-test.js should pass jscs', function () {
    ok(true, 'unit/components/minimap-control-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/components/minimap-control-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/components/minimap-control-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/components/minimap-control-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/components/scale-control-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForComponent)('scale-control', 'Unit | Component | scale control', {
    // Specify the other units that are required for this test
    // needs: ['component:foo', 'helper:bar'],
    unit: true
  });

  (0, _emberQunit.test)('it should return L.Control.Scale from createControl', function (assert) {
    var component = this.subject();

    // Renders the component to the page.
    var control = component.createControl();

    assert.ok(control instanceof L.Control.Scale);
  });
});
define('dummy/tests/unit/components/scale-control-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/components');
  test('unit/components/scale-control-test.js should pass jscs', function () {
    ok(true, 'unit/components/scale-control-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/components/scale-control-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/components/scale-control-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/components/scale-control-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/components/switch-scale-control-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForComponent)('switch-scale-control', 'Unit | Component | switch scale control', {
    unit: true
  });

  (0, _emberQunit.test)('it should return L.Control.SwitchScaleControl from createControl', function (assert) {
    var component = this.subject();

    // Renders the component to the page.
    var control = component.createControl();

    assert.ok(control instanceof L.Control.SwitchScaleControl);
  });
});
define('dummy/tests/unit/components/switch-scale-control-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/components');
  test('unit/components/switch-scale-control-test.js should pass jscs', function () {
    ok(true, 'unit/components/switch-scale-control-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/components/switch-scale-control-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/components/switch-scale-control-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/components/switch-scale-control-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/components/zoomslider-control-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForComponent)('zoomslider-control', 'Unit | Component | zoomslider control', {
    unit: true
  });

  (0, _emberQunit.test)('it should return L.Control.Zoomslider from createControl', function (assert) {
    var component = this.subject();

    // Renders the component to the page.
    var control = component.createControl();

    assert.ok(control instanceof L.Control.Zoomslider);
  });
});
define('dummy/tests/unit/components/zoomslider-control-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/components');
  test('unit/components/zoomslider-control-test.js should pass jscs', function () {
    ok(true, 'unit/components/zoomslider-control-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/components/zoomslider-control-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/components/zoomslider-control-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/components/zoomslider-control-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/controllers/edit-map-test', ['exports', 'ember-flexberry-gis/controllers/edit-map', 'qunit'], function (exports, _emberFlexberryGisControllersEditMap, _qunit) {

  (0, _qunit.module)('Unit | Controller | edit-map');

  (0, _qunit.test)('it exists', function (assert) {
    var route = _emberFlexberryGisControllersEditMap['default'].create({});
    assert.ok(route);
  });
});
define('dummy/tests/unit/controllers/edit-map-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/controllers');
  test('unit/controllers/edit-map-test.js should pass jscs', function () {
    ok(true, 'unit/controllers/edit-map-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/controllers/edit-map-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/controllers/edit-map-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/controllers/edit-map-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/controllers/gis-search-form-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleFor)('controller:gis-search-form', 'Unit | Controller | gis search form', {
    // Specify the other units that are required for this test.
    // needs: ['controller:foo']
  });

  // Replace this with your real tests.
  (0, _emberQunit.test)('it exists', function (assert) {
    var controller = this.subject();
    assert.ok(controller);
  });
});
define('dummy/tests/unit/controllers/gis-search-form-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/controllers');
  test('unit/controllers/gis-search-form-test.js should pass jscs', function () {
    ok(true, 'unit/controllers/gis-search-form-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/controllers/gis-search-form-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/controllers/gis-search-form-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/controllers/gis-search-form-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/controllers/list-map-test', ['exports', 'ember-flexberry-gis/controllers/list-map', 'qunit'], function (exports, _emberFlexberryGisControllersListMap, _qunit) {

  (0, _qunit.module)('Unit | Controller | list-map');

  (0, _qunit.test)('it exists', function (assert) {
    var route = _emberFlexberryGisControllersListMap['default'].create({});
    assert.ok(route);
  });
});
define('dummy/tests/unit/controllers/list-map-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/controllers');
  test('unit/controllers/list-map-test.js should pass jscs', function () {
    ok(true, 'unit/controllers/list-map-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/controllers/list-map-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/controllers/list-map-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/controllers/list-map-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/helpers/flexberry-search-properties-osm-ru-test', ['exports', 'dummy/helpers/flexberry-search-properties-osm-ru', 'qunit'], function (exports, _dummyHelpersFlexberrySearchPropertiesOsmRu, _qunit) {

  (0, _qunit.module)('Unit | Helper | flexberry search properties osm ru');

  // Replace this with your real tests.
  (0, _qunit.test)('it works', function (assert) {
    var result = (0, _dummyHelpersFlexberrySearchPropertiesOsmRu.flexberrySearchPropertiesOsmRu)([42]);
    assert.ok(result);
  });
});
define('dummy/tests/unit/helpers/flexberry-search-properties-osm-ru-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/helpers');
  test('unit/helpers/flexberry-search-properties-osm-ru-test.js should pass jscs', function () {
    ok(true, 'unit/helpers/flexberry-search-properties-osm-ru-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/helpers/flexberry-search-properties-osm-ru-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/helpers/flexberry-search-properties-osm-ru-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/helpers/flexberry-search-properties-osm-ru-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/helpers/instance-of-test', ['exports', 'dummy/helpers/instance-of', 'qunit'], function (exports, _dummyHelpersInstanceOf, _qunit) {

  (0, _qunit.module)('Unit | Helper | instance of');

  (0, _qunit.test)('it works', function (assert) {
    assert.expect(2);
    var obj = L.layerGroup();
    var constructor = L.LayerGroup;
    var result = (0, _dummyHelpersInstanceOf.instanceOf)([obj, constructor]);
    assert.ok(result);

    constructor = L.Control.MiniMap;
    result = (0, _dummyHelpersInstanceOf.instanceOf)([obj, constructor]);
    assert.notOk(result);
  });
});
define('dummy/tests/unit/helpers/instance-of-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/helpers');
  test('unit/helpers/instance-of-test.js should pass jscs', function () {
    ok(true, 'unit/helpers/instance-of-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/helpers/instance-of-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/helpers/instance-of-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/helpers/instance-of-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/initializers/flexberry-map-commands-test', ['exports', 'ember', 'dummy/initializers/map-commands', 'qunit'], function (exports, _ember, _dummyInitializersMapCommands, _qunit) {

  var application = undefined;

  (0, _qunit.module)('Unit | Initializer | map-commands', {
    beforeEach: function beforeEach() {
      _ember['default'].run(function () {
        application = _ember['default'].Application.create();
        application.deferReadiness();
      });
    }
  });

  // Replace this with your real tests.
  (0, _qunit.test)('it works', function (assert) {
    _dummyInitializersMapCommands['default'].initialize(application);

    // you would normally confirm the results of the initializer here
    assert.ok(true);
  });
});
define('dummy/tests/unit/initializers/flexberry-map-commands-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/initializers');
  test('unit/initializers/flexberry-map-commands-test.js should pass jscs', function () {
    ok(true, 'unit/initializers/flexberry-map-commands-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/initializers/flexberry-map-commands-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/initializers/flexberry-map-commands-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/initializers/flexberry-map-commands-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/initializers/flexberry-map-tools-test', ['exports', 'ember', 'dummy/initializers/map-tools', 'qunit'], function (exports, _ember, _dummyInitializersMapTools, _qunit) {

  var application = undefined;

  (0, _qunit.module)('Unit | Initializer | map-tools', {
    beforeEach: function beforeEach() {
      _ember['default'].run(function () {
        application = _ember['default'].Application.create();
        application.deferReadiness();
      });
    }
  });

  // Replace this with your real tests.
  (0, _qunit.test)('it works', function (assert) {
    _dummyInitializersMapTools['default'].initialize(application);

    // you would normally confirm the results of the initializer here
    assert.ok(true);
  });
});
define('dummy/tests/unit/initializers/flexberry-map-tools-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/initializers');
  test('unit/initializers/flexberry-map-tools-test.js should pass jscs', function () {
    ok(true, 'unit/initializers/flexberry-map-tools-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/initializers/flexberry-map-tools-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/initializers/flexberry-map-tools-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/initializers/flexberry-map-tools-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/initializers/local-storage-test', ['exports', 'ember', 'ember-flexberry-gis/initializers/local-storage', 'qunit'], function (exports, _ember, _emberFlexberryGisInitializersLocalStorage, _qunit) {

  var application = undefined;

  (0, _qunit.module)('Unit | Initializer | local storage', {
    beforeEach: function beforeEach() {
      _ember['default'].run(function () {
        application = _ember['default'].Application.create();
        application.deferReadiness();
      });
    }
  });

  // Replace this with your real tests.
  (0, _qunit.test)('it works', function (assert) {
    _emberFlexberryGisInitializersLocalStorage['default'].initialize(application);

    // you would normally confirm the results of the initializer here
    assert.ok(true);
  });
});
define('dummy/tests/unit/initializers/local-storage-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/initializers');
  test('unit/initializers/local-storage-test.js should pass jscs', function () {
    ok(true, 'unit/initializers/local-storage-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/initializers/local-storage-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/initializers/local-storage-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/initializers/local-storage-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/instance-initializers/open-map-test', ['exports', 'ember', 'dummy/instance-initializers/open-map', 'qunit', 'dummy/tests/helpers/destroy-app', 'ember-flexberry-gis/services/map-api', 'ember-flexberry-gis/services/map-store', 'sinon'], function (exports, _ember, _dummyInstanceInitializersOpenMap, _qunit, _dummyTestsHelpersDestroyApp, _emberFlexberryGisServicesMapApi, _emberFlexberryGisServicesMapStore, _sinon) {

  (0, _qunit.module)('Unit | Instance Initializer | open map', {
    beforeEach: function beforeEach() {
      var _this = this;

      _ember['default'].run(function () {
        _this.application = _ember['default'].Application.create();
        _this.application.register('service:map-api', _emberFlexberryGisServicesMapApi['default']);
        var objStore = _ember['default'].Service.extend({
          createRecord: function createRecord() {
            return {
              get: function get() {
                return { pushObject: function pushObject() {} };
              }
            };
          }
        });
        _this.application.register('service:store', objStore);
        _this.application.register('service:map-store', _emberFlexberryGisServicesMapStore['default']);
        _this.appInstance = _this.application.buildInstance();
      });
    },
    afterEach: function afterEach() {
      _ember['default'].run(this.appInstance, 'destroy');
      (0, _dummyTestsHelpersDestroyApp['default'])(this.application);
    }
  });

  (0, _qunit.test)('map api added function Open Map', function (assert) {
    //Arrange
    var configStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    configStub.returns({
      _lookupFactory: function _lookupFactory() {
        return {
          'APP': {
            'mapApiService': true
          }
        };
      }
    });

    //Action
    (0, _dummyInstanceInitializersOpenMap.initialize)(this.appInstance);
    var openMap = this.appInstance.lookup('service:map-api').getFromApi('openMap');

    //Assert
    assert.ok(typeof openMap === 'function');
    assert.ok(true);
    configStub.restore();
  });

  (0, _qunit.test)('Test for function Open Map', function (assert) {
    //Arrange
    var done = assert.async(1);
    var configStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    configStub.returns({
      _lookupFactory: function _lookupFactory() {
        return {
          'APP': {
            'mapApiService': true
          }
        };
      }
    });
    (0, _dummyInstanceInitializersOpenMap.initialize)(this.appInstance);
    var openMap = this.appInstance.lookup('service:map-api').getFromApi('openMap');
    var mapStoreStub = _sinon['default'].stub(this.appInstance.lookup('service:map-store'), 'getMapById');
    var routerStub = _sinon['default'].stub(this.appInstance.lookup('router:main'), 'transitionTo');
    mapStoreStub.returns(_ember['default'].RSVP.resolve({}));
    routerStub.returns(true);

    //Action
    var res = openMap('d3434', { test: true });

    //Assert
    assert.ok(res instanceof _ember['default'].RSVP.Promise);
    res.then(function () {
      assert.equal(mapStoreStub.callCount, 1);
      assert.equal(routerStub.callCount, 1);
      assert.equal(mapStoreStub.args[0][0], 'd3434');
      assert.deepEqual(routerStub.args[0][2], { queryParams: { test: true } });
      done();
      mapStoreStub.restore();
      routerStub.restore();
    });
    configStub.restore();
  });
});
define('dummy/tests/unit/instance-initializers/open-map-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/instance-initializers');
  test('unit/instance-initializers/open-map-test.js should pass jscs', function () {
    ok(true, 'unit/instance-initializers/open-map-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/instance-initializers/open-map-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/instance-initializers/open-map-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/instance-initializers/open-map-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/dynamic-properties-test', ['exports', 'ember', 'ember-flexberry-gis/mixins/dynamic-properties', 'qunit'], function (exports, _ember, _emberFlexberryGisMixinsDynamicProperties, _qunit) {

  var ClassWithDynamicPropertiesMixin = _ember['default'].Object.extend(_emberFlexberryGisMixinsDynamicProperties['default'], {});

  (0, _qunit.module)('Unit | Mixin | dynamic-properties mixin');

  (0, _qunit.test)('Mixin throws assertion failed exception if specified \'dynamicProperties\' property is not an \'object\' or an \'instance\'', function (assert) {
    var wrongDynamicPropertiesArray = _ember['default'].A([1, true, false, 'some string', [], function () {}, new Date(), new RegExp()]);

    assert.expect(wrongDynamicPropertiesArray.length);

    wrongDynamicPropertiesArray.forEach(function (wrongDynamicProperties) {
      try {
        ClassWithDynamicPropertiesMixin.create({ dynamicProperties: wrongDynamicProperties });
      } catch (ex) {
        assert.strictEqual(/wrong\s*type\s*of\s*.*dynamicProperties.*/gi.test(ex.message), true, 'Throws assertion failed exception if specified \'dynamicProperties\' property is \'' + _ember['default'].typeOf(wrongDynamicProperties) + '\'');
      }
    });
  });

  (0, _qunit.test)('Mixin assignes it\'s owner\'s properties form the specified \'dynamicProperties\'', function (assert) {
    assert.expect(1);

    var propertyValue = 'MyValue';
    var dynamicProperties = { property: propertyValue };
    var mixinOwner = ClassWithDynamicPropertiesMixin.create({ dynamicProperties: dynamicProperties });

    assert.strictEqual(mixinOwner.get('property'), propertyValue, 'Owner\'s properties are equals to related \'dynamicProperties\'');
  });

  (0, _qunit.test)('Mixin changes it\'s owner\'s properties (when something changes inside related \'dynamicProperties\')', function (assert) {
    assert.expect(2);

    var propertyValue = 'MyValue';
    var dynamicProperties = { property: propertyValue };
    var mixinOwner = ClassWithDynamicPropertiesMixin.create({ dynamicProperties: dynamicProperties });

    assert.strictEqual(mixinOwner.get('property'), propertyValue, 'Owner\'s properties are equals to related \'dynamicProperties\'');

    var propertyChangedValue = 'MyChangedValue';
    _ember['default'].set(dynamicProperties, 'property', propertyChangedValue);

    assert.strictEqual(mixinOwner.get('property'), propertyChangedValue, 'Owner\'s properties changes when values inside \'dynamicProperties\' changes');
  });

  (0, _qunit.test)('Mixin removes old & adds new owner\'s properties (when reference to whole \'dynamicProperties\' object changes)', function (assert) {
    assert.expect(22);

    var propertyValue = 'MyProperty';
    var anotherPropertyValue = 'MyAnotherProperty';
    var dynamicProperties = { property: propertyValue, anotherProperty: anotherPropertyValue };

    var usualPropertyValue = 'MyUsualProperty';

    var mixinOwner = ClassWithDynamicPropertiesMixin.create({
      usualProperty: usualPropertyValue,
      dynamicProperties: dynamicProperties
    });

    assert.strictEqual(mixinOwner.get('usualProperty'), usualPropertyValue, 'Owner\'s \'usualProperty\' is equals to it\'s initially defined value');
    assert.strictEqual(mixinOwner.get('property'), propertyValue, 'Owner\'s \'property\' is equals to related dynamicProperty');
    assert.strictEqual(mixinOwner.get('anotherProperty'), anotherPropertyValue, 'Owner\'s \'anotherProperty\' is equals to related dynamicProperty');

    var ownerPropertiesNames = _ember['default'].A(Object.keys(mixinOwner));
    assert.strictEqual(ownerPropertiesNames.contains('usualProperty'), true, 'Owner\'s properties keys contains \'usualProperty\'');
    assert.strictEqual(ownerPropertiesNames.contains('property'), true, 'Owner\'s properties keys contains \'property\'');
    assert.strictEqual(ownerPropertiesNames.contains('anotherProperty'), true, 'Owner\'s properties keys contains \'anotherProperty\'');

    var newPropertyValue = 'MyNewProperty';
    var newAnotherPropertyValue = 'MyNewAnotherProperty';
    var newDynamicProperties = { newProperty: newPropertyValue, newAnotherProperty: newAnotherPropertyValue };
    mixinOwner.set('dynamicProperties', newDynamicProperties);

    assert.strictEqual(mixinOwner.get('usualProperty'), usualPropertyValue, 'Owner\'s \'usualProperty\' is equals to it\'s initially defined value (after change of whole \'dynamicProperties\' object)');
    assert.strictEqual(_ember['default'].typeOf(mixinOwner.get('property')), 'undefined', 'Owner\'s \'property\' is undefined (after change of whole \'dynamicProperties\' object)');
    assert.strictEqual(_ember['default'].typeOf(mixinOwner.get('anotherProperty')), 'undefined', 'Owner\'s \'anotherProperty\' is undefined (after change of whole \'dynamicProperties\' object)');
    assert.strictEqual(mixinOwner.get('newProperty'), newPropertyValue, 'Owner\'s \'newProperty\' is equals to related dynamicProperty (after change of whole \'dynamicProperties\' object)');
    assert.strictEqual(mixinOwner.get('newAnotherProperty'), newAnotherPropertyValue, 'Owner\'s \'newAnotherProperty\' is equals to related dynamicProperty (after change of whole \'dynamicProperties\' object)');

    ownerPropertiesNames = _ember['default'].A(Object.keys(mixinOwner));
    assert.strictEqual(ownerPropertiesNames.contains('usualProperty'), true, 'Owner\'s properties keys contains \'usualProperty\' (after change of whole \'dynamicProperties\' object)');
    assert.strictEqual(ownerPropertiesNames.contains('property'), false, 'Owner\'s properties keys doesn\'t contains \'property\' (after change of whole \'dynamicProperties\' object)');
    assert.strictEqual(ownerPropertiesNames.contains('anotherProperty'), false, 'Owner\'s properties keys doesn\'t contains \'anotherProperty\' (after change of whole \'dynamicProperties\' object)');
    assert.strictEqual(ownerPropertiesNames.contains('newProperty'), true, 'Owner\'s properties keys contains \'newProperty\' (after change of whole \'dynamicProperties\' object)');
    assert.strictEqual(ownerPropertiesNames.contains('newAnotherProperty'), true, 'Owner\'s properties keys contains \'newAnotherProperty\' (after change of whole \'dynamicProperties\' object)');

    mixinOwner.set('dynamicProperties', null);
    assert.strictEqual(mixinOwner.get('usualProperty'), usualPropertyValue, 'Owner\'s \'usualProperty\' is equals to it\'s initially defined value (after change of whole \'dynamicProperties\' object to null)');
    assert.strictEqual(_ember['default'].typeOf(mixinOwner.get('newProperty')), 'undefined', 'Owner\'s \'newProperty\' is undefined (after change of whole \'dynamicProperties\' object to null)');
    assert.strictEqual(_ember['default'].typeOf(mixinOwner.get('newAnotherProperty')), 'undefined', 'Owner\'s \'newAnotherProperty\' is undefined (after change of whole \'dynamicProperties\' object to null)');

    ownerPropertiesNames = _ember['default'].A(Object.keys(mixinOwner));
    assert.strictEqual(ownerPropertiesNames.contains('usualProperty'), true, 'Owner\'s properties keys contains \'usualProperty\' (after change of whole \'dynamicProperties\' object to null)');
    assert.strictEqual(ownerPropertiesNames.contains('newProperty'), false, 'Owner\'s properties keys doesn\'t contains \'newProperty\' (after change of whole \'dynamicProperties\' object to null)');
    assert.strictEqual(ownerPropertiesNames.contains('newAnotherProperty'), false, 'Owner\'s properties keys doesn\'t contains \'newAnotherProperty\' (after change of whole \'dynamicProperties\' object to null)');
  });

  (0, _qunit.test)('Mixin removes assigned \'dynamicProperties\' before owner will be destroyed', function (assert) {
    assert.expect(12);

    var propertyValue = 'MyProperty';
    var anotherPropertyValue = 'MyAnotherProperty';
    var dynamicProperties = { property: propertyValue, anotherProperty: anotherPropertyValue };

    var usualPropertyValue = 'MyUsualProperty';

    var mixinOwner = ClassWithDynamicPropertiesMixin.create({
      usualProperty: usualPropertyValue,
      dynamicProperties: dynamicProperties
    });

    assert.strictEqual(mixinOwner.get('usualProperty'), usualPropertyValue, 'Owner\'s \'usualProperty\' is equals to it\'s initially defined value');
    assert.strictEqual(mixinOwner.get('property'), propertyValue, 'Owner\'s \'property\' is equals to related dynamicProperty');
    assert.strictEqual(mixinOwner.get('anotherProperty'), anotherPropertyValue, 'Owner\'s \'anotherProperty\' is equals to related dynamicProperty');

    var ownerPropertiesNames = _ember['default'].A(Object.keys(mixinOwner));
    assert.strictEqual(ownerPropertiesNames.contains('usualProperty'), true, 'Owner\'s properties keys contains \'usualProperty\'');
    assert.strictEqual(ownerPropertiesNames.contains('property'), true, 'Owner\'s properties keys contains \'property\'');
    assert.strictEqual(ownerPropertiesNames.contains('anotherProperty'), true, 'Owner\'s properties keys contains \'anotherProperty\'');

    mixinOwner.willDestroy();

    assert.strictEqual(mixinOwner.get('usualProperty'), usualPropertyValue, 'Owner\'s \'usualProperty\' is equals to it\'s initially defined value (after change of whole \'dynamicProperties\' object)');
    assert.strictEqual(_ember['default'].typeOf(mixinOwner.get('property')), 'undefined', 'Owner\'s \'property\' is undefined (after change of whole \'dynamicProperties\' object)');
    assert.strictEqual(_ember['default'].typeOf(mixinOwner.get('anotherProperty')), 'undefined', 'Owner\'s \'anotherProperty\' is undefined (after change of whole \'dynamicProperties\' object)');

    ownerPropertiesNames = _ember['default'].A(Object.keys(mixinOwner));
    assert.strictEqual(ownerPropertiesNames.contains('usualProperty'), true, 'Owner\'s properties keys contains \'usualProperty\'');
    assert.strictEqual(ownerPropertiesNames.contains('property'), false, 'Owner\'s properties keys doesn\'t contains \'property\'');
    assert.strictEqual(ownerPropertiesNames.contains('anotherProperty'), false, 'Owner\'s properties keys doesn\'t contains \'anotherProperty\'');
  });
});
define('dummy/tests/unit/mixins/dynamic-properties-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/dynamic-properties-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/dynamic-properties-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/dynamic-properties-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/dynamic-properties-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/dynamic-properties-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-convert-object-coord-test', ['exports', 'ember', 'qunit', 'ember-flexberry-gis/mixins/flexberry-map-model-api', 'sinon', 'ember-flexberry-gis/coordinate-reference-systems/epsg-4326', 'ember-flexberry-gis/coordinate-reference-systems/epsg-3395'], function (exports, _ember, _qunit, _emberFlexberryGisMixinsFlexberryMapModelApi, _sinon, _emberFlexberryGisCoordinateReferenceSystemsEpsg4326, _emberFlexberryGisCoordinateReferenceSystemsEpsg3395) {

  (0, _qunit.module)('Unit | Mixin | test method _convertObjectCoordinates');

  var mapApiMixinObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApi['default']);
  var geoJsonObject = L.polygon([[0, 100], [0, 101], [1, 101], [1, 100]]).toGeoJSON();

  (0, _qunit.test)('test method _convertObjectCoordinates with EPSG:4326', function (assert) {
    //Arrange
    assert.expect(1);
    var ownerStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    ownerStub.returns({
      knownForType: function knownForType() {
        return {
          'epsg4326': _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default'],
          'epsg3395': _emberFlexberryGisCoordinateReferenceSystemsEpsg3395['default']
        };
      }
    });
    var subject = mapApiMixinObject.create();

    //Act
    var result = subject._convertObjectCoordinates('EPSG:4326', geoJsonObject);

    //Assert
    assert.deepEqual(result.geometry.coordinates, [[[100, 0], [101, 0], [101, 1], [100, 1], [100, 0]]], 'Equals rezult coordinates with test coordinates');
    ownerStub.restore();
  });

  (0, _qunit.test)('test method _convertObjectCoordinates with EPSG:3395', function (assert) {
    //Arrange
    assert.expect(1);
    var ownerStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    ownerStub.returns({
      knownForType: function knownForType() {
        return {
          'epsg4326': _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default'],
          'epsg3395': _emberFlexberryGisCoordinateReferenceSystemsEpsg3395['default']
        };
      }
    });
    var subject = mapApiMixinObject.create();

    //Act
    var result = subject._convertObjectCoordinates('EPSG:4326', geoJsonObject, 'EPSG:3395');

    //Assert
    assert.deepEqual(result.geometry.coordinates, [[[11131949.079327356, 7.081154551613622e-10], [11243268.57012063, 7.081154551613622e-10], [11243268.57012063, 110579.9652218976], [11131949.079327356, 110579.9652218976], [11131949.079327356, 7.081154551613622e-10]]], 'Equals rezult coordinates with test coordinates');
    ownerStub.restore();
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-convert-object-coord-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/flexberry-map-model-api-convert-object-coord-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/flexberry-map-model-api-convert-object-coord-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-convert-object-coord-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/flexberry-map-model-api-convert-object-coord-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/flexberry-map-model-api-convert-object-coord-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-copy-object-test', ['exports', 'ember', 'qunit', 'ember-flexberry-gis/mixins/flexberry-map-model-api', 'sinon'], function (exports, _ember, _qunit, _emberFlexberryGisMixinsFlexberryMapModelApi, _sinon) {

  (0, _qunit.module)('Unit | Mixin | method copyObject');

  var mapApiMixinObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApi['default']);

  (0, _qunit.test)('test method copyObject', function (assert) {
    //Arrange
    assert.expect(8);
    var done = assert.async(1);
    var sourceLeafletLayer = L.featureGroup();
    var destinationLeafletLayer = L.featureGroup();
    var polygon = L.polygon([[1, 1], [5, 1], [2, 2], [3, 5]]);
    polygon.feature = {
      properties: {}
    };
    var destinationLayerModel = _ember['default'].A({
      settingsAsObject: {
        typeGeometry: 'polygon'
      }
    });
    var getModelLayerFeature = function getModelLayerFeature() {
      return _ember['default'].RSVP.resolve([{}, sourceLeafletLayer, [polygon]]);
    };

    var getModelLeafletObject = function getModelLeafletObject() {
      return [destinationLayerModel, destinationLeafletLayer];
    };

    var subject = mapApiMixinObject.create({
      _getModelLayerFeature: function _getModelLayerFeature() {},
      _getModelLeafletObject: function _getModelLeafletObject() {}
    });
    var getMLFeature = _sinon['default'].stub(subject, '_getModelLayerFeature', getModelLayerFeature);
    var getMLObject = _sinon['default'].stub(subject, '_getModelLeafletObject', getModelLeafletObject);

    //Act
    var result = subject.copyObject({
      layerId: '1',
      objectId: '1',
      shouldRemove: true
    }, {
      layerId: '2',
      properties: {}
    });

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise, 'Check result instance of Promise');
    result.then(function (data) {
      assert.deepEqual(data.getLatLngs(), [[L.latLng(1, 1), L.latLng(5, 1), L.latLng(2, 2), L.latLng(3, 5)]], 'Check latLngs');
      assert.equal(getMLFeature.callCount, 1, 'Check call count to method _getModelLayerFeature');
      assert.equal(getMLFeature.args[0][0], '1', 'Check call first arg to method _getModelLayerFeature');
      assert.equal(getMLFeature.args[0][1], '1', 'Check call second arg to method _getModelLayerFeature');
      assert.equal(getMLFeature.args[0][2], true, 'Check call third arg to method _getModelLayerFeature');
      assert.equal(getMLObject.callCount, 1, 'Check call count to method _getModelLeafletObject');
      assert.equal(getMLObject.args[0][0], '2', 'Check call first arg to method _getModelLeafletObject');
      done();
      getMLFeature.restore();
      getMLObject.restore();
    });
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-copy-object-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/flexberry-map-model-api-copy-object-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/flexberry-map-model-api-copy-object-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-copy-object-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/flexberry-map-model-api-copy-object-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/flexberry-map-model-api-copy-object-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-cosmos-test', ['exports', 'ember', 'ember-flexberry-gis/mixins/flexberry-map-model-api-cosmos', 'ember-flexberry-gis/coordinate-reference-systems/epsg-4326', 'dummy/tests/helpers/start-app', 'ember-flexberry-data', 'qunit', 'sinon'], function (exports, _ember, _emberFlexberryGisMixinsFlexberryMapModelApiCosmos, _emberFlexberryGisCoordinateReferenceSystemsEpsg4326, _dummyTestsHelpersStartApp, _emberFlexberryData, _qunit, _sinon) {

  var app = undefined;
  var store = undefined;

  (0, _qunit.module)('Unit | Mixin | flexberry map model api cosmos', {
    unit: true,
    needs: ['config:environment', 'model:new-platform-flexberry-g-i-s-layer-metadata'],
    beforeEach: function beforeEach() {
      _ember['default'].run(function () {
        app = (0, _dummyTestsHelpersStartApp['default'])();
        app.deferReadiness();
        store = app.__container__.lookup('service:store');
      });
    },
    afterEach: function afterEach() {
      _ember['default'].run(app, 'destroy');
    }
  });

  var mapApiMixinObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApiCosmos['default']);
  var metadataProjection = 'LayerMetadataE';
  var metadataModelName = 'new-platform-flexberry-g-i-s-layer-metadata';
  var crsFactory32640 = {
    code: 'EPSG:32640',
    definition: '+proj=utm +zone=40 +datum=WGS84 +units=m +no_defs',
    create: function create() {
      var crs = L.extend({}, new L.Proj.CRS(this.code, this.definition), {
        scale: function scale(zoom) {
          return 256 * Math.pow(2, zoom);
        },
        zoom: function zoom(scale) {
          return Math.log(scale / 256) / Math.LN2;
        }
      });
      return crs;
    }
  };
  var bbox = {
    type: 'Polygon',
    coordinates: [[[30, 20], [30, 30], [20, 30], [20, 20], [30, 20]]],
    crs: {
      type: 'name',
      properties: {
        name: 'EPSG:4326'
      }
    }
  };
  var testModel = _ember['default'].Object.create({
    anyText: 'test',
    boundingBox: bbox,
    id: '123',
    type: 'wms',
    settings: '{}'
  });

  (0, _qunit.test)('test method findCosmos for only with parameter feature', function (assert) {
    //Arrange
    assert.expect(7);
    var done = assert.async(1);
    var feature = {
      type: 'Feature',
      geometry: {
        type: 'Polygon',
        coordinates: [[[30, 10], [40, 40], [20, 40], [10, 20], [30, 10]]]
      },
      crs: {
        type: 'name',
        properties: {
          name: 'EPSG:4326'
        }
      }
    };

    var ownerStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    ownerStub.returns({
      knownForType: function knownForType() {
        return {
          'epsg4326': _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default']
        };
      },
      lookup: function lookup() {
        return null;
      }
    });

    var subject = mapApiMixinObject.create({
      _getQueryBuilderLayerMetadata: function _getQueryBuilderLayerMetadata() {
        return new _emberFlexberryData.Query.Builder(store, metadataModelName).from(metadataModelName).selectByProjection(metadataProjection);
      },
      _getMetadataModels: function _getMetadataModels() {
        return _ember['default'].RSVP.resolve([testModel]);
      }
    });
    var spyGetMetadataModels = _sinon['default'].spy(subject, '_getMetadataModels');
    var spyGetQueryBuilderLayerMetadata = _sinon['default'].spy(subject, '_getQueryBuilderLayerMetadata');

    //Act
    subject.findLayerMetadata(feature, null).then(function (layers) {
      //Assert
      assert.ok(spyGetQueryBuilderLayerMetadata.called);
      assert.ok(spyGetMetadataModels.called);
      assert.ok(spyGetMetadataModels.getCall(0).args[0]._predicate instanceof _emberFlexberryData.Query.GeographyPredicate);
      assert.equal(spyGetMetadataModels.getCall(0).args[0]._predicate._attributePath, 'boundingBox');
      assert.equal(spyGetMetadataModels.getCall(0).args[0]._predicate._intersectsValue, 'SRID=4326;POLYGON((30 10, 40 40, 20 40, 10 20, 30 10))');
      assert.equal(layers.length, 1);
      assert.equal(layers[0].areaIntersections, 100);
      done();
      ownerStub.restore();
      spyGetMetadataModels.restore();
      spyGetQueryBuilderLayerMetadata.restore();
    });
  });

  (0, _qunit.test)('test method findCosmos for only with parameter attributes one', function (assert) {
    //Arrange
    assert.expect(7);
    var done = assert.async(1);
    var attributes = ['test'];

    var ownerStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    ownerStub.returns({
      knownForType: function knownForType() {
        return {
          'epsg4326': _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default']
        };
      },
      lookup: function lookup() {
        return null;
      }
    });

    var subject = mapApiMixinObject.create({
      _getQueryBuilderLayerMetadata: function _getQueryBuilderLayerMetadata() {
        return new _emberFlexberryData.Query.Builder(store, metadataModelName).from(metadataModelName).selectByProjection(metadataProjection);
      },
      _getMetadataModels: function _getMetadataModels() {
        return _ember['default'].RSVP.resolve([testModel]);
      }
    });
    var spyGetMetadataModels = _sinon['default'].spy(subject, '_getMetadataModels');
    var spyGetQueryBuilderLayerMetadata = _sinon['default'].spy(subject, '_getQueryBuilderLayerMetadata');

    //Act
    subject.findLayerMetadata(null, attributes).then(function (layers) {
      //Assert
      assert.ok(spyGetQueryBuilderLayerMetadata.called);
      assert.ok(spyGetMetadataModels.called);
      assert.ok(spyGetMetadataModels.getCall(0).args[0]._predicate instanceof _emberFlexberryData.Query.StringPredicate);
      assert.equal(spyGetMetadataModels.getCall(0).args[0]._predicate._attributePath, 'anyText');
      assert.equal(spyGetMetadataModels.getCall(0).args[0]._predicate._containsValue, 'test');
      assert.equal(layers.length, 1);
      assert.ok(!layers[0].hasOwnProperty('areaIntersections'));
      done();
      ownerStub.restore();
      spyGetMetadataModels.restore();
      spyGetQueryBuilderLayerMetadata.restore();
    });
  });

  (0, _qunit.test)('test method findCosmos for only with parameter attributes two', function (assert) {
    //Arrange
    assert.expect(12);
    var done = assert.async(1);
    var attributes = ['test1', 'test2'];

    var ownerStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    ownerStub.returns({
      knownForType: function knownForType() {
        return {
          'epsg4326': _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default']
        };
      },
      lookup: function lookup() {
        return null;
      }
    });

    var subject = mapApiMixinObject.create({
      _getQueryBuilderLayerMetadata: function _getQueryBuilderLayerMetadata() {
        return new _emberFlexberryData.Query.Builder(store, metadataModelName).from(metadataModelName).selectByProjection(metadataProjection);
      },
      _getMetadataModels: function _getMetadataModels() {
        return _ember['default'].RSVP.resolve([testModel]);
      }
    });
    var spyGetMetadataModels = _sinon['default'].spy(subject, '_getMetadataModels');
    var spyGetQueryBuilderLayerMetadata = _sinon['default'].spy(subject, '_getQueryBuilderLayerMetadata');

    //Act
    subject.findLayerMetadata(null, attributes).then(function (layers) {
      //Assert
      assert.ok(spyGetQueryBuilderLayerMetadata.called);
      assert.ok(spyGetMetadataModels.called);
      assert.ok(spyGetMetadataModels.getCall(0).args[0]._predicate instanceof _emberFlexberryData.Query.ComplexPredicate);
      assert.equal(spyGetMetadataModels.getCall(0).args[0]._predicate._condition, 'or');
      assert.equal(spyGetMetadataModels.getCall(0).args[0]._predicate._predicates.length, 2);
      assert.ok(spyGetMetadataModels.getCall(0).args[0]._predicate._predicates[0] instanceof _emberFlexberryData.Query.StringPredicate);
      assert.equal(spyGetMetadataModels.getCall(0).args[0]._predicate._predicates[0]._attributePath, 'anyText');
      assert.equal(spyGetMetadataModels.getCall(0).args[0]._predicate._predicates[0]._containsValue, 'test1');
      assert.ok(spyGetMetadataModels.getCall(0).args[0]._predicate._predicates[1] instanceof _emberFlexberryData.Query.StringPredicate);
      assert.equal(spyGetMetadataModels.getCall(0).args[0]._predicate._predicates[1]._attributePath, 'anyText');
      assert.equal(spyGetMetadataModels.getCall(0).args[0]._predicate._predicates[1]._containsValue, 'test2');
      assert.equal(layers.length, 1);
      done();
      ownerStub.restore();
      spyGetMetadataModels.restore();
      spyGetQueryBuilderLayerMetadata.restore();
    });
  });

  (0, _qunit.test)('test method findCosmos for with feature and attributes', function (assert) {
    //Arrange
    assert.expect(13);
    var done = assert.async(1);
    var feature = {
      type: 'Feature',
      geometry: {
        type: 'Polygon',
        coordinates: [[[-2568154.38200208, 1238447.0003685], [-954618.679368619, 4568735.95227168], [-2683586.25264709, 5143088.31265003], [-4878104.10393015, 3114937.3173714], [-2568154.38200208, 1238447.0003685]]]
      },
      crs: {
        type: 'name',
        properties: {
          name: 'EPSG:32640'
        }
      }
    };
    var attributes = ['test'];

    var ownerStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    ownerStub.returns({
      knownForType: function knownForType() {
        return {
          'epsg32640': crsFactory32640
        };
      },
      lookup: function lookup() {
        return null;
      }
    });

    var subject = mapApiMixinObject.create({
      _getQueryBuilderLayerMetadata: function _getQueryBuilderLayerMetadata() {
        return new _emberFlexberryData.Query.Builder(store, metadataModelName).from(metadataModelName).selectByProjection(metadataProjection);
      },
      _getMetadataModels: function _getMetadataModels() {
        return _ember['default'].RSVP.resolve([testModel]);
      }
    });
    var spyGetMetadataModels = _sinon['default'].spy(subject, '_getMetadataModels');
    var spyGetQueryBuilderLayerMetadata = _sinon['default'].spy(subject, '_getQueryBuilderLayerMetadata');

    //Act
    subject.findLayerMetadata(feature, attributes).then(function (layers) {
      //Assert
      assert.ok(spyGetQueryBuilderLayerMetadata.called);
      assert.ok(spyGetMetadataModels.called);
      assert.ok(spyGetMetadataModels.getCall(0).args[0]._predicate instanceof _emberFlexberryData.Query.ComplexPredicate);
      assert.equal(spyGetMetadataModels.getCall(0).args[0]._predicate._condition, 'and');
      assert.equal(spyGetMetadataModels.getCall(0).args[0]._predicate._predicates.length, 2);
      assert.ok(spyGetMetadataModels.getCall(0).args[0]._predicate._predicates[0] instanceof _emberFlexberryData.Query.GeographyPredicate);
      assert.equal(spyGetMetadataModels.getCall(0).args[0]._predicate._predicates[0]._attributePath, 'boundingBox');
      assert.equal(spyGetMetadataModels.getCall(0).args[0]._predicate._predicates[0]._intersectsValue, 'SRID=4326;POLYGON((29.999999999999964 9.999999999999961, 40 39.999999999999964, 19.999999999999964 39.99999999999997, ' + '10.000000000000059 19.999999999999943, 29.999999999999964 9.999999999999961))');
      assert.ok(spyGetMetadataModels.getCall(0).args[0]._predicate._predicates[1] instanceof _emberFlexberryData.Query.StringPredicate);
      assert.equal(spyGetMetadataModels.getCall(0).args[0]._predicate._predicates[1]._attributePath, 'anyText');
      assert.equal(spyGetMetadataModels.getCall(0).args[0]._predicate._predicates[1]._containsValue, 'test');
      assert.equal(layers.length, 1);
      assert.equal(layers[0].areaIntersections, 1452646131646.9414);
      done();
      ownerStub.restore();
      spyGetMetadataModels.restore();
      spyGetQueryBuilderLayerMetadata.restore();
    });
  });

  (0, _qunit.test)('test method addLayerFromLayerMetadata', function (assert) {
    //Arrange
    assert.expect(7);
    var done = assert.async(1);
    var hierarchy = _ember['default'].A();
    var subject = mapApiMixinObject.create({
      _getQueryBuilderLayerMetadata: function _getQueryBuilderLayerMetadata() {
        return new _emberFlexberryData.Query.Builder(store, metadataModelName).from(metadataModelName).selectByProjection(metadataProjection);
      },
      _getMetadataModels: function _getMetadataModels() {
        return _ember['default'].RSVP.resolve({ content: [testModel] });
      },
      store: store,
      hierarchy: hierarchy
    });
    var spyGetMetadataModels = _sinon['default'].spy(subject, '_getMetadataModels');
    var spyGetQueryBuilderLayerMetadata = _sinon['default'].spy(subject, '_getQueryBuilderLayerMetadata');

    //Act
    subject.addLayerFromLayerMetadata('123', 10).then(function (layer) {
      //Assert
      assert.ok(spyGetQueryBuilderLayerMetadata.called);
      assert.ok(spyGetMetadataModels.called);
      assert.ok(spyGetMetadataModels.getCall(0).args[0]._id, '123');
      assert.ok(layer);
      assert.equal(layer.get('index'), '10');
      assert.equal(hierarchy.length, 1);
      assert.equal(layer.get('type'), 'wms');
      done();
      spyGetMetadataModels.restore();
      spyGetQueryBuilderLayerMetadata.restore();
    });
  });

  (0, _qunit.test)('test method addLayerFromLayerMetadata not found layer', function (assert) {
    //Arrange
    assert.expect(4);
    var done = assert.async(1);
    var hierarchy = _ember['default'].A();
    var subject = mapApiMixinObject.create({
      _getQueryBuilderLayerMetadata: function _getQueryBuilderLayerMetadata() {
        return new _emberFlexberryData.Query.Builder(store, metadataModelName).from(metadataModelName).selectByProjection(metadataProjection);
      },
      _getMetadataModels: function _getMetadataModels() {
        return _ember['default'].RSVP.resolve({ content: [] });
      },
      store: store,
      hierarchy: hierarchy
    });
    var spyGetMetadataModels = _sinon['default'].spy(subject, '_getMetadataModels');
    var spyGetQueryBuilderLayerMetadata = _sinon['default'].spy(subject, '_getQueryBuilderLayerMetadata');

    //Act
    subject.addLayerFromLayerMetadata('123', 10)['catch'](function (error) {
      //Assert
      assert.ok(spyGetQueryBuilderLayerMetadata.called);
      assert.ok(spyGetMetadataModels.called);
      assert.ok(spyGetMetadataModels.getCall(0).args[0]._id, '123');
      assert.equal(error, 'LayerMetadata 123 not found.');
      done();
      spyGetMetadataModels.restore();
      spyGetQueryBuilderLayerMetadata.restore();
    });
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-cosmos-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/flexberry-map-model-api-cosmos-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/flexberry-map-model-api-cosmos-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-cosmos-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/flexberry-map-model-api-cosmos-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/flexberry-map-model-api-cosmos-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-create-polygon-object-rhumb-test', ['exports', 'ember', 'qunit', 'ember-flexberry-gis/mixins/flexberry-map-model-api-expansion', 'ember-flexberry-gis/coordinate-reference-systems/epsg-4326'], function (exports, _ember, _qunit, _emberFlexberryGisMixinsFlexberryMapModelApiExpansion, _emberFlexberryGisCoordinateReferenceSystemsEpsg4326) {

  (0, _qunit.module)('Unit | Mixin | test method createPolygonObjectRhumb');

  var mapApiMixinObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApiExpansion['default']);
  var crs4326 = _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default'].create();

  var crsFactory32640 = {
    code: 'EPSG:32640',
    definition: '+proj=utm +zone=40 +datum=WGS84 +units=m +no_defs',
    create: function create() {
      var crs = L.extend({}, new L.Proj.CRS(this.code, this.definition), {
        scale: function scale(zoom) {
          return 256 * Math.pow(2, zoom);
        },
        zoom: function zoom(scale) {
          return Math.log(scale / 256) / Math.LN2;
        }
      });
      return crs;
    }
  };

  var crs32640 = crsFactory32640.create();

  (0, _qunit.test)('test method createPolygonObjectRhumb for LineString', function (assert) {
    //Arrange
    var testLiseString = {
      type: 'LineString',
      startPoint: [3, 7],
      crs: 'EPSG:4326',
      skip: 0,
      points: [{
        rhumb: 'SE',
        angle: 0,
        distance: 10
      }, {
        rhumb: 'NE',
        angle: 90,
        distance: 10
      }]
    };

    var resObj = {
      type: 'Feature',
      properties: undefined,
      geometry: {
        type: 'LineString',
        coordinates: [[3, 7], [3.0000000000000013, -3], [13.000000000000002, -2.9999999999999996]]
      },
      crs: {
        properties: {
          name: 'EPSG:4326'
        },
        type: 'name'
      }
    };
    var subject = mapApiMixinObject.create({
      _getModelLeafletObject: function _getModelLeafletObject() {
        return [null, { options: { crs: crs4326 } }];
      }
    });

    //Act
    var feature = subject.createPolygonObjectRhumb('1', testLiseString);

    //Assert
    assert.deepEqual(feature, resObj);
  });

  (0, _qunit.test)('test method createPolygonObjectRhumb for Polygon', function (assert) {
    //Arrange
    var testLiseString = {
      type: 'Polygon',
      startPoint: [30, 70],
      crs: 'EPSG:32640',
      skip: 0,
      hole: false,
      points: [{
        rhumb: 'SE',
        angle: 0,
        distance: 10
      }, {
        rhumb: 'NE',
        angle: 90,
        distance: 10
      }, {
        rhumb: 'NW',
        angle: 0,
        distance: 10
      }, {
        rhumb: 'NW',
        angle: 90,
        distance: 10
      }]
    };

    var resObj = {
      type: 'Feature',
      properties: undefined,
      geometry: {
        type: 'Polygon',
        coordinates: [[[30, 70], [30, 60], [40, 60], [40, 70], [30, 70]]]
      },
      crs: {
        properties: {
          name: 'EPSG:32640'
        },
        type: 'name'
      }
    };
    var subject = mapApiMixinObject.create({
      _getModelLeafletObject: function _getModelLeafletObject() {
        return [null, { options: { crs: crs32640 } }];
      }
    });

    //Act
    var feature = subject.createPolygonObjectRhumb('1', testLiseString);

    //Assert
    assert.deepEqual(feature, resObj);
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-create-polygon-object-rhumb-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/flexberry-map-model-api-create-polygon-object-rhumb-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/flexberry-map-model-api-create-polygon-object-rhumb-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-create-polygon-object-rhumb-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/flexberry-map-model-api-create-polygon-object-rhumb-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/flexberry-map-model-api-create-polygon-object-rhumb-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-delete-layer-objects-test', ['exports', 'ember', 'qunit', 'ember-flexberry-gis/mixins/flexberry-map-model-api', 'sinon'], function (exports, _ember, _qunit, _emberFlexberryGisMixinsFlexberryMapModelApi, _sinon) {

  (0, _qunit.module)('Unit | Mixin | method deleteLayerObjects');

  var mapApiMixinObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApi['default']);

  (0, _qunit.test)('test method deleteLayerObjects', function (assert) {
    //Arrange
    assert.expect(8);
    var done = assert.async(1);
    var testLeafletObject = L.featureGroup();
    var polygon = L.polygon([[1, 1], [2, 5], [2, 5]]).addTo(testLeafletObject);
    polygon.id = '1';
    var obj = { _deleteLayerFromAttrPanel: function _deleteLayerFromAttrPanel() {} };
    var getModelLayerFeature = function getModelLayerFeature() {
      return _ember['default'].RSVP.resolve([null, testLeafletObject]);
    };

    var subject = mapApiMixinObject.create({
      _getModelLayerFeature: function _getModelLayerFeature() {},
      mapApi: { getFromApi: function getFromApi() {
          return obj._deleteLayerFromAttrPanel;
        } },
      _getLayerFeatureId: function _getLayerFeatureId(layer, shape) {
        return shape.id;
      }
    });
    var getMLFeature = _sinon['default'].stub(subject, '_getModelLayerFeature', getModelLayerFeature);
    var spyDeleteLayerFromAttrPanelFunc = _sinon['default'].spy(obj, '_deleteLayerFromAttrPanel');
    var spyRemoveLayer = _sinon['default'].spy(testLeafletObject, 'removeLayer');

    //Act
    var result = subject.deleteLayerObjects('1', ['1']);

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise, 'Check result instance of Promise');
    result.then(function () {
      assert.equal(spyDeleteLayerFromAttrPanelFunc.callCount, 1, 'Check call count to method _deleteLayerFromAttrPanel');
      assert.equal(getMLFeature.callCount, 1, 'Check call count to method _getModelLayerFeature');
      assert.equal(getMLFeature.args[0][0], '1', 'Check call first arg to method _getModelLayerFeature');
      assert.deepEqual(getMLFeature.args[0][1], ['1'], 'Check call second arg to method _getModelLayerFeature');
      assert.equal(spyRemoveLayer.callCount, 1, 'Check call count to method removeLayer');
      assert.equal(spyRemoveLayer.args[0][0].id, '1', 'Check call first arg to method removeLayer');
      assert.equal(testLeafletObject.getLayers().length, 0, 'Count layers in object');
      done();
      spyDeleteLayerFromAttrPanelFunc.restore();
      spyRemoveLayer.restore();
      getMLFeature.restore();
    });
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-delete-layer-objects-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/flexberry-map-model-api-delete-layer-objects-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/flexberry-map-model-api-delete-layer-objects-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-delete-layer-objects-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/flexberry-map-model-api-delete-layer-objects-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/flexberry-map-model-api-delete-layer-objects-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-download-file-test', ['exports', 'ember', 'qunit', 'ember-flexberry-gis/mixins/flexberry-map-model-api', 'sinon', 'ember-flexberry-gis/coordinate-reference-systems/epsg-4326'], function (exports, _ember, _qunit, _emberFlexberryGisMixinsFlexberryMapModelApi, _sinon, _emberFlexberryGisCoordinateReferenceSystemsEpsg4326) {

  (0, _qunit.module)('Unit | Mixin | flexberry map model api download file');

  var mapApiMixinObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApi['default']);

  (0, _qunit.test)('test api method downloadFile', function (assert) {
    assert.expect(4);
    var done = assert.async(1);
    var ownerStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    ownerStub.returns({
      knownForType: function knownForType() {
        return {
          'epsg4326': _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default']
        };
      },
      resolveRegistration: function resolveRegistration() {
        return {
          APP: {
            backendUrls: {
              featureExportApi: 'featureExportApi'
            }
          }
        };
      }
    });

    var layer = _ember['default'].Object.create({
      id: '1',
      type: 'wfs',
      settingsAsObject: {
        url: 'geoserverUrl',
        typeNS: 'testTypeNS',
        typeName: 'layerWfs',
        geometryField: 'geometryField'
      },
      name: 'layerWfsName',
      headers: {},
      crs: {
        code: 'EPSG:4326'
      }
    });
    var maplayers = _ember['default'].A(layer);
    var subject = mapApiMixinObject.create({
      mapLayer: maplayers
    });

    var findByStub = _sinon['default'].stub(subject.mapLayer, 'findBy');
    findByStub.returns(layer);
    var stubAjax = _sinon['default'].stub(_ember['default'].$, 'ajax');
    stubAjax.yieldsTo('success', 'blob');

    var result = subject.downloadFile('1', ['111'], 'JSON', 'EPSG:4326', false);
    assert.ok(result instanceof _ember['default'].RSVP.Promise);
    result.then(function (res) {
      assert.equal(res.fileName, 'layerWfsName.json');
      assert.equal(res.blob, 'blob');
      assert.equal(stubAjax.callCount, 1);
      done();
      ownerStub.restore();
      stubAjax.restore();
      findByStub.restore();
    });
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-download-file-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/flexberry-map-model-api-download-file-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/flexberry-map-model-api-download-file-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-download-file-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/flexberry-map-model-api-download-file-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/flexberry-map-model-api-download-file-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-edit-layer-object-test', ['exports', 'ember', 'qunit', 'ember-flexberry-gis/mixins/flexberry-map-model-api', 'sinon', 'ember-flexberry-gis/coordinate-reference-systems/epsg-4326', 'ember-flexberry-gis/coordinate-reference-systems/epsg-3395'], function (exports, _ember, _qunit, _emberFlexberryGisMixinsFlexberryMapModelApi, _sinon, _emberFlexberryGisCoordinateReferenceSystemsEpsg4326, _emberFlexberryGisCoordinateReferenceSystemsEpsg3395) {

  (0, _qunit.module)('Unit | Mixin | test method editLayerObject');

  var mapApiMixinObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApi['default']);
  var geoJsonObject = L.polygon([[0, 100], [0, 101], [1, 101], [1, 100]]).toGeoJSON();
  var leafletObject = L.polygon([[1, 0], [2, 3], [3, 1], [3, 0]]);
  var leafletLayer = {
    options: {
      crs: {
        code: 'EPSG:4326'
      }
    },
    editLayer: function editLayer() {}
  };

  (0, _qunit.test)('test method editLayerObject with EPSG:4326', function (assert) {
    //Arrange
    assert.expect(6);
    var done = assert.async(1);
    var ownerStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    ownerStub.returns({
      knownForType: function knownForType() {
        return {
          'epsg4326': _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default'],
          'epsg3395': _emberFlexberryGisCoordinateReferenceSystemsEpsg3395['default']
        };
      },
      knownNamesForType: function knownNamesForType() {
        return ['epsg4326', 'epsg3395'];
      }
    });
    var getModelLayerFeature = function getModelLayerFeature() {
      return _ember['default'].RSVP.resolve([{}, leafletLayer, [leafletObject]]);
    };

    var subject = mapApiMixinObject.create({
      _getModelLayerFeature: function _getModelLayerFeature() {}
    });
    var spyEditLayer = _sinon['default'].spy(leafletLayer, 'editLayer');
    var getMLFeature = _sinon['default'].stub(subject, '_getModelLayerFeature', getModelLayerFeature);

    //Act
    var result = subject.editLayerObject('1', '1', geoJsonObject, 'EPSG:4326');

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise, 'Check result instance of Promise');
    result.then(function (res) {
      assert.equal(spyEditLayer.callCount, 1, 'Check call count to method editLayer');
      assert.deepEqual(res._latlngs, [[L.latLng(0, 100), L.latLng(0, 101), L.latLng(1, 101), L.latLng(1, 100)]], 'Equals rezult coordinates with test coordinates');
      assert.equal(getMLFeature.callCount, 1, 'Check call count to method _getModelLayerFeature');
      assert.equal(getMLFeature.args[0][0], '1', 'Check call first arg to method _getModelLayerFeature');
      assert.deepEqual(getMLFeature.args[0][1], ['1'], 'Check call second arg to method _getModelLayerFeature');
      done();
      spyEditLayer.restore();
      getMLFeature.restore();
      ownerStub.restore();
    });
  });

  (0, _qunit.test)('test method editLayerObject with EPSG:3395', function (assert) {
    //Arrange
    assert.expect(7);
    var done = assert.async(1);
    var ownerStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    ownerStub.returns({
      knownForType: function knownForType() {
        return {
          'epsg4326': _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default'],
          'epsg3395': _emberFlexberryGisCoordinateReferenceSystemsEpsg3395['default']
        };
      },
      knownNamesForType: function knownNamesForType() {
        return ['epsg4326', 'epsg3395'];
      }
    });
    var getModelLayerFeature = function getModelLayerFeature() {
      return _ember['default'].RSVP.resolve([{}, leafletLayer, [leafletObject]]);
    };

    var subject = mapApiMixinObject.create({
      _getModelLayerFeature: function _getModelLayerFeature() {}
    });
    var spyEditLayer = _sinon['default'].spy(leafletLayer, 'editLayer');
    var spyUnProject = _sinon['default'].spy(L.CRS.EPSG3395, 'unproject');
    var getMLFeature = _sinon['default'].stub(subject, '_getModelLayerFeature', getModelLayerFeature);

    //Act
    var result = subject.editLayerObject('1', '1', geoJsonObject, 'EPSG:3395');

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise, 'Check result instance of Promise');
    result.then(function (res) {
      assert.equal(spyEditLayer.callCount, 1, 'Check call count to method editLayer');
      assert.equal(spyUnProject.callCount, 5, 'Check call count to method unproject');
      assert.equal(getMLFeature.callCount, 1, 'Check call count to method _getModelLayerFeature');
      assert.equal(getMLFeature.args[0][0], '1', 'Check call first arg to method _getModelLayerFeature');
      assert.deepEqual(getMLFeature.args[0][1], ['1'], 'Check call second arg to method _getModelLayerFeature');
      assert.deepEqual(res._latlngs, [[L.latLng(0, 0.0008983152841195215), L.latLng(0, 0.0009072984369607167), L.latLng(0.00000904328947124462, 0.0009072984369607167), L.latLng(0.00000904328947124462, 0.0008983152841195215)]], 'Equals rezult coordinates with test coordinates');
      done();
      spyUnProject.restore();
      getMLFeature.restore();
      spyEditLayer.restore();
      ownerStub.restore();
    });
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-edit-layer-object-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/flexberry-map-model-api-edit-layer-object-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/flexberry-map-model-api-edit-layer-object-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-edit-layer-object-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/flexberry-map-model-api-edit-layer-object-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/flexberry-map-model-api-edit-layer-object-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-expansion-add-object-to-layer-test', ['exports', 'ember', 'qunit', 'ember-flexberry-gis/mixins/flexberry-map-model-api-expansion', 'sinon', 'ember-flexberry-gis/coordinate-reference-systems/epsg-4326', 'ember-flexberry-gis/coordinate-reference-systems/epsg-3395'], function (exports, _ember, _qunit, _emberFlexberryGisMixinsFlexberryMapModelApiExpansion, _sinon, _emberFlexberryGisCoordinateReferenceSystemsEpsg4326, _emberFlexberryGisCoordinateReferenceSystemsEpsg3395) {

  (0, _qunit.module)('Unit | Mixin | test method addObjectToLayer');

  var mapApiMixinObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApiExpansion['default']);
  var geoJsonObject = L.polygon([[0, 100], [0, 101], [1, 101], [1, 100]]).toGeoJSON();

  (0, _qunit.test)('test method addObjectToLayer with EPSG:4326', function (assert) {
    //Arrange
    var done = assert.async(1);
    var ownerStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    ownerStub.returns({
      knownForType: function knownForType() {
        return {
          'epsg4326': _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default'],
          'epsg3395': _emberFlexberryGisCoordinateReferenceSystemsEpsg3395['default']
        };
      }
    });
    var leafletObject = L.featureGroup();
    leafletObject.options = { crs: { code: 'EPSG:4326' } };
    var getModelLeafletObject = function getModelLeafletObject() {
      return [{ id: 1 }, leafletObject];
    };

    var subject = mapApiMixinObject.create({
      _getModelLeafletObject: function _getModelLeafletObject() {}
    });
    var getMLObject = _sinon['default'].stub(subject, '_getModelLeafletObject', getModelLeafletObject);

    //Act
    var promise = subject.addObjectToLayer('1', geoJsonObject);

    assert.ok(promise instanceof _ember['default'].RSVP.Promise);

    promise.then(function (result) {
      assert.equal(leafletObject.getLayers().length, 0, 'Layers count');
      assert.equal(result.layerId, '1', 'Layer id');
      assert.deepEqual(result._latlngs, [[L.latLng(0, 100), L.latLng(0, 101), L.latLng(1, 101), L.latLng(1, 100)]]);
      assert.equal(getMLObject.callCount, 1, 'Check call count to method _getModelLeafletObject');
      assert.equal(getMLObject.args[0][0], '1', 'Check call first arg to method _getModelLeafletObject');
      ownerStub.restore();
      getMLObject.restore();
      done();
    });
  });

  (0, _qunit.test)('test method addObjectToLayer with EPSG:3395', function (assert) {
    //Arrange
    var done = assert.async(1);
    var ownerStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    ownerStub.returns({
      knownForType: function knownForType() {
        return {
          'epsg4326': _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default'],
          'epsg3395': _emberFlexberryGisCoordinateReferenceSystemsEpsg3395['default']
        };
      },
      knownNamesForType: function knownNamesForType() {
        return ['epsg4326', 'epsg3395'];
      }
    });
    var leafletObject = L.featureGroup();
    leafletObject.options = { crs: { code: 'EPSG:4326' } };
    var getModelLeafletObject = function getModelLeafletObject() {
      return [{ id: 1 }, leafletObject];
    };

    var subject = mapApiMixinObject.create({
      _getModelLeafletObject: function _getModelLeafletObject() {}
    });
    var getMLObject = _sinon['default'].stub(subject, '_getModelLeafletObject', getModelLeafletObject);

    //Act
    subject.addObjectToLayer('1', geoJsonObject, 'EPSG:3395').then(function (result) {
      //Assert
      assert.equal(leafletObject.getLayers().length, 0);
      assert.equal(result.layerId, '1');
      assert.deepEqual(result._latlngs, [[L.latLng(0, 0.0008983152841195215), L.latLng(0, 0.0009072984369607167), L.latLng(0.00000904328947124462, 0.0009072984369607167), L.latLng(0.00000904328947124462, 0.0008983152841195215)]]);
      assert.equal(getMLObject.callCount, 1, 'Check call count to method _getModelLeafletObject');
      assert.equal(getMLObject.args[0][0], '1', 'Check call first arg to method _getModelLeafletObject');
      ownerStub.restore();
      getMLObject.restore();
      done();
    });
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-expansion-add-object-to-layer-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/flexberry-map-model-api-expansion-add-object-to-layer-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/flexberry-map-model-api-expansion-add-object-to-layer-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-expansion-add-object-to-layer-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/flexberry-map-model-api-expansion-add-object-to-layer-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/flexberry-map-model-api-expansion-add-object-to-layer-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-expansion-trim-line-to-polygon-test', ['exports', 'ember', 'qunit', 'ember-flexberry-gis/mixins/flexberry-map-model-api-expansion'], function (exports, _ember, _qunit, _emberFlexberryGisMixinsFlexberryMapModelApiExpansion) {

  (0, _qunit.module)('Unit | Mixin | test method trimLineToPolygon');

  var mapApiMixinObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApiExpansion['default']);

  var aGeoJson = {
    'type': 'Feature',
    'properties': {},
    'geometry': {
      'type': 'Polygon',
      'coordinates': [[[56.2, 58.1], [56.3, 58.1], [56.3, 58.2], [56.2, 58.2], [56.2, 58.1]]]
    },
    'crs': {
      'type': 'name',
      'properties': {
        'name': 'EPSG:4326'
      }
    }
  };
  var bGeoJson = {
    'type': 'Feature',
    'properties': {},
    'geometry': {
      'type': 'LineString',
      'coordinates': [[56.1, 58.1], [56.4, 58.1]]
    },
    'crs': {
      'type': 'name',
      'properties': {
        'name': 'EPSG:4326'
      }
    }
  };

  (0, _qunit.test)('test method trimLineToPolygon with EPSG:4326', function (assert) {
    assert.expect(2);
    var done = assert.async(1);
    var subject = mapApiMixinObject.create({});

    var promise = subject.trimLineToPolygon(aGeoJson, bGeoJson);

    assert.ok(promise instanceof _ember['default'].RSVP.Promise);
    promise.then(function (result) {
      assert.deepEqual(result.geometry.coordinates, [[56.2, 58.1], [56.3, 58.1]]);
      done();
    });
  });

  (0, _qunit.test)('test method trimLineToPolygon. Error objects does\' not intersect', function (assert) {
    assert.expect(2);
    var done = assert.async(1);
    bGeoJson.geometry.coordinates = [[56.1, 56], [56.4, 56]];
    var subject = mapApiMixinObject.create({});

    var promise = subject.trimLineToPolygon(aGeoJson, bGeoJson);

    assert.ok(promise instanceof _ember['default'].RSVP.Promise);
    promise.then()['catch'](function (result) {
      assert.equal(result, 'objects does\' not intersect');
      bGeoJson.geometry.coordinates = [[56.1, 58.1], [56.4, 58.1]];
      done();
    });
  });

  (0, _qunit.test)('test method trimLineToPolygon. Error different crs', function (assert) {
    assert.expect(2);
    var done = assert.async(1);
    aGeoJson.crs.properties.name = 'EPSG:3395';
    var subject = mapApiMixinObject.create({});

    var promise = subject.trimLineToPolygon(aGeoJson, bGeoJson);

    assert.ok(promise instanceof _ember['default'].RSVP.Promise);
    promise.then()['catch'](function (result) {
      assert.equal(result, 'CRS mismatch. Objects must have the same crs');
      aGeoJson.crs.properties.name = 'EPSG:4326';
      done();
    });
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-expansion-trim-line-to-polygon-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/flexberry-map-model-api-expansion-trim-line-to-polygon-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/flexberry-map-model-api-expansion-trim-line-to-polygon-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-expansion-trim-line-to-polygon-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/flexberry-map-model-api-expansion-trim-line-to-polygon-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/flexberry-map-model-api-expansion-trim-line-to-polygon-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-get-distance-between-objects-test', ['exports', 'ember', 'qunit', 'ember-flexberry-gis/mixins/flexberry-map-model-api'], function (exports, _ember, _qunit, _emberFlexberryGisMixinsFlexberryMapModelApi) {

  (0, _qunit.module)('Unit | Mixin | test method _getDistanceBetweenObjects');

  var mapApiMixinObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApi['default']);

  (0, _qunit.test)('test method _getDistanceBetweenObjects between polyline and polygon', function (assert) {
    //Arrange
    assert.expect(1);
    var firstObj = L.polyline([[1.001, 1.001], [1.003, 1.003], [1.005, 1.005]]);
    firstObj.feature = firstObj.toGeoJSON();
    var secondObj = L.polygon([[1.001, 1.001], [1.001, 1.002], [1.003, 1.001], [1.003, 0]]);
    secondObj.feature = secondObj.toGeoJSON();
    var subject = mapApiMixinObject.create();

    //Act
    var result = subject._getDistanceBetweenObjects(firstObj, secondObj);

    //Assert
    assert.equal(result, 55820.041009409564, 'Equals rezult distance with test distance');
  });

  (0, _qunit.test)('test method _getDistanceBetweenObjects between marker and polygon', function (assert) {
    //Arrange
    assert.expect(1);
    var firstObj = L.marker([1.001, 1.001]);
    firstObj.feature = firstObj.toGeoJSON();
    var secondObj = L.polygon([[1.001, 1.001], [1.001, 1.002], [1.003, 1.001], [1.003, 0]]);
    secondObj.feature = secondObj.toGeoJSON();
    var subject = mapApiMixinObject.create();

    //Act
    var result = subject._getDistanceBetweenObjects(firstObj, secondObj);

    //Assert
    assert.equal(result, 55597.65129192688, 'Equals rezult distance with test distance');
  });

  (0, _qunit.test)('test method _getDistanceBetweenObjects between marker and marker', function (assert) {
    //Arrange
    assert.expect(1);
    var firstObj = L.marker([1.001, 1.001]);
    firstObj.feature = firstObj.toGeoJSON();
    var secondObj = L.marker([1.001, 1.002]);
    secondObj.feature = secondObj.toGeoJSON();
    var subject = mapApiMixinObject.create();

    //Act
    var result = subject._getDistanceBetweenObjects(firstObj, secondObj);

    //Assert
    assert.equal(result, 111.19508023354534, 'Equals rezult distance with test distance');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-get-distance-between-objects-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/flexberry-map-model-api-get-distance-between-objects-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/flexberry-map-model-api-get-distance-between-objects-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-get-distance-between-objects-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/flexberry-map-model-api-get-distance-between-objects-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/flexberry-map-model-api-get-distance-between-objects-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-get-distance-test', ['exports', 'ember', 'qunit', 'ember-flexberry-gis/mixins/flexberry-map-model-api', 'sinon'], function (exports, _ember, _qunit, _emberFlexberryGisMixinsFlexberryMapModelApi, _sinon) {

  (0, _qunit.module)('Unit | Mixin | test method _getDistanceBetweenObjects');

  var mapApiMixinObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApi['default']);

  (0, _qunit.test)('test method getDistanceBetweenObjects between polyline and polygon', function (assert) {
    //Arrange
    assert.expect(7);
    var done = assert.async(1);
    var firstObj = L.polyline([[1.001, 1.001], [1.003, 1.003], [1.005, 1.005]]);
    firstObj.feature = firstObj.toGeoJSON();
    var secondObj = L.polygon([[1.001, 1.001], [1.001, 1.002], [1.003, 1.001], [1.003, 0]]);
    secondObj.feature = secondObj.toGeoJSON();
    var getModelLayerFeature = function getModelLayerFeature(layerId) {
      return _ember['default'].RSVP.resolve([null, null, [layerId === '1' ? firstObj : secondObj]]);
    };

    var subject = mapApiMixinObject.create({
      _getModelLayerFeature: function _getModelLayerFeature() {}
    });
    var getMLFeature = _sinon['default'].stub(subject, '_getModelLayerFeature', getModelLayerFeature);

    //Act
    var result = subject.getDistanceBetweenObjects('1', '4', '2', '3');

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise, 'Check result instance of Promise');
    result.then(function (res) {
      assert.equal(res, 55820.041009409564, 'Equals rezult distance with test distance');
      assert.equal(getMLFeature.callCount, 2, 'Check call count to method _getModelLayerFeature');
      assert.equal(getMLFeature.args[0][0], '1', 'Check call first arg to method _getModelLayerFeature');
      assert.equal(getMLFeature.args[0][1], '4', 'Check call second arg to method _getModelLayerFeature');
      assert.equal(getMLFeature.args[1][0], '2', 'Check call first arg to method _getModelLayerFeature');
      assert.equal(getMLFeature.args[1][1], '3', 'Check call second arg to method _getModelLayerFeature');
      done();
      getMLFeature.restore();
    });
  });

  (0, _qunit.test)('test method getDistanceBetweenObjects between marker and polygon', function (assert) {
    //Arrange
    assert.expect(7);
    var done = assert.async(1);
    var firstObj = L.marker([1.001, 1.001]);
    firstObj.feature = firstObj.toGeoJSON();
    var secondObj = L.polygon([[1.001, 1.001], [1.001, 1.002], [1.003, 1.001], [1.003, 0]]);
    secondObj.feature = secondObj.toGeoJSON();
    var getModelLayerFeature = function getModelLayerFeature(layerId) {
      return _ember['default'].RSVP.resolve([null, null, [layerId === '1' ? firstObj : secondObj]]);
    };

    var subject = mapApiMixinObject.create({
      _getModelLayerFeature: function _getModelLayerFeature() {}
    });
    var getMLFeature = _sinon['default'].stub(subject, '_getModelLayerFeature', getModelLayerFeature);

    //Act
    var result = subject.getDistanceBetweenObjects('1', '4', '2', '3');

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise, 'Check result instance of Promise');
    result.then(function (res) {
      assert.equal(res, 55597.65129192688, 'Equals rezult distance with test distance');
      assert.equal(getMLFeature.callCount, 2, 'Check call count to method _getModelLayerFeature');
      assert.equal(getMLFeature.args[0][0], '1', 'Check call first arg to method _getModelLayerFeature');
      assert.equal(getMLFeature.args[0][1], '4', 'Check call second arg to method _getModelLayerFeature');
      assert.equal(getMLFeature.args[1][0], '2', 'Check call first arg to method _getModelLayerFeature');
      assert.equal(getMLFeature.args[1][1], '3', 'Check call second arg to method _getModelLayerFeature');
      done();
      getMLFeature.restore();
    });
  });

  (0, _qunit.test)('test method getDistanceBetweenObjects between marker and marker', function (assert) {
    //Arrange
    assert.expect(7);
    var done = assert.async(1);
    var firstObj = L.marker([1.001, 1.001]);
    firstObj.feature = firstObj.toGeoJSON();
    var secondObj = L.marker([1.001, 1.002]);
    secondObj.feature = secondObj.toGeoJSON();
    var getModelLayerFeature = function getModelLayerFeature(layerId) {
      return _ember['default'].RSVP.resolve([null, null, [layerId === '1' ? firstObj : secondObj]]);
    };

    var subject = mapApiMixinObject.create({
      _getModelLayerFeature: function _getModelLayerFeature() {}
    });
    var getMLFeature = _sinon['default'].stub(subject, '_getModelLayerFeature', getModelLayerFeature);

    //Act
    var result = subject.getDistanceBetweenObjects('1', '4', '2', '3');

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise, 'Check result instance of Promise');
    result.then(function (res) {
      assert.equal(res, 111.19508023354534);
      assert.equal(getMLFeature.callCount, 2, 'Check call count to method _getModelLayerFeature');
      assert.equal(getMLFeature.args[0][0], '1', 'Check call first arg to method _getModelLayerFeature');
      assert.equal(getMLFeature.args[0][1], '4', 'Check call second arg to method _getModelLayerFeature');
      assert.equal(getMLFeature.args[1][0], '2', 'Check call first arg to method _getModelLayerFeature');
      assert.equal(getMLFeature.args[1][1], '3', 'Check call second arg to method _getModelLayerFeature');
      done();
      getMLFeature.restore();
    });
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-get-distance-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/flexberry-map-model-api-get-distance-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/flexberry-map-model-api-get-distance-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-get-distance-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/flexberry-map-model-api-get-distance-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/flexberry-map-model-api-get-distance-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-get-object-center-test', ['exports', 'ember', 'qunit', 'ember-flexberry-gis/mixins/flexberry-map-model-api'], function (exports, _ember, _qunit, _emberFlexberryGisMixinsFlexberryMapModelApi) {

  (0, _qunit.module)('Unit | Mixin | get object center');

  var mapApiMixinObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApi['default']);

  (0, _qunit.test)('return current center of point', function (assert) {
    //Arrange
    assert.expect(1);
    var subject = mapApiMixinObject.create();
    var obj2 = L.marker([1, 1]);
    obj2.feature = obj2.toGeoJSON();

    //Act
    var result = subject.getObjectCenter(obj2);
    var resObj = L.latLng(1, 1);

    //Assert
    assert.deepEqual(result, resObj, 'Equals rezult object with test object');
  });

  (0, _qunit.test)('return current center of polygon', function (assert) {
    //Arrange
    assert.expect(1);
    var subject = mapApiMixinObject.create();
    var obj2 = L.polygon([[1, 1], [1, 2], [3, 1], [3, 0]]);
    obj2.feature = obj2.toGeoJSON();

    //Act
    var result = subject.getObjectCenter(obj2);
    var resObj = L.latLng(2, 1);

    //Assert
    assert.deepEqual(result, resObj, 'Equals rezult object with test object');
  });

  (0, _qunit.test)('return current center of polyline', function (assert) {
    //Arrange
    assert.expect(1);
    var subject = mapApiMixinObject.create();
    var obj2 = L.polyline([[1, 1], [3, 3], [5, 5]]);
    obj2.feature = obj2.toGeoJSON();

    //Act
    var result = subject.getObjectCenter(obj2);
    var resObj = L.latLng(3, 3);

    //Assert
    assert.deepEqual(result, resObj, 'Equals rezult object with test object');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-get-object-center-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/flexberry-map-model-api-get-object-center-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/flexberry-map-model-api-get-object-center-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-get-object-center-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/flexberry-map-model-api-get-object-center-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/flexberry-map-model-api-get-object-center-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-get-rhumb-test', ['exports', 'ember', 'qunit', 'ember-flexberry-gis/mixins/flexberry-map-model-api'], function (exports, _ember, _qunit, _emberFlexberryGisMixinsFlexberryMapModelApi) {

  (0, _qunit.module)('Unit | Mixin | method get rhumb');

  var mapApiMixinObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApi['default']);

  (0, _qunit.test)('test method getRhumb for LineString', function (assert) {
    //Arrange
    var testLiseString = {
      type: 'Feature',
      geometry: {
        type: 'LineString',
        coordinates: [[3, 7], [3, 3], [8, 3]]
      }
    };

    var resObj = [{
      type: 'LineString',
      startPoint: [3, 7],
      crs: 'EPSG:4326',
      skip: 0,
      points: [{
        rhumb: 'SE',
        angle: 0,
        distance: 4
      }, {
        rhumb: 'SE',
        angle: 90,
        distance: 5
      }]
    }];
    var subject = mapApiMixinObject.create();

    //Act
    var rhumbs = subject.getRhumb(testLiseString, 'EPSG:4326');

    //Assert
    assert.deepEqual(rhumbs, resObj);
  });

  (0, _qunit.test)('test method getRhumb for MultiLineString', function (assert) {
    //Arrange
    var testLiseString = {
      type: 'Feature',
      geometry: {
        type: 'MultiLineString',
        coordinates: [[[3, 7], [3, 3], [8, 3]], [[6, 9], [6, 5], [10, 5]]]
      }
    };

    var resObj = [{
      type: 'LineString',
      startPoint: [3, 7],
      crs: 'EPSG:4326',
      skip: 0,
      points: [{
        rhumb: 'SE',
        angle: 0,
        distance: 4
      }, {
        rhumb: 'SE',
        angle: 90,
        distance: 5
      }]
    }, {
      type: 'LineString',
      startPoint: [6, 9],
      crs: 'EPSG:4326',
      skip: 0,
      points: [{
        rhumb: 'SE',
        angle: 0,
        distance: 4
      }, {
        rhumb: 'SE',
        angle: 90,
        distance: 4
      }]
    }];
    var subject = mapApiMixinObject.create();

    //Act
    var rhumbs = subject.getRhumb(testLiseString, 'EPSG:4326');

    //Assert
    assert.deepEqual(rhumbs, resObj);
  });

  (0, _qunit.test)('test method getRhumb for Polygon without hole', function (assert) {
    //Arrange
    var testLiseString = {
      type: 'Feature',
      geometry: {
        type: 'Polygon',
        coordinates: [[[3, 7], [3, 3], [8, 3], [8, 7], [3, 7]]]
      }
    };

    var resObj = [{
      type: 'Polygon',
      startPoint: [3, 7],
      crs: 'EPSG:4326',
      skip: 0,
      hole: false,
      points: [{
        rhumb: 'SE',
        angle: 0,
        distance: 4
      }, {
        rhumb: 'SE',
        angle: 90,
        distance: 5
      }, {
        rhumb: 'NE',
        angle: 0,
        distance: 4
      }, {
        rhumb: 'NW',
        angle: 90,
        distance: 5
      }]
    }];
    var subject = mapApiMixinObject.create();

    //Act
    var rhumbs = subject.getRhumb(testLiseString, 'EPSG:4326');

    //Assert
    assert.deepEqual(rhumbs, resObj);
  });

  (0, _qunit.test)('test method getRhumb for Polygon with hole', function (assert) {
    //Arrange
    var testLiseString = {
      type: 'Feature',
      geometry: {
        type: 'Polygon',
        coordinates: [[[3, 7], [3, 3], [8, 3], [8, 7], [3, 7]], [[4, 4], [5, 4], [5, 5], [4, 5], [4, 4]]]
      }
    };

    var resObj = [{
      type: 'Polygon',
      startPoint: [3, 7],
      crs: 'EPSG:4326',
      skip: 0,
      hole: false,
      points: [{
        rhumb: 'SE',
        angle: 0,
        distance: 4
      }, {
        rhumb: 'SE',
        angle: 90,
        distance: 5
      }, {
        rhumb: 'NE',
        angle: 0,
        distance: 4
      }, {
        rhumb: 'NW',
        angle: 90,
        distance: 5
      }]
    }, {
      type: 'Polygon',
      startPoint: [4, 4],
      crs: 'EPSG:4326',
      skip: 0,
      hole: true,
      points: [{
        rhumb: 'SE',
        angle: 90,
        distance: 1
      }, {
        rhumb: 'NE',
        angle: 0,
        distance: 1
      }, {
        rhumb: 'NW',
        angle: 90,
        distance: 1
      }, {
        rhumb: 'SE',
        angle: 0,
        distance: 1
      }]
    }];
    var subject = mapApiMixinObject.create();

    //Act
    var rhumbs = subject.getRhumb(testLiseString, 'EPSG:4326');

    //Assert
    assert.deepEqual(rhumbs, resObj);
  });

  (0, _qunit.test)('test method getRhumb for MultiPolygon with part', function (assert) {
    //Arrange
    var testLiseString = {
      type: 'Feature',
      geometry: {
        type: 'MultiPolygon',
        coordinates: [[[[3, 7], [3, 3], [8, 3], [8, 7], [3, 7]]], [[[9, 3], [9, 2], [10, 2], [10, 3], [9, 3]]]]
      }
    };

    var resObj = [{
      type: 'Polygon',
      startPoint: [3, 7],
      crs: 'EPSG:4326',
      skip: 0,
      hole: false,
      points: [{
        rhumb: 'SE',
        angle: 0,
        distance: 4
      }, {
        rhumb: 'SE',
        angle: 90,
        distance: 5
      }, {
        rhumb: 'NE',
        angle: 0,
        distance: 4
      }, {
        rhumb: 'NW',
        angle: 90,
        distance: 5
      }]
    }, {
      type: 'Polygon',
      startPoint: [9, 3],
      crs: 'EPSG:4326',
      skip: 0,
      hole: false,
      points: [{
        rhumb: 'SE',
        angle: 0,
        distance: 1
      }, {
        rhumb: 'SE',
        angle: 90,
        distance: 1
      }, {
        rhumb: 'NE',
        angle: 0,
        distance: 1
      }, {
        rhumb: 'NW',
        angle: 90,
        distance: 1
      }]
    }];
    var subject = mapApiMixinObject.create();

    //Act
    var rhumbs = subject.getRhumb(testLiseString, 'EPSG:4326');

    //Assert
    assert.deepEqual(rhumbs, resObj);
  });

  (0, _qunit.test)('test method getRhumb for MultiPolygon with part and hole', function (assert) {
    //Arrange
    var testLiseString = {
      type: 'Feature',
      geometry: {
        type: 'MultiPolygon',
        coordinates: [[[[3, 7], [3, 3], [8, 3], [8, 7], [3, 7]], [[4, 4], [5, 4], [5, 5], [4, 5], [4, 4]]], [[[9, 3], [9, 2], [10, 2], [10, 3], [9, 3]]]]
      }
    };

    var resObj = [{
      type: 'Polygon',
      startPoint: [3, 7],
      crs: 'EPSG:4326',
      skip: 0,
      hole: false,
      points: [{
        rhumb: 'SE',
        angle: 0,
        distance: 4
      }, {
        rhumb: 'SE',
        angle: 90,
        distance: 5
      }, {
        rhumb: 'NE',
        angle: 0,
        distance: 4
      }, {
        rhumb: 'NW',
        angle: 90,
        distance: 5
      }]
    }, {
      type: 'Polygon',
      startPoint: [4, 4],
      crs: 'EPSG:4326',
      skip: 0,
      hole: true,
      points: [{
        rhumb: 'SE',
        angle: 90,
        distance: 1
      }, {
        rhumb: 'NE',
        angle: 0,
        distance: 1
      }, {
        rhumb: 'NW',
        angle: 90,
        distance: 1
      }, {
        rhumb: 'SE',
        angle: 0,
        distance: 1
      }]
    }, {
      type: 'Polygon',
      startPoint: [9, 3],
      crs: 'EPSG:4326',
      skip: 0,
      hole: false,
      points: [{
        rhumb: 'SE',
        angle: 0,
        distance: 1
      }, {
        rhumb: 'SE',
        angle: 90,
        distance: 1
      }, {
        rhumb: 'NE',
        angle: 0,
        distance: 1
      }, {
        rhumb: 'NW',
        angle: 90,
        distance: 1
      }]
    }];
    var subject = mapApiMixinObject.create();

    //Act
    var rhumbs = subject.getRhumb(testLiseString, 'EPSG:4326');

    //Assert
    assert.deepEqual(rhumbs, resObj);
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-get-rhumb-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/flexberry-map-model-api-get-rhumb-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/flexberry-map-model-api-get-rhumb-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-get-rhumb-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/flexberry-map-model-api-get-rhumb-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/flexberry-map-model-api-get-rhumb-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-savelayer-test', ['exports', 'ember', 'ember-flexberry-gis/mixins/flexberry-map-model-api-savelayer', 'qunit'], function (exports, _ember, _emberFlexberryGisMixinsFlexberryMapModelApiSavelayer, _qunit) {

  (0, _qunit.module)('Unit | Mixin | flexberry map model api savelayer');

  // Replace this with your real tests.
  (0, _qunit.test)('it works', function (assert) {
    var FlexberryMapModelApiSavelayerObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApiSavelayer['default']);
    var subject = FlexberryMapModelApiSavelayerObject.create();
    assert.ok(subject);
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-savelayer-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/flexberry-map-model-api-savelayer-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/flexberry-map-model-api-savelayer-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-savelayer-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/flexberry-map-model-api-savelayer-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/flexberry-map-model-api-savelayer-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-set-visibilitty-test', ['exports', 'ember', 'qunit', 'ember-flexberry-gis/mixins/flexberry-map-model-api', 'sinon'], function (exports, _ember, _qunit, _emberFlexberryGisMixinsFlexberryMapModelApi, _sinon) {

  (0, _qunit.module)('Unit | Mixin | test method setVisibility ');

  var mapApiMixinObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApi['default']);

  var layerModel = _ember['default'].Component.extend({
    visibility: false
  });

  (0, _qunit.test)('Test visibility = true', function (assert) {
    //Arrange
    assert.expect(9);
    var firstLayer = layerModel.create({
      id: '1'
    });
    var secondLayer = layerModel.create({
      id: '2'
    });
    var map = L.map(document.createElement('div'), {
      center: [51.505, -0.09],
      zoom: 13
    });
    map.on('flexberry-map:moveend', function () {});
    var done = assert.async(1);
    var subject = mapApiMixinObject.create({
      mapApi: {
        getFromApi: function getFromApi() {
          return map;
        }
      },
      mapLayer: _ember['default'].A([firstLayer, secondLayer])
    });
    var mapFireSpy = _sinon['default'].stub(map, 'fire', function (name, e) {
      e.results = _ember['default'].A([{ promise: _ember['default'].RSVP.resolve() }]);
    });
    var mapLayerFindSpy = _sinon['default'].spy(subject.mapLayer, 'findBy');

    //Act
    var result = subject._setVisibility(['1'], true);

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise, 'Equals result = Promise');
    result.then(function (res) {
      assert.equal(res, 'success', 'Check result message');
      assert.equal(firstLayer.get('visibility'), true, 'Check firstLayer visibility');
      assert.equal(secondLayer.get('visibility'), false, 'Check secondLayer visibility');
      assert.equal(mapFireSpy.callCount, 1, 'Check call count method fire on map');
      assert.equal(mapFireSpy.args[0][0], 'flexberry-map:moveend', 'Check first argument method fire on map');
      assert.equal(mapLayerFindSpy.callCount, 1, 'Check call count method findBy on Array');
      assert.equal(mapLayerFindSpy.args[0][0], 'id', 'Check first argument method findBy on Array');
      assert.equal(mapLayerFindSpy.args[0][1], '1', 'Check second argument method findBy on Array');
      done();
      mapFireSpy.restore();
      mapLayerFindSpy.restore();
    });
  });

  (0, _qunit.test)('Test visibility = false', function (assert) {
    //Arrange
    assert.expect(10);
    var firstLayer = layerModel.create({
      id: '1'
    });
    var secondLayer = layerModel.create({
      id: '2'
    });
    var map = L.map(document.createElement('div'), {
      center: [51.505, -0.09],
      zoom: 13
    });
    map.on('flexberry-map:moveend', function () {});
    var done = assert.async(1);
    var subject = mapApiMixinObject.create({
      mapApi: {
        getFromApi: function getFromApi() {
          return map;
        }
      },
      mapLayer: _ember['default'].A([firstLayer, secondLayer])
    });
    var mapFireSpy = _sinon['default'].stub(map, 'fire', function (name, e) {
      e.results = _ember['default'].A([{ promise: _ember['default'].RSVP.resolve() }]);
    });
    var mapLayerFindSpy = _sinon['default'].spy(subject.mapLayer, 'findBy');

    //Act
    var result = subject._setVisibility(['1', '2']);

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise, 'Equals result = Promise');
    result.then(function (res) {
      assert.equal(res, 'success', 'Check result message');
      assert.equal(firstLayer.get('visibility'), false, 'Check firstLayer visibility');
      assert.equal(secondLayer.get('visibility'), false, 'Check secondLayer visibility');
      assert.equal(mapFireSpy.callCount, 0, 'Check call count method fire on map');
      assert.equal(mapLayerFindSpy.callCount, 2, 'Check call count method findBy on Array');
      assert.equal(mapLayerFindSpy.args[0][0], 'id', 'Check first argument method findBy on Array');
      assert.equal(mapLayerFindSpy.args[0][1], '1', 'Check second argument method findBy on Array');
      assert.equal(mapLayerFindSpy.args[1][0], 'id', 'Check first argument method findBy on Array');
      assert.equal(mapLayerFindSpy.args[1][1], '2', 'Check second argument method findBy on Array');
      done();
      mapFireSpy.restore();
      mapLayerFindSpy.restore();
    });
  });

  (0, _qunit.test)('Test not founded layers', function (assert) {
    //Arrange
    assert.expect(8);
    var map = L.map(document.createElement('div'), {
      center: [51.505, -0.09],
      zoom: 13
    });
    map.on('flexberry-map:moveend', function () {});
    var done = assert.async(1);
    var subject = mapApiMixinObject.create({
      mapApi: {
        getFromApi: function getFromApi() {
          return map;
        }
      },
      mapLayer: _ember['default'].A([])
    });
    var mapFireSpy = _sinon['default'].stub(map, 'fire', function (name, e) {
      e.results = _ember['default'].A([{ promise: _ember['default'].RSVP.resolve() }]);
    });
    var mapLayerFindSpy = _sinon['default'].spy(subject.mapLayer, 'findBy');

    //Act
    var result = subject._setVisibility(['3', '4'], true);

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise, 'Equals result = Promise');
    result['catch'](function (res) {
      assert.equal(res, 'Layer \'3\' not found.', 'Check result message');
      assert.equal(mapFireSpy.callCount, 0, 'Check call count method fire on map');
      assert.equal(mapLayerFindSpy.callCount, 2, 'Check call count method findBy on Array');
      assert.equal(mapLayerFindSpy.args[0][0], 'id', 'Check first argument method findBy on Array');
      assert.equal(mapLayerFindSpy.args[0][1], '3', 'Check second argument method findBy on Array');
      assert.equal(mapLayerFindSpy.args[1][0], 'id', 'Check first argument method findBy on Array');
      assert.equal(mapLayerFindSpy.args[1][1], '4', 'Check second argument method findBy on Array');
      done();
      mapFireSpy.restore();
      mapLayerFindSpy.restore();
    });
  });

  (0, _qunit.test)('Test array is empty', function (assert) {
    //Arrange
    assert.expect(4);
    var map = L.map(document.createElement('div'), {
      center: [51.505, -0.09],
      zoom: 13
    });
    map.on('flexberry-map:moveend', function () {});
    var done = assert.async(1);
    var subject = mapApiMixinObject.create({
      mapApi: {
        getFromApi: function getFromApi() {
          return map;
        }
      },
      mapLayer: _ember['default'].A([])
    });
    var mapFireSpy = _sinon['default'].stub(map, 'fire', function (name, e) {
      e.results = _ember['default'].A([{ promise: _ember['default'].RSVP.resolve() }]);
    });
    var mapLayerFindSpy = _sinon['default'].spy(subject.mapLayer, 'findBy');

    //Act
    var result = subject._setVisibility([], true);

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise, 'Equals result = Promise');
    result['catch'](function (res) {
      assert.equal(res, 'all layerIds is not found', 'Check result message');
      assert.equal(mapFireSpy.callCount, 0, 'Check call count method fire on map');
      assert.equal(mapLayerFindSpy.callCount, 0, 'Check call count method findBy on Array');
      done();
      mapFireSpy.restore();
      mapLayerFindSpy.restore();
    });
  });

  (0, _qunit.test)('Test parametr is not a array', function (assert) {
    //Arrange
    assert.expect(2);
    var done = assert.async(1);
    var subject = mapApiMixinObject.create();

    //Act
    var result = subject._setVisibility();

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise, 'Equals result = Promise');
    result['catch'](function (res) {
      assert.equal(res, 'Parametr is not a Array', 'Check result message');
      done();
    });
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-set-visibilitty-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/flexberry-map-model-api-set-visibilitty-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/flexberry-map-model-api-set-visibilitty-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-set-visibilitty-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/flexberry-map-model-api-set-visibilitty-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/flexberry-map-model-api-set-visibilitty-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-set-visibility-objects-test', ['exports', 'ember', 'qunit', 'ember-flexberry-gis/mixins/flexberry-map-model-api', 'sinon', 'ember-flexberry-gis/layers/-private/vector'], function (exports, _ember, _qunit, _emberFlexberryGisMixinsFlexberryMapModelApi, _sinon, _emberFlexberryGisLayersPrivateVector) {

  (0, _qunit.module)('Unit | Mixin | test method setVisibilityObjects');

  var mapApiMixinObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApi['default']);

  var layerModel = _ember['default'].A({
    settingsAsObject: {
      labelSettings: {
        signMapObjects: true
      }
    }
  });
  var _labelsLayer = L.featureGroup();
  var leafletObject = L.featureGroup();
  leafletObject.options = {
    showExisting: false,
    continueLoading: false
  };
  leafletObject._labelsLayer = _labelsLayer;
  var firstTestLayer = L.polygon([[1, 2], [4, 2], [4, 4], [1, 2]]).addTo(leafletObject);
  firstTestLayer.id = '1';
  var secondTestLayer = L.polygon([[10, 20], [40, 20], [40, 40], [10, 20]]).addTo(leafletObject);
  secondTestLayer.id = '2';
  var thirdTestLayer = L.polygon([[0.1, 0.2], [0.4, 0.2], [0.4, 0.4], [0.1, 0.2]]).addTo(leafletObject);
  thirdTestLayer.id = '3';
  var firstTestLabelLayer = L.marker([1, 2]).addTo(_labelsLayer);
  firstTestLabelLayer.id = '1';
  var secondTestLabelLayer = L.marker([40, 20]).addTo(_labelsLayer);
  secondTestLabelLayer.id = '2';
  var thirdTestLabelLayer = L.marker([20, 40]).addTo(_labelsLayer);
  thirdTestLabelLayer.id = '3';

  (0, _qunit.test)('Test to addLayers to map (visibility = true)', function (assert) {
    //Arrange
    assert.expect(9);
    var map = L.map(document.createElement('div'), {
      center: [51.505, -0.09],
      zoom: 13
    });
    var done = assert.async(1);
    var subject = mapApiMixinObject.create({
      _getModelLeafletObject: function _getModelLeafletObject() {
        return [layerModel, leafletObject];
      },
      _getTypeLayer: function _getTypeLayer() {
        return new _emberFlexberryGisLayersPrivateVector['default']();
      },
      mapApi: {
        getFromApi: function getFromApi() {
          return map;
        }
      },
      _getLayerFeatureId: function _getLayerFeatureId(layer, shape) {
        return shape.id;
      },
      _getModelLayerFeature: function _getModelLayerFeature() {
        return _ember['default'].RSVP.resolve();
      }
    });
    var getModelLeafletObjSpy = _sinon['default'].spy(subject, '_getModelLeafletObject');
    var getModelLayerFeatureSpy = _sinon['default'].spy(subject, '_getModelLayerFeature');
    var mapAddSpy = _sinon['default'].spy(map, 'addLayer');

    //Act
    var result = subject._setVisibilityObjects('1', ['1', '2'], true);

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise, 'Equals result = Promise');
    result.then(function (res) {
      assert.equal(res, 'sucsess', 'Check result message');
      assert.equal(Object.values(map._layers).length, 5, 'Check count layers on Map');
      assert.equal(mapAddSpy.callCount, 5, 'Check call count to method addLayer');
      assert.equal(getModelLeafletObjSpy.callCount, 1, 'Check call count to method _getModelLeafletObject');
      assert.equal(getModelLeafletObjSpy.args[0][0], '1', 'Check call first arg to method _getModelLeafletObject');
      assert.equal(getModelLayerFeatureSpy.callCount, 1, 'Check call count to method _getModelLayerFeature');
      assert.equal(getModelLayerFeatureSpy.args[0][0], '1', 'Check call first arg to method _getModelLayerFeature');
      assert.deepEqual(getModelLayerFeatureSpy.args[0][1], ['1', '2'], 'Check call second arg to method _getModelLayerFeature');
      done();
      getModelLeafletObjSpy.restore();
      getModelLayerFeatureSpy.restore();
      mapAddSpy.restore();
    });
  });

  (0, _qunit.test)('Test to removeLayers to map (visibility = false)', function (assert) {
    //Arrange
    assert.expect(7);
    var map = L.map(document.createElement('div'), {
      center: [51.505, -0.09],
      zoom: 13
    });
    var done = assert.async(1);
    map.addLayer(leafletObject);
    map.addLayer(leafletObject._labelsLayer);
    var subject = mapApiMixinObject.create({
      _getModelLeafletObject: function _getModelLeafletObject() {
        return [layerModel, leafletObject];
      },
      _getTypeLayer: function _getTypeLayer() {
        return new _emberFlexberryGisLayersPrivateVector['default']();
      },
      mapApi: {
        getFromApi: function getFromApi() {
          return map;
        }
      },
      _getLayerFeatureId: function _getLayerFeatureId(layer, shape) {
        return shape.id;
      },
      _getModelLayerFeature: function _getModelLayerFeature() {
        return _ember['default'].RSVP.resolve();
      }
    });
    var getModelLeafletObjSpy = _sinon['default'].spy(subject, '_getModelLeafletObject');
    var getModelLayerFeatureSpy = _sinon['default'].spy(subject, '_getModelLayerFeature');
    var mapRemoveSpy = _sinon['default'].spy(map, 'removeLayer');

    //Act
    var result = subject._setVisibilityObjects('1', ['1', '2'], false);

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise, 'Equals result = Promise');
    result.then(function (res) {
      assert.equal(res, 'sucsess', 'Check result message');
      assert.equal(Object.values(map._layers).length, 5, 'Check count layers on Map');
      assert.equal(mapRemoveSpy.callCount, 4, 'Check call count to method removeLayer');
      assert.equal(getModelLeafletObjSpy.callCount, 1, 'Check call count to method _getModelLeafletObject');
      assert.equal(getModelLeafletObjSpy.args[0][0], '1', 'Check call first arg to method _getModelLeafletObject');
      assert.equal(getModelLayerFeatureSpy.callCount, 0, 'Check call count to method _getModelLayerFeature');
      done();
      getModelLeafletObjSpy.restore();
      getModelLayerFeatureSpy.restore();
      mapRemoveSpy.restore();
    });
  });

  (0, _qunit.test)('Test to check fail message', function (assert) {
    //Arrange
    assert.expect(6);
    var map = L.map(document.createElement('div'), {
      center: [51.505, -0.09],
      zoom: 13
    });
    var done = assert.async(1);
    leafletObject.options.continueLoading = true;
    var subject = mapApiMixinObject.create({
      _getModelLeafletObject: function _getModelLeafletObject() {
        return [layerModel, leafletObject];
      },
      _getTypeLayer: function _getTypeLayer() {
        return new _emberFlexberryGisLayersPrivateVector['default']();
      },
      mapApi: {
        getFromApi: function getFromApi() {
          return map;
        }
      },
      _getLayerFeatureId: function _getLayerFeatureId(layer, shape) {
        return shape.id;
      },
      _getModelLayerFeature: function _getModelLayerFeature() {
        return _ember['default'].RSVP.resolve();
      }
    });
    var getModelLeafletObjSpy = _sinon['default'].spy(subject, '_getModelLeafletObject');
    var getModelLayerFeatureSpy = _sinon['default'].spy(subject, '_getModelLayerFeature');
    var mapRemoveSpy = _sinon['default'].spy(map, 'removeLayer');

    //Act
    var result = subject._setVisibilityObjects('1', ['1', '2'], true);

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise, 'Equals result = Promise');
    result.then(function () {})['catch'](function (res) {
      assert.equal(res, 'Not working to layer with continueLoading', 'Check result message');
      assert.equal(Object.values(map._layers).length, 0, 'Check count layers on Map');
      assert.equal(mapRemoveSpy.callCount, 0, 'Check call count to method removeLayer');
      assert.equal(getModelLeafletObjSpy.callCount, 1, 'Check call count to method _getModelLeafletObject');
      assert.equal(getModelLayerFeatureSpy.callCount, 0, 'Check call count to method _getModelLayerFeature');
      done();
      leafletObject.options.continueLoading = false;
      getModelLeafletObjSpy.restore();
      getModelLayerFeatureSpy.restore();
      mapRemoveSpy.restore();
    });
  });

  (0, _qunit.test)('Map doesn\'t layers and visibility = false', function (assert) {
    //Arrange
    assert.expect(6);
    var map = L.map(document.createElement('div'), {
      center: [51.505, -0.09],
      zoom: 13
    });
    var done = assert.async(1);
    var subject = mapApiMixinObject.create({
      _getModelLeafletObject: function _getModelLeafletObject() {
        return [layerModel, leafletObject];
      },
      _getTypeLayer: function _getTypeLayer() {
        return new _emberFlexberryGisLayersPrivateVector['default']();
      },
      mapApi: {
        getFromApi: function getFromApi() {
          return map;
        }
      },
      _getLayerFeatureId: function _getLayerFeatureId(layer, shape) {
        return shape.id;
      },
      _getModelLayerFeature: function _getModelLayerFeature() {
        return _ember['default'].RSVP.resolve();
      }
    });
    var getModelLeafletObjSpy = _sinon['default'].spy(subject, '_getModelLeafletObject');
    var getModelLayerFeatureSpy = _sinon['default'].spy(subject, '_getModelLayerFeature');
    var mapRemoveSpy = _sinon['default'].spy(map, 'removeLayer');

    //Act
    var result = subject._setVisibilityObjects('1', ['1', '2'], false);

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise, 'Equals result = Promise');
    result.then(function (res) {
      assert.equal(res, 'sucsess', 'Check result message');
      assert.equal(Object.values(map._layers).length, 0, 'Check count layers on Map');
      assert.equal(mapRemoveSpy.callCount, 4, 'Check call count to method removeLayer');
      assert.equal(getModelLeafletObjSpy.callCount, 1, 'Check call count to method _getModelLeafletObject');
      assert.equal(getModelLayerFeatureSpy.callCount, 0, 'Check call count to method _getModelLayerFeature');
      done();
      getModelLeafletObjSpy.restore();
      getModelLayerFeatureSpy.restore();
      mapRemoveSpy.restore();
    });
  });

  (0, _qunit.test)('Map doesn\'t layers and visibility = false', function (assert) {
    //Arrange
    assert.expect(9);
    var map = L.map(document.createElement('div'), {
      center: [51.505, -0.09],
      zoom: 13
    });
    map.addLayer(leafletObject);
    map.addLayer(leafletObject._labelsLayer);
    var done = assert.async(1);
    var subject = mapApiMixinObject.create({
      _getModelLeafletObject: function _getModelLeafletObject() {
        return [layerModel, leafletObject];
      },
      _getTypeLayer: function _getTypeLayer() {
        return new _emberFlexberryGisLayersPrivateVector['default']();
      },
      mapApi: {
        getFromApi: function getFromApi() {
          return map;
        }
      },
      _getLayerFeatureId: function _getLayerFeatureId(layer, shape) {
        return shape.id;
      },
      _getModelLayerFeature: function _getModelLayerFeature() {
        return _ember['default'].RSVP.resolve();
      }
    });
    var getModelLeafletObjSpy = _sinon['default'].spy(subject, '_getModelLeafletObject');
    var getModelLayerFeatureSpy = _sinon['default'].spy(subject, '_getModelLayerFeature');
    var mapAddSpy = _sinon['default'].spy(map, 'addLayer');

    //Act
    var result = subject._setVisibilityObjects('1', ['1', '2'], true);

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise, 'Equals result = Promise');
    result.then(function (res) {
      assert.equal(res, 'sucsess', 'Check result message');
      assert.equal(Object.values(map._layers).length, 9, 'Check count layers on Map');
      assert.equal(mapAddSpy.callCount, 4, 'Check call count to method addLayer');
      assert.equal(getModelLeafletObjSpy.callCount, 1, 'Check call count to method _getModelLeafletObject');
      assert.equal(getModelLeafletObjSpy.args[0][0], '1', 'Check call first arg to method _getModelLeafletObject');
      assert.equal(getModelLayerFeatureSpy.callCount, 1, 'Check call count to method _getModelLayerFeature');
      assert.equal(getModelLayerFeatureSpy.args[0][0], '1', 'Check call first arg to method _getModelLayerFeature');
      assert.deepEqual(getModelLayerFeatureSpy.args[0][1], ['1', '2'], 'Check call second arg to method _getModelLayerFeature');
      done();
      getModelLeafletObjSpy.restore();
      getModelLayerFeatureSpy.restore();
      mapAddSpy.restore();
    });
  });

  (0, _qunit.test)('Test to check success message \'showExisting\'', function (assert) {
    //Arrange
    assert.expect(9);
    var map = L.map(document.createElement('div'), {
      center: [51.505, -0.09],
      zoom: 13
    });
    var done = assert.async(1);
    leafletObject.options.showExisting = true;
    var subject = mapApiMixinObject.create({
      _getModelLeafletObject: function _getModelLeafletObject() {
        return [layerModel, leafletObject];
      },
      _getTypeLayer: function _getTypeLayer() {
        return new _emberFlexberryGisLayersPrivateVector['default']();
      },
      mapApi: {
        getFromApi: function getFromApi() {
          return map;
        }
      },
      _getLayerFeatureId: function _getLayerFeatureId(layer, shape) {
        return shape.id;
      },
      _getModelLayerFeature: function _getModelLayerFeature() {
        return _ember['default'].RSVP.resolve();
      }
    });
    var getModelLeafletObjSpy = _sinon['default'].spy(subject, '_getModelLeafletObject');
    var getModelLayerFeatureSpy = _sinon['default'].spy(subject, '_getModelLayerFeature');
    var mapAddSpy = _sinon['default'].spy(map, 'addLayer');

    //Act
    var result = subject._setVisibilityObjects('1', ['1', '2'], true);

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise, 'Equals result = Promise');
    result.then(function (res) {
      assert.equal(res, 'sucsess', 'Check result message');
      assert.equal(Object.values(map._layers).length, 5, 'Check count layers on Map');
      assert.equal(mapAddSpy.callCount, 5, 'Check call count to method addLayer');
      assert.equal(getModelLeafletObjSpy.callCount, 1, 'Check call count to method _getModelLeafletObject');
      assert.equal(getModelLeafletObjSpy.args[0][0], '1', 'Check call first arg to method _getModelLeafletObject');
      assert.equal(getModelLayerFeatureSpy.callCount, 1, 'Check call count to method _getModelLayerFeature');
      assert.equal(getModelLayerFeatureSpy.args[0][0], '1', 'Check call first arg to method _getModelLayerFeature');
      assert.deepEqual(getModelLayerFeatureSpy.args[0][1], ['1', '2'], 'Check call second arg to method _getModelLayerFeature');
      done();
      leafletObject.options.showExisting = false;
      getModelLeafletObjSpy.restore();
      getModelLayerFeatureSpy.restore();
      mapAddSpy.restore();
    });
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-set-visibility-objects-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/flexberry-map-model-api-set-visibility-objects-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/flexberry-map-model-api-set-visibility-objects-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-set-visibility-objects-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/flexberry-map-model-api-set-visibility-objects-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/flexberry-map-model-api-set-visibility-objects-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-test', ['exports', 'ember', 'qunit', 'ember-flexberry-gis/mixins/flexberry-map-model-api', 'sinon'], function (exports, _ember, _qunit, _emberFlexberryGisMixinsFlexberryMapModelApi, _sinon) {

  (0, _qunit.module)('Unit | Mixin | flexberry map model api test');

  var mapApiMixinObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApi['default']);

  // Replace this with your real tests.
  (0, _qunit.test)('it works FlexberryMapModelApiMixin', function (assert) {
    var subject = mapApiMixinObject.create();
    assert.ok(subject);
  });

  (0, _qunit.test)('uploadFile should send post request with fileName and data to backend and return Ember.RSVP.Promise', function (assert) {
    assert.expect(4);
    var done = assert.async(1);
    var server = _sinon['default'].fakeServer.create();
    server.respondWith('uploadfileresponse');
    var configStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    configStub.returns({
      resolveRegistration: function resolveRegistration() {
        return {
          'APP': {
            'backendUrl': 'stubbackend'
          }
        };
      }
    });

    var subject = mapApiMixinObject.create();
    var payload = { 'name': 'testFile' };

    var result = subject.uploadFile(payload);
    server.respond();

    assert.ok(result instanceof _ember['default'].RSVP.Promise);
    assert.deepEqual(server.requests[0].requestBody, payload);
    assert.equal(server.requests[0].url, 'stubbackend/controls/FileUploaderHandler.ashx?FileName=testFile');
    result.then(function (e) {
      assert.equal(e, 'uploadfileresponse');
      done();
    });

    configStub.restore();
    server.restore();
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/flexberry-map-model-api-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/flexberry-map-model-api-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/flexberry-map-model-api-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/flexberry-map-model-api-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-visualedit-test', ['exports', 'ember', 'ember-flexberry-gis/mixins/flexberry-map-model-api-visualedit', 'qunit'], function (exports, _ember, _emberFlexberryGisMixinsFlexberryMapModelApiVisualedit, _qunit) {

  (0, _qunit.module)('Unit | Mixin | flexberry map model api visualedit');

  // Replace this with your real tests.
  (0, _qunit.test)('it works', function (assert) {
    var FlexberryMapModelApiVisualeditObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApiVisualedit['default']);
    var subject = FlexberryMapModelApiVisualeditObject.create();
    assert.ok(subject);
  });

  (0, _qunit.test)('one', function (assert) {
    assert.ok(true);
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-visualedit-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/flexberry-map-model-api-visualedit-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/flexberry-map-model-api-visualedit-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/flexberry-map-model-api-visualedit-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/flexberry-map-model-api-visualedit-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/flexberry-map-model-api-visualedit-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/flexberry_map_model_api_show_and_hide_test', ['exports', 'ember', 'qunit', 'ember-flexberry-gis/mixins/flexberry-map-model-api', 'sinon', 'ember-flexberry-gis/layers/-private/vector'], function (exports, _ember, _qunit, _emberFlexberryGisMixinsFlexberryMapModelApi, _sinon, _emberFlexberryGisLayersPrivateVector) {

  (0, _qunit.module)('Unit | Mixin | test api show and hide layers');

  var arrayFindBy = function arrayFindBy(prop, value) {
    return this.filter(function (elem) {
      if (elem.hasOwnProperty(prop)) {
        return elem[prop] === value;
      }
    })[0];
  };

  var mapApiMixinObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApi['default']);

  var _labelsLayer = L.featureGroup();
  var leafletObject = L.featureGroup();
  leafletObject.options = {
    showExisting: false,
    continueLoading: false
  };
  leafletObject._labelsLayer = _labelsLayer;
  var firstTestLayer = L.polygon([[1, 2], [4, 2], [4, 4], [1, 2]]).addTo(leafletObject);
  firstTestLayer.id = '1';
  var secondTestLayer = L.polygon([[10, 20], [40, 20], [40, 40], [10, 20]]).addTo(leafletObject);
  secondTestLayer.id = '2';
  var thirdTestLayer = L.polygon([[0.1, 0.2], [0.4, 0.2], [0.4, 0.4], [0.1, 0.2]]).addTo(leafletObject);
  thirdTestLayer.id = '3';
  var firstTestLabelLayer = L.marker([1, 2]).addTo(_labelsLayer);
  firstTestLabelLayer.id = '1';
  var secondTestLabelLayer = L.marker([40, 20]).addTo(_labelsLayer);
  secondTestLabelLayer.id = '2';
  var thirdTestLabelLayer = L.marker([20, 40]).addTo(_labelsLayer);
  thirdTestLabelLayer.id = '3';

  var layer1 = _ember['default'].Object.create({
    id: '1',
    visibility: false,
    _leafletObject: leafletObject,
    settingsAsObject: {
      labelSettings: {
        signMapObjects: true
      }
    }
  });
  var layer2 = _ember['default'].Object.create({
    id: '2',
    visibility: false,
    _leafletObject: leafletObject,
    settingsAsObject: {
      labelSettings: {
        signMapObjects: true
      }
    }
  });
  var maplayers = _ember['default'].A([layer1, layer2]);

  (0, _qunit.test)('test method showLayers with continueLoading = false', function (assert) {
    //Arrange
    assert.expect(6);
    var done = assert.async(1);

    var map = L.map(document.createElement('div'), {
      center: [51.505, -0.09],
      zoom: 13
    });

    var subject = mapApiMixinObject.create({
      _getTypeLayer: function _getTypeLayer() {
        return new _emberFlexberryGisLayersPrivateVector['default']();
      },
      mapApi: {
        getFromApi: function getFromApi() {
          return map;
        }
      },
      mapLayer: maplayers
    });

    leafletObject.options.continueLoading = false;
    var leafletMapFireStub = _sinon['default'].stub(map, 'fire');
    leafletMapFireStub.returns(_ember['default'].RSVP.resolve());
    var findByStub = _sinon['default'].stub(subject.mapLayer, 'findBy', arrayFindBy);

    //Act
    var result = subject.showLayers(['1']);

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise);
    result.then(function (res) {
      assert.equal(res, 'success');
      assert.equal(findByStub.callCount, 1);
      assert.equal(findByStub.args[0][0], 'id');
      assert.equal(findByStub.args[0][1], '1');
      assert.equal(leafletMapFireStub.callCount, 1);
      done();
      leafletMapFireStub.restore();
      findByStub.restore();
    });
  });

  (0, _qunit.test)('test method showLayers with continueLoading = true', function (assert) {
    //Arrange
    assert.expect(7);
    var done = assert.async(1);

    var map = L.map(document.createElement('div'), {
      center: [51.505, -0.09],
      zoom: 13
    });

    var subject = mapApiMixinObject.create({
      _getTypeLayer: function _getTypeLayer() {
        return new _emberFlexberryGisLayersPrivateVector['default']();
      },
      mapApi: {
        getFromApi: function getFromApi() {
          return map;
        }
      },
      mapLayer: maplayers
    });

    leafletObject.options.continueLoading = true;
    var leafletMapFireStub = _sinon['default'].stub(map, 'fire');
    leafletMapFireStub.returns(_ember['default'].RSVP.resolve());
    var findByStub = _sinon['default'].stub(subject.mapLayer, 'findBy', arrayFindBy);

    //Act
    var result = subject.showLayers(['1']);

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise);
    result.then(function (res) {
      assert.equal(res, 'success');
      assert.equal(findByStub.callCount, 1);
      assert.equal(findByStub.args[0][0], 'id');
      assert.equal(findByStub.args[0][1], '1');
      assert.equal(leafletMapFireStub.callCount, 1);
      assert.equal(leafletMapFireStub.args[0][0], 'flexberry-map:moveend');
      done();
      leafletMapFireStub.restore();
      findByStub.restore();
    });
  });

  (0, _qunit.test)('test method showAllLayerObjects with continueLoading = false', function (assert) {
    //Arrange
    assert.expect(13);
    var done = assert.async(1);

    var map = L.map(document.createElement('div'), {
      center: [51.505, -0.09],
      zoom: 13
    });

    var subject = mapApiMixinObject.create({
      _getTypeLayer: function _getTypeLayer() {
        return new _emberFlexberryGisLayersPrivateVector['default']();
      },
      mapApi: {
        getFromApi: function getFromApi() {
          return map;
        }
      },
      _getModelLayerFeature: function _getModelLayerFeature() {
        leafletObject.addLayer(firstTestLayer);
        leafletObject.addLayer(secondTestLayer);
        leafletObject.addLayer(thirdTestLayer);
        return _ember['default'].RSVP.resolve([null, null, [firstTestLayer, secondTestLayer, thirdTestLayer]]);
      },
      mapLayer: maplayers
    });
    leafletObject.options.showExisting = false;
    leafletObject.options.continueLoading = false;
    var getModelLayerFeatureSpy = _sinon['default'].spy(subject, '_getModelLayerFeature');
    var leafletMapFireStub = _sinon['default'].stub(map, 'fire');
    leafletMapFireStub.withArgs('flexberry-map:moveend').returns(_ember['default'].RSVP.resolve());
    var mapAddSpy = _sinon['default'].spy(map, 'addLayer');
    var mapRemoveSpy = _sinon['default'].spy(map, 'removeLayer');
    var leafletObjectClearLayersSpy = _sinon['default'].spy(leafletObject, 'clearLayers');
    var findByStub = _sinon['default'].stub(subject.mapLayer, 'findBy', arrayFindBy);

    //Act
    var result = subject.showAllLayerObjects('1');

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise);
    result.then(function (res) {
      assert.equal(res, 'success');
      assert.equal(getModelLayerFeatureSpy.callCount, 1);
      assert.equal(getModelLayerFeatureSpy.args[0][0], '1');
      assert.deepEqual(getModelLayerFeatureSpy.args[0][1], null);
      assert.equal(leafletMapFireStub.callCount, 8);
      assert.notEqual(leafletMapFireStub.args[0][0], 'flexberry-map:moveend');
      assert.equal(mapAddSpy.callCount, 8);
      assert.equal(mapRemoveSpy.callCount, 0);
      assert.equal(findByStub.callCount, 1);
      assert.equal(findByStub.args[0][0], 'id');
      assert.equal(findByStub.args[0][1], '1');
      assert.equal(leafletObjectClearLayersSpy.callCount, 1);
      done();
      getModelLayerFeatureSpy.restore();
      leafletMapFireStub.restore();
      mapAddSpy.restore();
      mapRemoveSpy.restore();
      leafletObjectClearLayersSpy.restore();
      findByStub.restore();
    });
  });

  (0, _qunit.test)('test method showAllLayerObjects with continueLoading = true', function (assert) {
    //Arrange
    assert.expect(11);
    var done = assert.async(1);

    var map = L.map(document.createElement('div'), {
      center: [51.505, -0.09],
      zoom: 13
    });

    var subject = mapApiMixinObject.create({
      _getTypeLayer: function _getTypeLayer() {
        return new _emberFlexberryGisLayersPrivateVector['default']();
      },
      mapApi: {
        getFromApi: function getFromApi() {
          return map;
        }
      },
      _getModelLayerFeature: function _getModelLayerFeature() {
        leafletObject.addLayer(firstTestLayer);
        leafletObject.addLayer(secondTestLayer);
        leafletObject.addLayer(thirdTestLayer);
        return _ember['default'].RSVP.resolve([null, null, [firstTestLayer, secondTestLayer, thirdTestLayer]]);
      },
      mapLayer: maplayers
    });

    leafletObject.options.continueLoading = true;
    var getModelLayerFeatureSpy = _sinon['default'].spy(subject, '_getModelLayerFeature');
    var leafletMapFireStub = _sinon['default'].stub(map, 'fire');
    leafletMapFireStub.withArgs('flexberry-map:moveend').returns(_ember['default'].RSVP.resolve());
    var mapAddSpy = _sinon['default'].spy(map, 'addLayer');
    var mapRemoveSpy = _sinon['default'].spy(map, 'removeLayer');
    var leafletObjectClearLayersSpy = _sinon['default'].spy(leafletObject, 'clearLayers');
    var findByStub = _sinon['default'].stub(subject.mapLayer, 'findBy', arrayFindBy);

    //Act
    var result = subject.showAllLayerObjects('1');

    //Assert
    assert.ok(result instanceof _ember['default'].RSVP.Promise);
    result.then(function (res) {
      assert.equal(res, 'success');
      assert.equal(getModelLayerFeatureSpy.callCount, 0);
      assert.equal(leafletMapFireStub.callCount, 9);
      assert.equal(leafletMapFireStub.args[0][0], 'flexberry-map:moveend');
      assert.equal(mapAddSpy.callCount, 8);
      assert.equal(mapRemoveSpy.callCount, 0);
      assert.equal(findByStub.callCount, 1);
      assert.equal(findByStub.args[0][0], 'id');
      assert.equal(findByStub.args[0][1], '1');
      assert.equal(leafletObjectClearLayersSpy.callCount, 0);
      done();
      getModelLayerFeatureSpy.restore();
      leafletMapFireStub.restore();
      mapAddSpy.restore();
      mapRemoveSpy.restore();
      leafletObjectClearLayersSpy.restore();
      findByStub.restore();
    });
  });

  (0, _qunit.test)('test method hideAllLayerObjects', function (assert) {
    //Arrange
    assert.expect(4);

    var map = L.map(document.createElement('div'), {
      center: [51.505, -0.09],
      zoom: 13
    });

    map.addLayer(firstTestLayer);
    map.addLayer(secondTestLayer);
    map.addLayer(thirdTestLayer);
    map.addLayer(_labelsLayer);

    var subject = mapApiMixinObject.create({
      _getTypeLayer: function _getTypeLayer() {
        return new _emberFlexberryGisLayersPrivateVector['default']();
      },
      mapApi: {
        getFromApi: function getFromApi() {
          return map;
        }
      },
      mapLayer: maplayers
    });

    var mapRemoveSpy = _sinon['default'].spy(map, 'removeLayer');
    var findByStub = _sinon['default'].stub(subject.mapLayer, 'findBy', arrayFindBy);

    //Act
    subject.hideAllLayerObjects('1');

    //Assert
    assert.equal(mapRemoveSpy.callCount, 7);
    assert.equal(findByStub.callCount, 1);
    assert.equal(findByStub.args[0][0], 'id');
    assert.equal(findByStub.args[0][1], '1');
    mapRemoveSpy.restore();
    findByStub.restore();
  });

  (0, _qunit.test)('test method hideLayers with continueLoading = false', function (assert) {
    //Arrange
    assert.expect(5);

    var map = L.map(document.createElement('div'), {
      center: [51.505, -0.09],
      zoom: 13
    });

    var subject = mapApiMixinObject.create({
      _getTypeLayer: function _getTypeLayer() {
        return new _emberFlexberryGisLayersPrivateVector['default']();
      },
      mapApi: {
        getFromApi: function getFromApi() {
          return map;
        }
      },
      _getModelLayerFeature: function _getModelLayerFeature() {
        return _ember['default'].RSVP.resolve();
      },
      mapLayer: maplayers
    });

    leafletObject.options.continueLoading = false;
    var getModelLayerFeatureSpy = _sinon['default'].spy(subject, '_getModelLayerFeature');
    var leafletMapFireStub = _sinon['default'].stub(map, 'fire');
    leafletMapFireStub.returns(_ember['default'].RSVP.resolve());
    var findByStub = _sinon['default'].stub(subject.mapLayer, 'findBy', arrayFindBy);

    //Act
    subject.hideLayers(['1']);

    //Assert
    assert.equal(getModelLayerFeatureSpy.callCount, 0);
    assert.equal(leafletMapFireStub.callCount, 0);
    assert.equal(findByStub.callCount, 1);
    assert.equal(findByStub.args[0][0], 'id');
    assert.equal(findByStub.args[0][1], '1');
    getModelLayerFeatureSpy.restore();
    leafletMapFireStub.restore();
    findByStub.restore();
  });

  (0, _qunit.test)('test method hideLayers with continueLoading = true', function (assert) {
    //Arrange
    assert.expect(5);

    var map = L.map(document.createElement('div'), {
      center: [51.505, -0.09],
      zoom: 13
    });

    var subject = mapApiMixinObject.create({
      _getTypeLayer: function _getTypeLayer() {
        return new _emberFlexberryGisLayersPrivateVector['default']();
      },
      mapApi: {
        getFromApi: function getFromApi() {
          return map;
        }
      },
      _getModelLayerFeature: function _getModelLayerFeature() {
        return _ember['default'].RSVP.resolve();
      },
      mapLayer: maplayers
    });

    leafletObject.options.continueLoading = true;
    var getModelLayerFeatureSpy = _sinon['default'].spy(subject, '_getModelLayerFeature');
    var leafletMapFireStub = _sinon['default'].stub(map, 'fire');
    leafletMapFireStub.returns(_ember['default'].RSVP.resolve());
    var findByStub = _sinon['default'].stub(subject.mapLayer, 'findBy', arrayFindBy);

    //Act
    subject.hideLayers(['1']);

    //Assert
    assert.equal(getModelLayerFeatureSpy.callCount, 0);
    assert.equal(leafletMapFireStub.callCount, 0);
    assert.equal(findByStub.callCount, 1);
    assert.equal(findByStub.args[0][0], 'id');
    assert.equal(findByStub.args[0][1], '1');
    getModelLayerFeatureSpy.restore();
    leafletMapFireStub.restore();
    findByStub.restore();
  });
});
define('dummy/tests/unit/mixins/flexberry_map_model_api_show_and_hide_test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/flexberry_map_model_api_show_and_hide_test.js should pass jscs', function () {
    ok(true, 'unit/mixins/flexberry_map_model_api_show_and_hide_test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/flexberry_map_model_api_show_and_hide_test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/flexberry_map_model_api_show_and_hide_test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/flexberry_map_model_api_show_and_hide_test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/leaflet-events-test', ['exports', 'ember', 'ember-flexberry-gis/mixins/leaflet-events', 'qunit', 'sinon'], function (exports, _ember, _emberFlexberryGisMixinsLeafletEvents, _qunit, _sinon) {

  var MixinImplementation = _ember['default'].Object.extend(_emberFlexberryGisMixinsLeafletEvents['default']);

  (0, _qunit.module)('Unit | Mixin | leaflet events');

  // Replace this with your real tests.
  (0, _qunit.test)('it works', function (assert) {
    var subject = MixinImplementation.create();
    assert.ok(subject);
  });

  (0, _qunit.test)('usedLeafletEvents should return events with exists methods', function (assert) {
    var subject = MixinImplementation.create({
      leafletEvents: ['testEvent1', 'testEvent2'],
      testEvent1: function testEvent1() {}
    });

    assert.deepEqual(subject.get('usedLeafletEvents'), ['testEvent1']);
  });

  (0, _qunit.test)('_addEventListeners should create eventHandles for used events', function (assert) {

    var addEventListener = _sinon['default'].spy();

    var subject = MixinImplementation.create({
      usedLeafletEvents: ['testEvent1', 'testEvent2'],
      _leafletObject: { addEventListener: addEventListener }
    });

    subject._addEventListeners();

    assert.ok(addEventListener.calledTwice);
    assert.ok(subject.get('_eventHandlers').hasOwnProperty('testEvent1'));
    assert.ok(subject.get('_eventHandlers').hasOwnProperty('testEvent2'));
  });

  (0, _qunit.test)('_removeEventListener shoud remove all used eventHandles', function (assert) {
    var removeEventListener = _sinon['default'].spy();

    var subject = MixinImplementation.create({
      usedLeafletEvents: ['testEvent1', 'testEvent2'],
      _eventHandlers: {
        testEvent1: '',
        testEvent2: ''
      },
      _leafletObject: { removeEventListener: removeEventListener }
    });

    subject._removeEventListeners();

    assert.ok(removeEventListener.calledTwice);
    assert.notOk(subject.get('_eventHandlers').hasOwnProperty('testEvent1'));
    assert.notOk(subject.get('_eventHandlers').hasOwnProperty('testEvent2'));
    assert.deepEqual(subject.get('_eventHandlers'), {});
  });
});
define('dummy/tests/unit/mixins/leaflet-events-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/leaflet-events-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/leaflet-events-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/leaflet-events-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/leaflet-events-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/leaflet-events-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/leaflet-options-test', ['exports', 'ember', 'ember-flexberry-gis/mixins/leaflet-options', 'qunit'], function (exports, _ember, _emberFlexberryGisMixinsLeafletOptions, _qunit) {

  var MixinImplementation = _ember['default'].Object.extend(_emberFlexberryGisMixinsLeafletOptions['default']);

  (0, _qunit.module)('Unit | Mixin | leaflet options');

  // Replace this with your real tests.
  (0, _qunit.test)('it works', function (assert) {
    var subject = MixinImplementation.create();
    assert.ok(subject);
  });

  (0, _qunit.test)('get(options) should return object with specified properties', function (assert) {
    var subject = MixinImplementation.create({
      leafletOptions: ['testOption1', 'testOption2'],
      testOption1: '222',
      testOption2: 333
    });

    var options = subject.get('options');

    assert.deepEqual(options, {
      testOption1: '222',
      testOption2: 333
    });
  });
});
define('dummy/tests/unit/mixins/leaflet-options-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/leaflet-options-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/leaflet-options-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/leaflet-options-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/leaflet-options-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/leaflet-options-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/leaflet-properties-test', ['exports', 'ember', 'ember-flexberry-gis/mixins/leaflet-properties', 'qunit', 'sinon'], function (exports, _ember, _emberFlexberryGisMixinsLeafletProperties, _qunit, _sinon) {

  (0, _qunit.module)('Unit | Mixin | leaflet properties');

  var MixinImplementation = _ember['default'].Object.extend(_emberFlexberryGisMixinsLeafletProperties['default']);

  // Replace this with your real tests.
  (0, _qunit.test)('it works', function (assert) {
    var subject = MixinImplementation.create();
    assert.ok(subject);
  });

  (0, _qunit.test)('_addObservers should call this.addObserver for specified properties', function (assert) {
    var property = 'testProperty';
    var subject = MixinImplementation.create({
      leafletProperties: [property]
    });

    var addObserver = _sinon['default'].spy(subject, 'addObserver');

    subject._addObservers();

    assert.ok(addObserver.calledWith(property));
  });

  (0, _qunit.test)('after addObserver property changed should fire specified layer function', function (assert) {
    var callTestProperty = _sinon['default'].spy();

    var subject = MixinImplementation.create({
      leafletProperties: ['testProperty:callTestProperty'],
      _leafletObject: { callTestProperty: callTestProperty }
    });

    subject._addObservers();
    _ember['default'].run(function () {
      subject.set('testProperty', 'property');
    });

    assert.ok(callTestProperty.called);
  });

  (0, _qunit.test)('after addObserver property changed should fire default setter for property of layer', function (assert) {
    var setTestProperty = _sinon['default'].spy();

    var subject = MixinImplementation.create({
      leafletProperties: ['testProperty'],
      _leafletObject: { setTestProperty: setTestProperty }
    });

    subject._addObservers();
    _ember['default'].run(function () {
      subject.set('testProperty', 'property');
    });

    assert.ok(setTestProperty.called);
  });

  (0, _qunit.test)('after addObserver property changed should throws if layer property setter is missing', function (assert) {
    var subject = MixinImplementation.create({
      leafletProperties: ['testProperty'],
      _leafletObject: {}
    });

    subject._addObservers();

    assert.throws(function () {
      subject.set('testProperty', 'property');
    });
  });
});
define('dummy/tests/unit/mixins/leaflet-properties-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/leaflet-properties-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/leaflet-properties-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/leaflet-properties-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/leaflet-properties-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/leaflet-properties-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/map-model-api-comparelayers-test', ['exports', 'ember', 'ember-flexberry-gis/mixins/flexberry-map-model-api', 'qunit', 'npm:clipper-lib'], function (exports, _ember, _emberFlexberryGisMixinsFlexberryMapModelApi, _qunit, _npmClipperLib) {

  (0, _qunit.module)('Unit | Mixin | map model api comparelayers');

  var mapApiMixinObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApi['default']);

  var feature1 = {
    type: 'MultiPolygon',
    properties: {},
    coordinates: [[[[3, 3], [3, 7], [8, 7], [8, 3], [3, 3]]]]
  };

  var feature2 = {
    type: 'MultiPolygon',
    properties: {},
    coordinates: [[[[6, 5], [6, 9], [10, 9], [10, 5], [6, 5]]]]
  };

  var feature3 = {
    type: 'MultiPolygon',
    properties: {},
    coordinates: [[[[4, 4], [4, 5], [5, 5], [5, 4], [4, 4]]]]
  };

  var feature4 = {
    type: 'MultiPolygon',
    properties: {},
    coordinates: [[[[10, 3], [9, 3], [9, 2], [10, 2], [10, 3]]]]
  };

  var crsFactory32640 = {
    code: 'EPSG:32640',
    definition: '+proj=utm +zone=40 +datum=WGS84 +units=m +no_defs',
    create: function create() {
      var crs = L.extend({}, new L.Proj.CRS(this.code, this.definition), {
        scale: function scale(zoom) {
          return 256 * Math.pow(2, zoom);
        },
        zoom: function zoom(scale) {
          return Math.log(scale / 256) / Math.LN2;
        }
      });
      return crs;
    }
  };
  var crs32640 = crsFactory32640.create();

  var geoJson32640 = {
    type: 'MultiPolygon',
    properties: {},
    coordinates: [[[[514059.321485393, 6507392.17766284], [513865.509562311, 6507418.6567982], [513839.790201802, 6507279.05179395], [514059.321485393, 6507392.17766284]]]]
  };

  (0, _qunit.test)('_coordsToPoints should return array of points to the power of 8', function (assert) {
    assert.expect(1);

    var featureLayer = L.geoJSON(geoJson32640).getLayers()[0].getLatLngs();

    var subject = mapApiMixinObject.create();
    var result = subject._coordsToPoints(featureLayer);

    assert.deepEqual(result, [[[{ 'X': 51405932148539, 'Y': 650739217766284 }, { 'X': 51386550956231, 'Y': 650741865679820 }, { 'X': 51383979020180, 'Y': 650727905179395 }]]]);
  });

  (0, _qunit.test)('_pointsToCoords should return array of coordinates', function (assert) {
    assert.expect(1);

    var arr = [[[new _npmClipperLib['default'].IntPoint(51405932148539, 650739217766284), new _npmClipperLib['default'].IntPoint(51386550956231, 650741865679820), new _npmClipperLib['default'].IntPoint(51383979020180, 650727905179395)]]];

    var subject = mapApiMixinObject.create();
    var result = subject._pointsToCoords(arr);

    assert.deepEqual(result, [[[[514059.32148539, 6507392.17766284], [513865.50956231, 6507418.65679820], [513839.79020180, 6507279.05179395], [514059.32148539, 6507392.17766284]]]]);
  });

  (0, _qunit.test)('_addToArrayPointsAndFeature should return points and features', function (assert) {
    assert.expect(2);
    var done = assert.async(1);

    var featureLayer = L.geoJSON(geoJson32640).getLayers()[0];
    var subject = mapApiMixinObject.create({
      _getModelLayerFeature: function _getModelLayerFeature() {
        return _ember['default'].RSVP.resolve(new _ember['default'].RSVP.resolve([null, { options: { crs: crs32640 } }, [featureLayer]]));
      }
    });

    var result = subject._addToArrayPointsAndFeature();

    result.then(function (arrayPointsAndFeature) {
      assert.deepEqual(arrayPointsAndFeature.arrPoints[0], [[[{ 'X': 51405932148539, 'Y': 650739217766284 }, { 'X': 51386550956231, 'Y': 650741865679820 }, { 'X': 51383979020180, 'Y': 650727905179395 }]]]);
      assert.ok(arrayPointsAndFeature.features[0]);
      done();
    });
  });

  (0, _qunit.test)('differenceLayers should return the difference of layers', function (assert) {
    assert.expect(4);
    var done = assert.async(1);

    var featureLayer1 = L.geoJSON(feature1).getLayers()[0];
    var featureLayer2 = L.geoJSON(feature2).getLayers()[0];

    var subject = mapApiMixinObject.create({
      _getModelLayerFeature: function _getModelLayerFeature(layer) {
        if (layer === '1') {
          return _ember['default'].RSVP.resolve(new _ember['default'].RSVP.resolve([null, { options: { crs: crs32640 } }, [featureLayer1]]));
        } else {
          return _ember['default'].RSVP.resolve(new _ember['default'].RSVP.resolve([null, { options: { crs: crs32640 } }, [featureLayer2]]));
        }
      },
      _getModelLeafletObject: function _getModelLeafletObject() {
        return [null, { options: { crs: crs32640 } }];
      }
    });

    var result = subject.differenceLayers('1', '2');

    result.then(function (diff) {
      assert.deepEqual(diff.diffFeatures[0].feature, {
        type: 'Feature',
        geometry: {
          type: 'Polygon',
          coordinates: [[[8, 5], [6, 5], [6, 7], [3, 7], [3, 3], [8, 3], [8, 5]]]
        }
      });
      assert.equal(diff.diffFeatures[0].area.toFixed(2), 16.00);
      assert.ok(diff.layerA);
      assert.ok(diff.layerB);
      done();
    });
  });

  (0, _qunit.test)('differenceLayers should return NOT difference', function (assert) {
    assert.expect(1);
    var done = assert.async(1);

    var featureLayer1 = L.geoJSON(feature1).getLayers()[0];

    var subject = mapApiMixinObject.create({
      _getModelLayerFeature: function _getModelLayerFeature(layer) {
        if (layer === '1') {
          return _ember['default'].RSVP.resolve(new _ember['default'].RSVP.resolve([null, { options: { crs: crs32640 } }, [featureLayer1]]));
        } else {
          return _ember['default'].RSVP.resolve(new _ember['default'].RSVP.resolve([null, { options: { crs: crs32640 } }, [featureLayer1]]));
        }
      },
      _getModelLeafletObject: function _getModelLeafletObject() {
        return [null, { options: { crs: crs32640 } }];
      }
    });

    var result = subject.differenceLayers('1', '2');

    result.then(function (diff) {
      assert.equal(diff, 'The difference is not found');
      done();
    });
  });

  (0, _qunit.test)('compareLayers should return array of objects', function (assert) {
    assert.expect(22);
    var done = assert.async(4);

    var featureLayer1 = L.geoJSON(feature1).getLayers()[0];
    featureLayer1.options.crs = crs32640;
    featureLayer1.feature.properties.primarykey = '001';
    var featureLayer3 = L.geoJSON(feature3).getLayers()[0];
    featureLayer3.options.crs = crs32640;
    featureLayer3.feature.properties.primarykey = '003';
    var featureLayer4 = L.geoJSON(feature4).getLayers()[0];
    featureLayer4.options.crs = crs32640;
    featureLayer4.feature.properties.primarykey = '004';

    var featureLayer2 = L.geoJSON(feature2).getLayers()[0];
    featureLayer2.options.crs = crs32640;
    featureLayer2.feature.properties.primarykey = '002';

    var subject = mapApiMixinObject.create({
      _getModelLayerFeature: function _getModelLayerFeature(layer) {
        if (layer === '1') {
          return _ember['default'].RSVP.resolve(new _ember['default'].RSVP.resolve([null, { options: { crs: crs32640 } }, [featureLayer1]]));
        } else if ('2') {
          return _ember['default'].RSVP.resolve(new _ember['default'].RSVP.resolve([null, { options: { crs: crs32640 } }, [featureLayer2, featureLayer3, featureLayer4]]));
        }
      },
      _getModelLeafletObject: function _getModelLeafletObject() {
        return [null, { options: { crs: crs32640 } }];
      }
    });

    var resIntersects = subject.compareLayers('1', '2', 'intersects', false);
    var resContains = subject.compareLayers('1', '2', 'contains', false);
    var resNotIntersects = subject.compareLayers('1', '2', 'notIntersects', false);
    var resNotDiff = subject.compareLayers('1', '1', 'intersects', false);

    resIntersects.then(function (result) {
      assert.equal(result.length, 2);
      assert.deepEqual(result[0].objectDifference.feature, {
        type: 'Feature',
        geometry: {
          type: 'Polygon',
          coordinates: [[[8, 5], [6, 5], [6, 7], [3, 7], [3, 3], [8, 3], [8, 5]]]
        }
      });
      assert.equal(result[0].areaDifference.toFixed(2), 16.00);
      assert.equal(result[0].id, '002');

      assert.deepEqual(result[1].objectDifference.feature, {
        type: 'Feature',
        geometry: {
          type: 'Polygon',
          coordinates: [[[4, 4], [4, 5], [5, 5], [5, 4], [4, 4]]]
        }
      });
      assert.equal(result[1].areaDifference.toFixed(2), 1.00);
      assert.equal(result[1].hasOwnProperty('id'), false);
      done();
    });

    resContains.then(function (result) {
      assert.equal(result.length, 2);
      assert.deepEqual(result[0].objectDifference.feature, {
        type: 'Feature',
        geometry: {
          type: 'Polygon',
          coordinates: [[[8, 5], [6, 5], [6, 7], [3, 7], [3, 3], [8, 3], [8, 5]]]
        }
      });
      assert.equal(result[0].areaDifference.toFixed(2), 16.00);
      assert.equal(result[0].hasOwnProperty('id'), false);

      assert.deepEqual(result[1].objectDifference.feature, {
        type: 'Feature',
        geometry: {
          type: 'Polygon',
          coordinates: [[[4, 4], [4, 5], [5, 5], [5, 4], [4, 4]]]
        }
      });
      assert.equal(result[1].areaDifference.toFixed(2), 1.00);
      assert.equal(result[1].id, '003');
      done();
    });

    resNotIntersects.then(function (result) {
      assert.equal(result.length, 2);
      assert.deepEqual(result[0].objectDifference.feature, {
        type: 'Feature',
        geometry: {
          type: 'Polygon',
          coordinates: [[[10, 9], [6, 9], [6, 7], [8, 7], [8, 5], [10, 5], [10, 9]]]
        }
      });
      assert.equal(result[0].areaDifference.toFixed(2), 12.00);
      assert.equal(result[0].id, '002');

      assert.deepEqual(result[1].objectDifference.feature, {
        type: 'Feature',
        geometry: {
          type: 'Polygon',
          coordinates: [[[10, 3], [9, 3], [9, 2], [10, 2], [10, 3]]]
        }
      });
      assert.equal(result[1].areaDifference.toFixed(2), 1.00);
      assert.equal(result[1].id, '004');
      done();
    });

    resNotDiff['catch'](function (result) {
      assert.equal(result, 'The difference is not found');
      done();
    });
  });
});
define('dummy/tests/unit/mixins/map-model-api-comparelayers-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/map-model-api-comparelayers-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/map-model-api-comparelayers-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/map-model-api-comparelayers-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/map-model-api-comparelayers-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/map-model-api-comparelayers-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/map-model-api-getlayerobjectoptions-test', ['exports', 'ember', 'qunit', 'ember-flexberry-gis/mixins/flexberry-map-model-api', 'ember-flexberry-gis/coordinate-reference-systems/epsg-4326', 'sinon'], function (exports, _ember, _qunit, _emberFlexberryGisMixinsFlexberryMapModelApi, _emberFlexberryGisCoordinateReferenceSystemsEpsg4326, _sinon) {

  (0, _qunit.module)('Unit | Mixin | flexberry-map-model-api getLayerObjectOptions');

  var mapApiMixinObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApi['default']);

  var crsFactory32640 = {
    code: 'EPSG:32640',
    definition: '+proj=utm +zone=40 +datum=WGS84 +units=m +no_defs',
    create: function create() {
      var crs = L.extend({}, new L.Proj.CRS(this.code, this.definition), {
        scale: function scale(zoom) {
          return 256 * Math.pow(2, zoom);
        },
        zoom: function zoom(scale) {
          return Math.log(scale / 256) / Math.LN2;
        }
      });
      return crs;
    }
  };

  var crs32640 = crsFactory32640.create();

  var coordinates32640 = [[[[514059.321485393, 6507392.17766284], [513865.509562311, 6507418.6567982], [513839.790201802, 6507279.05179395], [513740.187971532, 6507317.79141744], [513721.727135932, 6507264.36084561], [513663.282762761, 6507443.48435832], [513802.186924293, 6507539.53170715], [514050.141524955, 6507525.35628219], [514059.321485393, 6507392.17766284]]]];

  var coordinates4326 = [[[[57.24265119051584, 58.706458371940684], [57.23930783675451, 58.70670243628802], [57.23885536193849, 58.705449470295804], [57.23713874882379, 58.705800565222816], [57.23681688374202, 58.705321292241], [57.23581910198846, 58.706931847023135], [57.23822236061096, 58.70779003629061], [57.24250106747296, 58.70765474411314], [57.24265119051584, 58.706458371940684]]]];

  var geoJson32640 = {
    type: 'Feature',
    properties: {
      foo: 'bar'
    },
    geometry: {
      type: 'MultiPolygon',
      coordinates: coordinates32640
    }
  };

  var featureLayer = L.polygon(coordinates4326);
  featureLayer.feature = geoJson32640;
  featureLayer.toProjectedGeoJSON = function () {};

  (0, _qunit.test)('getLayerObjectOptions should return properties of feature, projected geometry, and correct area', function (assert) {
    assert.expect(4);
    var done = assert.async(1);

    var subject = mapApiMixinObject.create({
      _getModelLayerFeature: function _getModelLayerFeature() {
        return _ember['default'].RSVP.resolve([null, { options: { crs: crs32640 } }, [featureLayer]]);
      }
    });

    var toProjectedGeoJSONStub = _sinon['default'].stub(featureLayer, 'toProjectedGeoJSON');
    toProjectedGeoJSONStub.returns({
      type: 'Feature',
      properties: {
        foo: 'bar'
      },
      geometry: {
        type: 'MultiPolygon',
        coordinates: coordinates32640
      }
    });

    var result = subject.getLayerObjectOptions();

    result.then(function (options) {
      assert.equal(options.foo, 'bar');
      assert.equal(options.area.toFixed(2), 61177.16);
      assert.deepEqual(options.geometry, coordinates32640);
      assert.ok(toProjectedGeoJSONStub.calledWith(crs32640));
      toProjectedGeoJSONStub.restore();
      done();
    });
  });

  (0, _qunit.test)('getLayerObjectOptions return projected geometry if specified crsName', function (assert) {
    assert.expect(2);
    var done = assert.async(1);
    var ownerStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    ownerStub.returns({
      knownForType: function knownForType() {
        return {
          'epsg4326': _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default'],
          'epsg32640': crsFactory32640
        };
      }
    });

    var toProjectedGeoJSONStub = _sinon['default'].stub(featureLayer, 'toProjectedGeoJSON');
    toProjectedGeoJSONStub.returns({
      type: 'Feature',
      properties: {
        foo: 'bar'
      },
      geometry: {
        type: 'MultiPolygon',
        coordinates: coordinates32640
      }
    });

    var subject = mapApiMixinObject.create({
      _getModelLayerFeature: function _getModelLayerFeature() {
        return _ember['default'].RSVP.resolve([null, { options: { crs: crs32640 } }, [featureLayer]]);
      }
    });

    var result = subject.getLayerObjectOptions(null, null, 'EPSG:4326');
    result.then(function (options) {
      assert.equal(options.area.toFixed(2), 61177.16);
      assert.deepEqual(options.geometry, coordinates4326);
      done();
      ownerStub.restore();
      toProjectedGeoJSONStub.restore();
    });
  });
});
define('dummy/tests/unit/mixins/map-model-api-getlayerobjectoptions-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/map-model-api-getlayerobjectoptions-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/map-model-api-getlayerobjectoptions-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/map-model-api-getlayerobjectoptions-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/map-model-api-getlayerobjectoptions-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/map-model-api-getlayerobjectoptions-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/mixins/map-model-api-getmergegeometry-test-test', ['exports', 'ember', 'ember-flexberry-gis/mixins/flexberry-map-model-api', 'qunit'], function (exports, _ember, _emberFlexberryGisMixinsFlexberryMapModelApi, _qunit) {

  (0, _qunit.module)('Unit | Mixin | map model api getmergegeometry test');

  var mapApiMixinObject = _ember['default'].Object.extend(_emberFlexberryGisMixinsFlexberryMapModelApi['default']);

  (0, _qunit.test)('splitObjectIds should return 1 and 3 promisses', function (assert) {
    var subject = mapApiMixinObject.create({
      _getModelLayerFeature: function _getModelLayerFeature() {
        return _ember['default'].RSVP.resolve([null, null, null]);
      }
    });

    // 220
    var result220 = subject.loadingFeaturesByPackages('1', ['1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1']);

    // 20
    var result20 = subject.loadingFeaturesByPackages('1', ['1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1']);

    assert.equal(result220.length, 3);
    assert.equal(result20.length, 1);
  });
});
define('dummy/tests/unit/mixins/map-model-api-getmergegeometry-test-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/mixins');
  test('unit/mixins/map-model-api-getmergegeometry-test-test.js should pass jscs', function () {
    ok(true, 'unit/mixins/map-model-api-getmergegeometry-test-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/mixins/map-model-api-getmergegeometry-test-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/mixins/map-model-api-getmergegeometry-test-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/mixins/map-model-api-getmergegeometry-test-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-layer-link-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForModel)('new-platform-flexberry-g-i-s-layer-link', 'Unit | Model | new-platform-flexberry-g-i-s-layer-link', {
    // Specify the other units that are required for this test.
    needs: ['model:custom-inflector-rules', 'model:new-platform-flexberry-g-i-s-layer-link', 'model:new-platform-flexberry-g-i-s-layer-metadata', 'model:new-platform-flexberry-g-i-s-link-metadata', 'model:new-platform-flexberry-g-i-s-link-parameter', 'model:new-platform-flexberry-g-i-s-map-layer', 'model:new-platform-flexberry-g-i-s-map-object-setting', 'model:new-platform-flexberry-g-i-s-map', 'model:new-platform-flexberry-g-i-s-parameter-metadata']
  });

  (0, _emberQunit.test)('it exists', function (assert) {
    var model = this.subject();

    // let store = this.store();
    assert.ok(!!model);
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-layer-link-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/models');
  test('unit/models/new-platform-flexberry-g-i-s-layer-link-test.js should pass jscs', function () {
    ok(true, 'unit/models/new-platform-flexberry-g-i-s-layer-link-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-layer-link-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/models/new-platform-flexberry-g-i-s-layer-link-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/models/new-platform-flexberry-g-i-s-layer-link-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-layer-metadata-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForModel)('new-platform-flexberry-g-i-s-layer-metadata', 'Unit | Model | new-platform-flexberry-g-i-s-layer-metadata', {
    // Specify the other units that are required for this test.
    needs: ['model:custom-inflector-rules', 'model:new-platform-flexberry-g-i-s-layer-link', 'model:new-platform-flexberry-g-i-s-layer-metadata', 'model:new-platform-flexberry-g-i-s-link-metadata', 'model:new-platform-flexberry-g-i-s-link-parameter', 'model:new-platform-flexberry-g-i-s-map-layer', 'model:new-platform-flexberry-g-i-s-map-object-setting', 'model:new-platform-flexberry-g-i-s-map', 'model:new-platform-flexberry-g-i-s-parameter-metadata']
  });

  (0, _emberQunit.test)('it exists', function (assert) {
    var model = this.subject();

    // let store = this.store();
    assert.ok(!!model);
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-layer-metadata-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/models');
  test('unit/models/new-platform-flexberry-g-i-s-layer-metadata-test.js should pass jscs', function () {
    ok(true, 'unit/models/new-platform-flexberry-g-i-s-layer-metadata-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-layer-metadata-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/models/new-platform-flexberry-g-i-s-layer-metadata-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/models/new-platform-flexberry-g-i-s-layer-metadata-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-link-metadata-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForModel)('new-platform-flexberry-g-i-s-link-metadata', 'Unit | Model | new-platform-flexberry-g-i-s-link-metadata', {
    // Specify the other units that are required for this test.
    needs: ['model:custom-inflector-rules', 'model:new-platform-flexberry-g-i-s-layer-link', 'model:new-platform-flexberry-g-i-s-layer-metadata', 'model:new-platform-flexberry-g-i-s-link-metadata', 'model:new-platform-flexberry-g-i-s-link-parameter', 'model:new-platform-flexberry-g-i-s-map-layer', 'model:new-platform-flexberry-g-i-s-map-object-setting', 'model:new-platform-flexberry-g-i-s-map', 'model:new-platform-flexberry-g-i-s-parameter-metadata']
  });

  (0, _emberQunit.test)('it exists', function (assert) {
    var model = this.subject();

    // let store = this.store();
    assert.ok(!!model);
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-link-metadata-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/models');
  test('unit/models/new-platform-flexberry-g-i-s-link-metadata-test.js should pass jscs', function () {
    ok(true, 'unit/models/new-platform-flexberry-g-i-s-link-metadata-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-link-metadata-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/models/new-platform-flexberry-g-i-s-link-metadata-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/models/new-platform-flexberry-g-i-s-link-metadata-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-link-parameter-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForModel)('new-platform-flexberry-g-i-s-link-parameter', 'Unit | Model | new-platform-flexberry-g-i-s-link-parameter', {
    // Specify the other units that are required for this test.
    needs: ['model:custom-inflector-rules', 'model:new-platform-flexberry-g-i-s-layer-link', 'model:new-platform-flexberry-g-i-s-layer-metadata', 'model:new-platform-flexberry-g-i-s-link-metadata', 'model:new-platform-flexberry-g-i-s-link-parameter', 'model:new-platform-flexberry-g-i-s-map-layer', 'model:new-platform-flexberry-g-i-s-map-object-setting', 'model:new-platform-flexberry-g-i-s-map', 'model:new-platform-flexberry-g-i-s-parameter-metadata']
  });

  (0, _emberQunit.test)('it exists', function (assert) {
    var model = this.subject();

    // let store = this.store();
    assert.ok(!!model);
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-link-parameter-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/models');
  test('unit/models/new-platform-flexberry-g-i-s-link-parameter-test.js should pass jscs', function () {
    ok(true, 'unit/models/new-platform-flexberry-g-i-s-link-parameter-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-link-parameter-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/models/new-platform-flexberry-g-i-s-link-parameter-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/models/new-platform-flexberry-g-i-s-link-parameter-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-map-layer-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForModel)('new-platform-flexberry-g-i-s-map-layer', 'Unit | Model | new-platform-flexberry-g-i-s-map-layer', {
    // Specify the other units that are required for this test.
    needs: ['model:custom-inflector-rules', 'model:new-platform-flexberry-g-i-s-layer-link', 'model:new-platform-flexberry-g-i-s-layer-metadata', 'model:new-platform-flexberry-g-i-s-link-metadata', 'model:new-platform-flexberry-g-i-s-link-parameter', 'model:new-platform-flexberry-g-i-s-map-layer', 'model:new-platform-flexberry-g-i-s-map-object-setting', 'model:new-platform-flexberry-g-i-s-map', 'model:new-platform-flexberry-g-i-s-parameter-metadata']
  });

  (0, _emberQunit.test)('it exists', function (assert) {
    var model = this.subject();

    // let store = this.store();
    assert.ok(!!model);
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-map-layer-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/models');
  test('unit/models/new-platform-flexberry-g-i-s-map-layer-test.js should pass jscs', function () {
    ok(true, 'unit/models/new-platform-flexberry-g-i-s-map-layer-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-map-layer-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/models/new-platform-flexberry-g-i-s-map-layer-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/models/new-platform-flexberry-g-i-s-map-layer-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-map-object-setting-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForModel)('new-platform-flexberry-g-i-s-map-object-setting', 'Unit | Model | new-platform-flexberry-g-i-s-map-object-setting', {
    // Specify the other units that are required for this test.
    needs: ['model:custom-inflector-rules', 'model:new-platform-flexberry-g-i-s-layer-link', 'model:new-platform-flexberry-g-i-s-layer-metadata', 'model:new-platform-flexberry-g-i-s-link-metadata', 'model:new-platform-flexberry-g-i-s-link-parameter', 'model:new-platform-flexberry-g-i-s-map-layer', 'model:new-platform-flexberry-g-i-s-map-object-setting', 'model:new-platform-flexberry-g-i-s-map', 'model:new-platform-flexberry-g-i-s-parameter-metadata']
  });

  (0, _emberQunit.test)('it exists', function (assert) {
    var model = this.subject();

    // let store = this.store();
    assert.ok(!!model);
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-map-object-setting-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/models');
  test('unit/models/new-platform-flexberry-g-i-s-map-object-setting-test.js should pass jscs', function () {
    ok(true, 'unit/models/new-platform-flexberry-g-i-s-map-object-setting-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-map-object-setting-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/models/new-platform-flexberry-g-i-s-map-object-setting-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/models/new-platform-flexberry-g-i-s-map-object-setting-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-map-test', ['exports', 'ember-qunit', 'sinon', 'ember', 'ember-flexberry-gis/utils/layer-to-jsts'], function (exports, _emberQunit, _sinon, _ember, _emberFlexberryGisUtilsLayerToJsts) {

  (0, _emberQunit.moduleForModel)('new-platform-flexberry-g-i-s-map', 'Unit | Model | new-platform-flexberry-g-i-s-map', {
    // Specify the other units that are required for this test.
    needs: ['model:custom-inflector-rules', 'model:new-platform-flexberry-g-i-s-layer-link', 'model:new-platform-flexberry-g-i-s-layer-metadata', 'model:new-platform-flexberry-g-i-s-link-metadata', 'model:new-platform-flexberry-g-i-s-link-parameter', 'model:new-platform-flexberry-g-i-s-map-layer', 'model:new-platform-flexberry-g-i-s-map-object-setting', 'model:new-platform-flexberry-g-i-s-map', 'model:new-platform-flexberry-g-i-s-parameter-metadata', 'service:map-api', 'config:environment', 'component:flexberry-map']
  });

  var crsName = 'EPSG:4326';
  var objWithCrs = {
    options: {
      crs: {
        code: crsName
      }
    }
  };
  var objA = [{
    options: {
      crs: {
        code: crsName
      }
    },
    feature: {
      type: 'Feature',
      id: 'vydel_utverzhdeno_polygon.0017782c-6f34-46b5-ac77-c0a65366c452',
      geometry_name: 'shape',
      properties: {
        id: '141-17',
        lesnichestvo: 'Закамское',
        uchastkovoelesnichestvo: 'Чермозское(Чермозское)',
        nomerkvartala: '141',
        primarykey: '0017782c-6f34-46b5-ac77-c0a65366c452',
        area: 10
      },
      geometry: {
        type: 'MultiPolygon',
        coordinates: [[[[55.78205, 58.73614], [55.85209, 58.73935], [55.85690, 58.71903], [55.78205, 58.71476], [55.78205, 58.73614]]]]
      }
    }
  }];

  var objB = [{
    options: {
      crs: {
        code: crsName
      }
    },
    feature: {
      type: 'Feature',
      id: 'kvartal_utverzhdeno_polygon.45df35c7-f292-44f8-b328-5fd4be739233',
      geometry_name: 'shape',
      properties: {
        nomer: '41',
        lesnichestvo: 'Закамское',
        uchastkovoelesnichestvo: 'Чермозское(Чермозское)',
        primarykey: '45df35c7-f292-44f8-b328-5fd4be739233',
        area: 20
      },
      geometry: {
        type: 'MultiPolygon',
        coordinates: [[[[55.80677, 58.72884], [55.83286, 58.73846], [55.83836, 58.72991], [55.80677, 58.72884]]]]
      }
    },
    _latlngs: [[[L.latLng(58.72884, 55.80677), L.latLng(58.73846, 55.83286), L.latLng(58.72991, 55.83836)]]]
  }];

  var objC = [{
    options: {
      crs: {
        code: crsName
      }
    },
    feature: {
      type: 'Feature',
      id: 'kvartal_utverzhdeno_polygon.d633ea1d-eb32-423f-8663-a38abc7ba094',
      geometry_name: 'shape',
      properties: {
        nomer: '42',
        lesnichestvo: 'Закамское',
        uchastkovoelesnichestvo: 'Чермозское(Чермозское)',
        primarykey: 'd633ea1d-eb32-423f-8663-a38abc7ba094',
        area: 30
      },
      geometry: {
        type: 'MultiPolygon',
        coordinates: [[[[55.97843, 58.73810], [55.01448, 58.73329], [55.98461, 58.72420], [55.97843, 58.73810]]]]
      }
    }
  }];

  var objD = [{
    options: {
      crs: {
        code: crsName
      }
    },
    feature: {
      type: 'Feature',
      id: 'kvartal_utverzhdeno_polygon.79fd98d0-52ae-44ae-b616-971768196ad8',
      geometry_name: 'shape',
      properties: {
        nomer: '43',
        lesnichestvo: 'Закамское',
        uchastkovoelesnichestvo: 'Чермозское(Чермозское)',
        primarykey: '79fd98d0-52ae-44ae-b616-971768196ad8',
        area: 30
      },
      geometry: {
        type: 'MultiPolygon',
        coordinates: [[[[55.85072, 58.68176], [55.88848, 58.67194], [55.84316, 58.65391], [55.85072, 58.68176]]]]
      }
    }
  }];

  (0, _emberQunit.test)('it exists', function (assert) {
    var model = this.subject();

    assert.ok(!!model);
  });

  (0, _emberQunit.test)('substitution _getModelLayerFeature', function (assert) {
    var map = this.subject();
    var _getModelLayerFeatureStub = _sinon['default'].stub(map, '_getModelLayerFeature');
    _getModelLayerFeatureStub.withArgs(1).returns(objA);
    assert.ok(_getModelLayerFeatureStub(1));
  });

  (0, _emberQunit.test)('isContainsObject', function (assert) {
    var map = this.subject();
    var _getModelLayerFeatureStub = _sinon['default'].stub(map, '_getModelLayerFeature');
    _getModelLayerFeatureStub.withArgs('f34ea73d-9f00-4f02-b02d-675d459c972b', ['0017782c-6f34-46b5-ac77-c0a65366c452']).returns(new _ember['default'].RSVP.Promise(function (resolve, reject) {
      resolve([null, objWithCrs, objA]);
    }));
    _getModelLayerFeatureStub.withArgs('63b3f6fb-3d4c-4acc-ab93-1b4fa31f9b0e', ['45df35c7-f292-44f8-b328-5fd4be739233']).returns(new _ember['default'].RSVP.Promise(function (resolve, reject) {
      resolve([null, objWithCrs, objB]);
    }));

    map.isContainsObject('f34ea73d-9f00-4f02-b02d-675d459c972b', '0017782c-6f34-46b5-ac77-c0a65366c452', '63b3f6fb-3d4c-4acc-ab93-1b4fa31f9b0e', '45df35c7-f292-44f8-b328-5fd4be739233').then(function (e) {
      assert.ok(e, 'Contains');
    });

    map.isContainsObject('63b3f6fb-3d4c-4acc-ab93-1b4fa31f9b0e', '45df35c7-f292-44f8-b328-5fd4be739233', 'f34ea73d-9f00-4f02-b02d-675d459c972b', '0017782c-6f34-46b5-ac77-c0a65366c452').then(function (e) {
      assert.notOk(e, 'Not contains');
    });
  });

  (0, _emberQunit.test)('getAreaExtends', function (assert) {
    var map = this.subject();
    var _getModelLayerFeatureStub = _sinon['default'].stub(map, '_getModelLayerFeature');
    _getModelLayerFeatureStub.withArgs('f34ea73d-9f00-4f02-b02d-675d459c972b', ['0017782c-6f34-46b5-ac77-c0a65366c452']).returns(new _ember['default'].RSVP.Promise(function (resolve, reject) {
      resolve([null, objWithCrs, objA]);
    }));
    _getModelLayerFeatureStub.withArgs('63b3f6fb-3d4c-4acc-ab93-1b4fa31f9b0e', ['45df35c7-f292-44f8-b328-5fd4be739233']).returns(new _ember['default'].RSVP.Promise(function (resolve, reject) {
      resolve([null, objWithCrs, objB]);
    }));
    _getModelLayerFeatureStub.withArgs('63b3f6fb-3d4c-4acc-ab93-1b4fa31f9b0e', ['d633ea1d-eb32-423f-8663-a38abc7ba094']).returns(new _ember['default'].RSVP.Promise(function (resolve, reject) {
      resolve([null, objWithCrs, objC]);
    }));
    _getModelLayerFeatureStub.withArgs('63b3f6fb-3d4c-4acc-ab93-1b4fa31f9b0e', ['79fd98d0-52ae-44ae-b616-971768196ad8']).returns(new _ember['default'].RSVP.Promise(function (resolve, reject) {
      resolve([null, objWithCrs, objD]);
    }));

    map.getAreaExtends('f34ea73d-9f00-4f02-b02d-675d459c972b', '0017782c-6f34-46b5-ac77-c0a65366c452', '63b3f6fb-3d4c-4acc-ab93-1b4fa31f9b0e', '45df35c7-f292-44f8-b328-5fd4be739233').then(function (e) {
      assert.equal(e, 0, 'B<A and intersect');
    });

    map.getAreaExtends('63b3f6fb-3d4c-4acc-ab93-1b4fa31f9b0e', '45df35c7-f292-44f8-b328-5fd4be739233', 'f34ea73d-9f00-4f02-b02d-675d459c972b', '0017782c-6f34-46b5-ac77-c0a65366c452').then(function (e) {
      assert.equal(e, 8887057.32835752, 'B>A and intesect');
    });

    map.getAreaExtends('63b3f6fb-3d4c-4acc-ab93-1b4fa31f9b0e', '79fd98d0-52ae-44ae-b616-971768196ad8', '63b3f6fb-3d4c-4acc-ab93-1b4fa31f9b0e', 'd633ea1d-eb32-423f-8663-a38abc7ba094').then(function (e) {
      assert.equal(e, 43187392.82526295, 'Not intersect');
    });
  });

  (0, _emberQunit.test)('getIntersectionArea', function (assert) {
    var map = this.subject();
    var _getModelLayerFeatureStub = _sinon['default'].stub(map, '_getModelLayerFeature');
    _getModelLayerFeatureStub.withArgs('f34ea73d-9f00-4f02-b02d-675d459c972b', ['0017782c-6f34-46b5-ac77-c0a65366c452']).returns(new _ember['default'].RSVP.Promise(function (resolve, reject) {
      resolve([null, objWithCrs, objA]);
    }));

    _getModelLayerFeatureStub.withArgs('63b3f6fb-3d4c-4acc-ab93-1b4fa31f9b0e', ['45df35c7-f292-44f8-b328-5fd4be739233']).returns(new _ember['default'].RSVP.Promise(function (resolve, reject) {
      resolve([null, objWithCrs, objB]);
    }));
    _getModelLayerFeatureStub.withArgs('63b3f6fb-3d4c-4acc-ab93-1b4fa31f9b0e', ['d633ea1d-eb32-423f-8663-a38abc7ba094']).returns(new _ember['default'].RSVP.Promise(function (resolve, reject) {
      resolve([null, objWithCrs, objC]);
    }));

    map.getIntersectionArea('63b3f6fb-3d4c-4acc-ab93-1b4fa31f9b0e', '45df35c7-f292-44f8-b328-5fd4be739233', 'f34ea73d-9f00-4f02-b02d-675d459c972b', ['0017782c-6f34-46b5-ac77-c0a65366c452']).then(function (e) {
      assert.equal(e[0].area, 887494.3528438057, 'Intersect');
    });

    map.getIntersectionArea('63b3f6fb-3d4c-4acc-ab93-1b4fa31f9b0e', '79fd98d0-52ae-44ae-b616-971768196ad8', '63b3f6fb-3d4c-4acc-ab93-1b4fa31f9b0e', ['d633ea1d-eb32-423f-8663-a38abc7ba094']).then(function (e) {
      assert.equal(e[0].area, 'Intersection not found', 'Not area intersect');
    })['catch'](function (e) {
      assert.ok(e, 'Not intersect');
    });
  });

  (0, _emberQunit.test)('getDistanceBetweenObjects', function (assert) {
    var map = this.subject();
    var _getModelLayerFeatureStub = _sinon['default'].stub(map, '_getModelLayerFeature');
    _getModelLayerFeatureStub.withArgs('f34ea73d-9f00-4f02-b02d-675d459c972b', ['0017782c-6f34-46b5-ac77-c0a65366c452']).returns(new _ember['default'].RSVP.Promise(function (resolve, reject) {
      resolve([null, objWithCrs, L.geoJSON(objA[0].feature).getLayers()]);
    }));
    _getModelLayerFeatureStub.withArgs('63b3f6fb-3d4c-4acc-ab93-1b4fa31f9b0e', ['45df35c7-f292-44f8-b328-5fd4be739233']).returns(new _ember['default'].RSVP.Promise(function (resolve, reject) {
      resolve([null, objWithCrs, L.geoJSON(objB[0].feature).getLayers()]);
    }));

    map.getDistanceBetweenObjects('f34ea73d-9f00-4f02-b02d-675d459c972b', '0017782c-6f34-46b5-ac77-c0a65366c452', '63b3f6fb-3d4c-4acc-ab93-1b4fa31f9b0e', '45df35c7-f292-44f8-b328-5fd4be739233').then(function (e) {
      assert.equal(e, 536.4476316355142, 'distance');
    });
  });

  (0, _emberQunit.test)('getmulticircuitobject with difference', function (assert) {
    var map = this.subject();
    var objA = {
      type: 'Feature',
      properties: {},
      geometry: {
        type: 'Polygon',
        coordinates: [[[56.18425, 58.07197], [56.21068, 58.07197], [56.21068, 58.07987], [56.18425, 58.07987], [56.18425, 58.07197]]]
      },
      crs: {
        type: 'name',
        properties: {
          name: 'EPSG:4326'
        }
      }
    };
    var objB = {
      type: 'Feature',
      properties: {},
      geometry: {
        type: 'Polygon',
        coordinates: [[[56.19712, 58.06770], [56.22322, 58.06770], [56.22322, 58.07551], [56.19712, 58.07551], [56.19712, 58.06770]]]
      },
      crs: {
        type: 'name',
        properties: {
          name: 'EPSG:4326'
        }
      }
    };
    var objC = {
      type: 'Feature',
      properties: {},
      geometry: {
        type: 'Polygon',
        coordinates: [[[56.21644, 58.07864], [56.23197, 58.07864], [56.23197, 58.08608], [56.21644, 58.08608], [56.21644, 58.07864]]]
      },
      crs: {
        type: 'name',
        properties: {
          name: 'EPSG:4326'
        }
      }
    };
    var multiObject = {
      type: 'Feature',
      geometry: {
        type: 'MultiPolygon',
        coordinates: [[[[56.19712, 58.07197], [56.18425, 58.07197], [56.18425, 58.07987], [56.21068, 58.07987], [56.21068, 58.07551], [56.19712, 58.07551], [56.19712, 58.07197]]], [[[56.21068, 58.07551], [56.22322, 58.07551], [56.22322, 58.0677], [56.19712, 58.0677], [56.19712, 58.07197], [56.21068, 58.07197], [56.21068, 58.07551]]], [[[56.21644, 58.07864], [56.21644, 58.08608], [56.23197, 58.08608], [56.23197, 58.07864], [56.21644, 58.07864]]]]
      },
      crs: {
        type: 'name',
        properties: {
          name: 'EPSG:4326'
        }
      }
    };

    var resultObj = map.createMulti([objA, objB, objC], false);

    assert.deepEqual(resultObj, multiObject, 'multi object');
  });

  (0, _emberQunit.test)('getmulticircuitobject with union', function (assert) {
    var map = this.subject();
    var objA = {
      type: 'Feature',
      properties: {},
      geometry: {
        type: 'Polygon',
        coordinates: [[[56.18425, 58.07197], [56.21068, 58.07197], [56.21068, 58.07987], [56.18425, 58.07987], [56.18425, 58.07197]]]
      },
      crs: {
        type: 'name',
        properties: {
          name: 'EPSG:4326'
        }
      }
    };
    var objB = {
      type: 'Feature',
      properties: {},
      geometry: {
        type: 'Polygon',
        coordinates: [[[56.19712, 58.06770], [56.22322, 58.06770], [56.22322, 58.07551], [56.19712, 58.07551], [56.19712, 58.06770]]]
      },
      crs: {
        type: 'name',
        properties: {
          name: 'EPSG:4326'
        }
      }
    };
    var objC = {
      type: 'Feature',
      properties: {},
      geometry: {
        type: 'Polygon',
        coordinates: [[[56.21644, 58.07864], [56.23197, 58.07864], [56.23197, 58.08608], [56.21644, 58.08608], [56.21644, 58.07864]]]
      },
      crs: {
        type: 'name',
        properties: {
          name: 'EPSG:4326'
        }
      }
    };
    var multiObject = {
      type: 'Feature',
      geometry: {
        type: 'MultiPolygon',
        coordinates: [[[[56.19712, 58.07197], [56.18425, 58.07197], [56.18425, 58.07987], [56.21068, 58.07987], [56.21068, 58.07551], [56.22322, 58.07551], [56.22322, 58.0677], [56.19712, 58.0677], [56.19712, 58.07197]]], [[[56.21644, 58.07864], [56.21644, 58.08608], [56.23197, 58.08608], [56.23197, 58.07864], [56.21644, 58.07864]]]]
      },
      crs: {
        type: 'name',
        properties: {
          name: 'EPSG:4326'
        }
      }
    };

    var resultObj = map.createMulti([objA, objB, objC], true);

    assert.deepEqual(resultObj, multiObject, 'multi object');
  });

  (0, _emberQunit.test)('getMergedGeometry with difference should return geoJson feature in EPSG:4326', function (assert) {
    assert.expect(1);
    var done = assert.async(1);

    var geoJson1Layer1 = {
      type: 'MultiPolygon',
      properties: {},
      coordinates: [[[[1.001, 2.002], [1.005, 2.002], [1.003, 2.003], [1.001, 2.003], [1.001, 2.002]]]]
    };

    var geoJson2Layer1 = {
      type: 'MultiPolygon',
      properties: {},
      coordinates: [[[[1.003, 2.0025], [1.005, 2.0025], [1.003, 2.003], [1.001, 2.003], [1.003, 2.0025]]]]
    };

    var geoJson1Layer2 = {
      type: 'MultiPolygon',
      properties: {},
      coordinates: [[[[1.001, 2.0033], [1.003, 2.0033], [1.005, 2.004], [1.001, 2.004], [1.001, 2.0033]]]]
    };

    var geoJson2Layer2 = {
      type: 'MultiPolygon',
      properties: {},
      coordinates: [[[[1.001, 2.0033], [1.003, 2.0033], [1.003, 2.0035], [1.001, 2.0035], [1.001, 2.0033]]]]
    };

    var geoJsonUnion = {
      type: 'Feature',
      geometry: {
        type: 'MultiPolygon',
        coordinates: [[[[1.0039999999999998, 2.0025], [1.005, 2.002], [1.001, 2.002], [1.001, 2.003], [1.003, 2.0025], [1.0039999999999998, 2.0025]]], [[[1.003, 2.003], [1.005, 2.0025], [1.0039999999999998, 2.0025], [1.003, 2.003]]], [[[1.001, 2.0035], [1.001, 2.004], [1.005, 2.004], [1.003, 2.0033], [1.003, 2.0035], [1.001, 2.0035]]]]
      },
      crs: {
        type: 'name',
        properties: {
          name: 'EPSG:4326'
        }
      }
    };

    var feature1Layer1 = L.geoJSON(geoJson1Layer1).getLayers()[0];
    feature1Layer1.options.crs = { code: 'EPSG:4326' };
    var feature2Layer1 = L.geoJSON(geoJson2Layer1).getLayers()[0];
    feature2Layer1.options.crs = { code: 'EPSG:4326' };

    var feature1Layer2 = L.geoJSON(geoJson1Layer2).getLayers()[0];
    feature1Layer2.options.crs = { code: 'EPSG:4326' };
    var feature2Layer2 = L.geoJSON(geoJson2Layer2).getLayers()[0];
    feature2Layer2.options.crs = { code: 'EPSG:4326' };

    feature1Layer1.toJsts = function () {};

    var toJstsStub1 = _sinon['default'].stub(feature1Layer1, 'toJsts');
    var objJsts1 = (0, _emberFlexberryGisUtilsLayerToJsts.geometryToJsts)(geoJson1Layer1);
    objJsts1.setSRID(4326);
    toJstsStub1.returns(objJsts1);

    feature2Layer1.toJsts = function () {};

    var toJstsStub2 = _sinon['default'].stub(feature2Layer1, 'toJsts');
    var objJsts2 = (0, _emberFlexberryGisUtilsLayerToJsts.geometryToJsts)(geoJson2Layer1);
    objJsts2.setSRID(4326);
    toJstsStub2.returns(objJsts2);

    feature1Layer2.toJsts = function () {};

    var toJstsStub3 = _sinon['default'].stub(feature1Layer2, 'toJsts');
    var objJsts3 = (0, _emberFlexberryGisUtilsLayerToJsts.geometryToJsts)(geoJson1Layer2);
    objJsts3.setSRID(4326);
    toJstsStub3.returns(objJsts3);

    feature2Layer2.toJsts = function () {};

    var toJstsStub4 = _sinon['default'].stub(feature2Layer2, 'toJsts');
    var objJsts4 = (0, _emberFlexberryGisUtilsLayerToJsts.geometryToJsts)(geoJson2Layer2);
    objJsts4.setSRID(4326);
    toJstsStub4.returns(objJsts4);

    var map = this.subject();
    var _getModelLayerFeatureStub = _sinon['default'].stub(map, '_getModelLayerFeature');
    _getModelLayerFeatureStub.withArgs('1', ['1', '2']).returns(new _ember['default'].RSVP.Promise(function (resolve, reject) {
      resolve([null, null, [feature1Layer1, feature2Layer1]]);
    }));

    _getModelLayerFeatureStub.withArgs('2', ['1', '2']).returns(new _ember['default'].RSVP.Promise(function (resolve, reject) {
      resolve([null, null, [feature1Layer2, feature2Layer2]]);
    }));

    var result = map.getMergedGeometry('1', ['1', '2'], '2', ['1', '2']);

    result.then(function (feature) {
      assert.deepEqual(feature, geoJsonUnion);
      done();
      _getModelLayerFeatureStub.restore();
    });
  });

  (0, _emberQunit.test)('getMergedGeometry with union should return geoJson feature in EPSG:4326', function (assert) {
    assert.expect(1);
    var done = assert.async(1);

    var geoJson1Layer1 = {
      type: 'MultiPolygon',
      properties: {},
      coordinates: [[[[1.001, 2.002], [1.005, 2.002], [1.003, 2.003], [1.001, 2.003], [1.001, 2.002]]]]
    };

    var geoJson2Layer1 = {
      type: 'MultiPolygon',
      properties: {},
      coordinates: [[[[1.003, 2.0025], [1.005, 2.0025], [1.003, 2.003], [1.001, 2.003], [1.003, 2.0025]]]]
    };

    var geoJson1Layer2 = {
      type: 'MultiPolygon',
      properties: {},
      coordinates: [[[[1.001, 2.0033], [1.003, 2.0033], [1.005, 2.004], [1.001, 2.004], [1.001, 2.0033]]]]
    };

    var geoJson2Layer2 = {
      type: 'MultiPolygon',
      properties: {},
      coordinates: [[[[1.001, 2.0033], [1.003, 2.0033], [1.003, 2.0035], [1.001, 2.0035], [1.001, 2.0033]]]]
    };

    var geoJsonUnion = {
      type: 'Feature',
      geometry: {
        type: 'MultiPolygon',
        coordinates: [[[[1.0039999999999998, 2.0025], [1.005, 2.002], [1.001, 2.002], [1.001, 2.003], [1.003, 2.003], [1.005, 2.0025], [1.0039999999999998, 2.0025]]], [[[1.003, 2.0033], [1.001, 2.0033], [1.001, 2.0035], [1.001, 2.004], [1.005, 2.004], [1.003, 2.0033]]]]
      },
      crs: {
        type: 'name',
        properties: {
          name: 'EPSG:4326'
        }
      }
    };

    var feature1Layer1 = L.geoJSON(geoJson1Layer1).getLayers()[0];
    feature1Layer1.options.crs = { code: 'EPSG:4326' };
    var feature2Layer1 = L.geoJSON(geoJson2Layer1).getLayers()[0];
    feature2Layer1.options.crs = { code: 'EPSG:4326' };

    var feature1Layer2 = L.geoJSON(geoJson1Layer2).getLayers()[0];
    feature1Layer2.options.crs = { code: 'EPSG:4326' };
    var feature2Layer2 = L.geoJSON(geoJson2Layer2).getLayers()[0];
    feature2Layer2.options.crs = { code: 'EPSG:4326' };

    feature1Layer1.toJsts = function () {};

    var toJstsStub1 = _sinon['default'].stub(feature1Layer1, 'toJsts');
    var objJsts1 = (0, _emberFlexberryGisUtilsLayerToJsts.geometryToJsts)(geoJson1Layer1);
    objJsts1.setSRID(4326);
    toJstsStub1.returns(objJsts1);

    feature2Layer1.toJsts = function () {};

    var toJstsStub2 = _sinon['default'].stub(feature2Layer1, 'toJsts');
    var objJsts2 = (0, _emberFlexberryGisUtilsLayerToJsts.geometryToJsts)(geoJson2Layer1);
    objJsts2.setSRID(4326);
    toJstsStub2.returns(objJsts2);

    feature1Layer2.toJsts = function () {};

    var toJstsStub3 = _sinon['default'].stub(feature1Layer2, 'toJsts');
    var objJsts3 = (0, _emberFlexberryGisUtilsLayerToJsts.geometryToJsts)(geoJson1Layer2);
    objJsts3.setSRID(4326);
    toJstsStub3.returns(objJsts3);

    feature2Layer2.toJsts = function () {};

    var toJstsStub4 = _sinon['default'].stub(feature2Layer2, 'toJsts');
    var objJsts4 = (0, _emberFlexberryGisUtilsLayerToJsts.geometryToJsts)(geoJson2Layer2);
    objJsts4.setSRID(4326);
    toJstsStub4.returns(objJsts4);

    var map = this.subject();
    var _getModelLayerFeatureStub = _sinon['default'].stub(map, '_getModelLayerFeature');
    _getModelLayerFeatureStub.withArgs('1', ['1', '2']).returns(new _ember['default'].RSVP.Promise(function (resolve, reject) {
      resolve([null, null, [feature1Layer1, feature2Layer1]]);
    }));

    _getModelLayerFeatureStub.withArgs('2', ['1', '2']).returns(new _ember['default'].RSVP.Promise(function (resolve, reject) {
      resolve([null, null, [feature1Layer2, feature2Layer2]]);
    }));

    var result = map.getMergedGeometry('1', ['1', '2'], '2', ['1', '2'], true);

    result.then(function (feature) {
      assert.deepEqual(feature, geoJsonUnion);
      done();
      _getModelLayerFeatureStub.restore();
    });
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-map-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/models');
  test('unit/models/new-platform-flexberry-g-i-s-map-test.js should pass jscs', function () {
    ok(true, 'unit/models/new-platform-flexberry-g-i-s-map-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-map-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/models/new-platform-flexberry-g-i-s-map-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/models/new-platform-flexberry-g-i-s-map-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-parameter-metadata-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForModel)('new-platform-flexberry-g-i-s-parameter-metadata', 'Unit | Model | new-platform-flexberry-g-i-s-parameter-metadata', {
    // Specify the other units that are required for this test.
    needs: ['model:custom-inflector-rules', 'model:new-platform-flexberry-g-i-s-layer-link', 'model:new-platform-flexberry-g-i-s-layer-metadata', 'model:new-platform-flexberry-g-i-s-link-metadata', 'model:new-platform-flexberry-g-i-s-link-parameter', 'model:new-platform-flexberry-g-i-s-map-layer', 'model:new-platform-flexberry-g-i-s-map-object-setting', 'model:new-platform-flexberry-g-i-s-map', 'model:new-platform-flexberry-g-i-s-parameter-metadata']
  });

  (0, _emberQunit.test)('it exists', function (assert) {
    var model = this.subject();

    // let store = this.store();
    assert.ok(!!model);
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-parameter-metadata-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/models');
  test('unit/models/new-platform-flexberry-g-i-s-parameter-metadata-test.js should pass jscs', function () {
    ok(true, 'unit/models/new-platform-flexberry-g-i-s-parameter-metadata-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/models/new-platform-flexberry-g-i-s-parameter-metadata-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/models/new-platform-flexberry-g-i-s-parameter-metadata-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/models/new-platform-flexberry-g-i-s-parameter-metadata-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/routes/edit-map-new-test', ['exports', 'ember-flexberry-gis/routes/edit-map-new', 'qunit'], function (exports, _emberFlexberryGisRoutesEditMapNew, _qunit) {

  (0, _qunit.module)('Unit | Route | edit-map-new');

  (0, _qunit.test)('it exists', function (assert) {
    var route = _emberFlexberryGisRoutesEditMapNew['default'].create({});
    assert.ok(route);
  });
});
define('dummy/tests/unit/routes/edit-map-new-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/routes');
  test('unit/routes/edit-map-new-test.js should pass jscs', function () {
    ok(true, 'unit/routes/edit-map-new-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/routes/edit-map-new-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/routes/edit-map-new-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/routes/edit-map-new-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/routes/edit-map-test', ['exports', 'ember-flexberry-gis/routes/edit-map', 'qunit'], function (exports, _emberFlexberryGisRoutesEditMap, _qunit) {

  (0, _qunit.module)('Unit | Route | edit-map');

  (0, _qunit.test)('it exists', function (assert) {
    var route = _emberFlexberryGisRoutesEditMap['default'].create({});
    assert.ok(route);
  });
});
define('dummy/tests/unit/routes/edit-map-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/routes');
  test('unit/routes/edit-map-test.js should pass jscs', function () {
    ok(true, 'unit/routes/edit-map-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/routes/edit-map-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/routes/edit-map-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/routes/edit-map-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/routes/gis-search-form-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleFor)('route:gis-search-form', 'Unit | Route | gis search form', {
    // Specify the other units that are required for this test.
    // needs: ['controller:foo']
  });

  (0, _emberQunit.test)('it exists', function (assert) {
    var route = this.subject();
    assert.ok(route);
  });
});
define('dummy/tests/unit/routes/gis-search-form-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/routes');
  test('unit/routes/gis-search-form-test.js should pass jscs', function () {
    ok(true, 'unit/routes/gis-search-form-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/routes/gis-search-form-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/routes/gis-search-form-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/routes/gis-search-form-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/routes/list-map-test', ['exports', 'ember-flexberry-gis/routes/list-map', 'qunit'], function (exports, _emberFlexberryGisRoutesListMap, _qunit) {

  (0, _qunit.module)('Unit | Route | list-map');

  (0, _qunit.test)('it exists', function (assert) {
    var route = _emberFlexberryGisRoutesListMap['default'].create({});
    assert.ok(route);
  });
});
define('dummy/tests/unit/routes/list-map-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/routes');
  test('unit/routes/list-map-test.js should pass jscs', function () {
    ok(true, 'unit/routes/list-map-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/routes/list-map-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/routes/list-map-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/routes/list-map-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-layer-link-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForModel)('new-platform-flexberry-g-i-s-layer-link', 'Unit | Serializer | new-platform-flexberry-g-i-s-layer-link', {
    // Specify the other units that are required for this test.
    needs: ['serializer:new-platform-flexberry-g-i-s-layer-link', 'transform:file', 'transform:decimal', 'transform:json', 'model:custom-inflector-rules', 'model:new-platform-flexberry-g-i-s-layer-link', 'model:new-platform-flexberry-g-i-s-layer-metadata', 'model:new-platform-flexberry-g-i-s-link-metadata', 'model:new-platform-flexberry-g-i-s-link-parameter', 'model:new-platform-flexberry-g-i-s-map-layer', 'model:new-platform-flexberry-g-i-s-map-object-setting', 'model:new-platform-flexberry-g-i-s-map', 'model:new-platform-flexberry-g-i-s-parameter-metadata']
  });

  // Replace this with your real tests.
  (0, _emberQunit.test)('it serializes records', function (assert) {
    var record = this.subject();

    var serializedRecord = record.serialize();

    assert.ok(serializedRecord);
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-layer-link-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/serializers');
  test('unit/serializers/new-platform-flexberry-g-i-s-layer-link-test.js should pass jscs', function () {
    ok(true, 'unit/serializers/new-platform-flexberry-g-i-s-layer-link-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-layer-link-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/serializers/new-platform-flexberry-g-i-s-layer-link-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/serializers/new-platform-flexberry-g-i-s-layer-link-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-layer-metadata-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForModel)('new-platform-flexberry-g-i-s-layer-metadata', 'Unit | Serializer | new-platform-flexberry-g-i-s-layer-metadata', {
    // Specify the other units that are required for this test.
    needs: ['serializer:new-platform-flexberry-g-i-s-layer-metadata', 'transform:file', 'transform:decimal', 'transform:json', 'model:custom-inflector-rules', 'model:new-platform-flexberry-g-i-s-layer-link', 'model:new-platform-flexberry-g-i-s-layer-metadata', 'model:new-platform-flexberry-g-i-s-link-metadata', 'model:new-platform-flexberry-g-i-s-link-parameter', 'model:new-platform-flexberry-g-i-s-map-layer', 'model:new-platform-flexberry-g-i-s-map-object-setting', 'model:new-platform-flexberry-g-i-s-map', 'model:new-platform-flexberry-g-i-s-parameter-metadata']
  });

  // Replace this with your real tests.
  (0, _emberQunit.test)('it serializes records', function (assert) {
    var record = this.subject();

    var serializedRecord = record.serialize();

    assert.ok(serializedRecord);
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-layer-metadata-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/serializers');
  test('unit/serializers/new-platform-flexberry-g-i-s-layer-metadata-test.js should pass jscs', function () {
    ok(true, 'unit/serializers/new-platform-flexberry-g-i-s-layer-metadata-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-layer-metadata-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/serializers/new-platform-flexberry-g-i-s-layer-metadata-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/serializers/new-platform-flexberry-g-i-s-layer-metadata-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-link-metadata-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForModel)('new-platform-flexberry-g-i-s-link-metadata', 'Unit | Serializer | new-platform-flexberry-g-i-s-link-metadata', {
    // Specify the other units that are required for this test.
    needs: ['serializer:new-platform-flexberry-g-i-s-link-metadata', 'transform:file', 'transform:decimal', 'transform:json', 'model:custom-inflector-rules', 'model:new-platform-flexberry-g-i-s-layer-link', 'model:new-platform-flexberry-g-i-s-layer-metadata', 'model:new-platform-flexberry-g-i-s-link-metadata', 'model:new-platform-flexberry-g-i-s-link-parameter', 'model:new-platform-flexberry-g-i-s-map-layer', 'model:new-platform-flexberry-g-i-s-map-object-setting', 'model:new-platform-flexberry-g-i-s-map', 'model:new-platform-flexberry-g-i-s-parameter-metadata']
  });

  // Replace this with your real tests.
  (0, _emberQunit.test)('it serializes records', function (assert) {
    var record = this.subject();

    var serializedRecord = record.serialize();

    assert.ok(serializedRecord);
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-link-metadata-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/serializers');
  test('unit/serializers/new-platform-flexberry-g-i-s-link-metadata-test.js should pass jscs', function () {
    ok(true, 'unit/serializers/new-platform-flexberry-g-i-s-link-metadata-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-link-metadata-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/serializers/new-platform-flexberry-g-i-s-link-metadata-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/serializers/new-platform-flexberry-g-i-s-link-metadata-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-link-parameter-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForModel)('new-platform-flexberry-g-i-s-link-parameter', 'Unit | Serializer | new-platform-flexberry-g-i-s-link-parameter', {
    // Specify the other units that are required for this test.
    needs: ['serializer:new-platform-flexberry-g-i-s-link-parameter', 'transform:file', 'transform:decimal', 'transform:json', 'model:custom-inflector-rules', 'model:new-platform-flexberry-g-i-s-layer-link', 'model:new-platform-flexberry-g-i-s-layer-metadata', 'model:new-platform-flexberry-g-i-s-link-metadata', 'model:new-platform-flexberry-g-i-s-link-parameter', 'model:new-platform-flexberry-g-i-s-map-layer', 'model:new-platform-flexberry-g-i-s-map-object-setting', 'model:new-platform-flexberry-g-i-s-map', 'model:new-platform-flexberry-g-i-s-parameter-metadata']
  });

  // Replace this with your real tests.
  (0, _emberQunit.test)('it serializes records', function (assert) {
    var record = this.subject();

    var serializedRecord = record.serialize();

    assert.ok(serializedRecord);
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-link-parameter-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/serializers');
  test('unit/serializers/new-platform-flexberry-g-i-s-link-parameter-test.js should pass jscs', function () {
    ok(true, 'unit/serializers/new-platform-flexberry-g-i-s-link-parameter-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-link-parameter-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/serializers/new-platform-flexberry-g-i-s-link-parameter-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/serializers/new-platform-flexberry-g-i-s-link-parameter-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-map-layer-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForModel)('new-platform-flexberry-g-i-s-map-layer', 'Unit | Serializer | new-platform-flexberry-g-i-s-map-layer', {
    // Specify the other units that are required for this test.
    needs: ['serializer:new-platform-flexberry-g-i-s-map-layer', 'transform:file', 'transform:decimal', 'transform:json', 'model:custom-inflector-rules', 'model:new-platform-flexberry-g-i-s-layer-link', 'model:new-platform-flexberry-g-i-s-layer-metadata', 'model:new-platform-flexberry-g-i-s-link-metadata', 'model:new-platform-flexberry-g-i-s-link-parameter', 'model:new-platform-flexberry-g-i-s-map-layer', 'model:new-platform-flexberry-g-i-s-map-object-setting', 'model:new-platform-flexberry-g-i-s-map', 'model:new-platform-flexberry-g-i-s-parameter-metadata']
  });

  // Replace this with your real tests.
  (0, _emberQunit.test)('it serializes records', function (assert) {
    var record = this.subject();

    var serializedRecord = record.serialize();

    assert.ok(serializedRecord);
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-map-layer-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/serializers');
  test('unit/serializers/new-platform-flexberry-g-i-s-map-layer-test.js should pass jscs', function () {
    ok(true, 'unit/serializers/new-platform-flexberry-g-i-s-map-layer-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-map-layer-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/serializers/new-platform-flexberry-g-i-s-map-layer-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/serializers/new-platform-flexberry-g-i-s-map-layer-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-map-object-setting-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForModel)('new-platform-flexberry-g-i-s-map-object-setting', 'Unit | Serializer | new-platform-flexberry-g-i-s-map-object-setting', {
    // Specify the other units that are required for this test.
    needs: ['serializer:new-platform-flexberry-g-i-s-map-object-setting', 'transform:file', 'transform:decimal', 'transform:json', 'model:custom-inflector-rules', 'model:new-platform-flexberry-g-i-s-layer-link', 'model:new-platform-flexberry-g-i-s-layer-metadata', 'model:new-platform-flexberry-g-i-s-link-metadata', 'model:new-platform-flexberry-g-i-s-link-parameter', 'model:new-platform-flexberry-g-i-s-map-layer', 'model:new-platform-flexberry-g-i-s-map-object-setting', 'model:new-platform-flexberry-g-i-s-map', 'model:new-platform-flexberry-g-i-s-parameter-metadata']
  });

  // Replace this with your real tests.
  (0, _emberQunit.test)('it serializes records', function (assert) {
    var record = this.subject();

    var serializedRecord = record.serialize();

    assert.ok(serializedRecord);
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-map-object-setting-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/serializers');
  test('unit/serializers/new-platform-flexberry-g-i-s-map-object-setting-test.js should pass jscs', function () {
    ok(true, 'unit/serializers/new-platform-flexberry-g-i-s-map-object-setting-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-map-object-setting-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/serializers/new-platform-flexberry-g-i-s-map-object-setting-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/serializers/new-platform-flexberry-g-i-s-map-object-setting-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-map-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForModel)('new-platform-flexberry-g-i-s-map', 'Unit | Serializer | new-platform-flexberry-g-i-s-map', {
    // Specify the other units that are required for this test.
    needs: ['serializer:new-platform-flexberry-g-i-s-map', 'transform:file', 'transform:decimal', 'transform:json', 'model:custom-inflector-rules', 'model:new-platform-flexberry-g-i-s-layer-link', 'model:new-platform-flexberry-g-i-s-layer-metadata', 'model:new-platform-flexberry-g-i-s-link-metadata', 'model:new-platform-flexberry-g-i-s-link-parameter', 'model:new-platform-flexberry-g-i-s-map-layer', 'model:new-platform-flexberry-g-i-s-map-object-setting', 'model:new-platform-flexberry-g-i-s-map', 'model:new-platform-flexberry-g-i-s-parameter-metadata']
  });

  // Replace this with your real tests.
  (0, _emberQunit.test)('it serializes records', function (assert) {
    var record = this.subject();

    var serializedRecord = record.serialize();

    assert.ok(serializedRecord);
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-map-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/serializers');
  test('unit/serializers/new-platform-flexberry-g-i-s-map-test.js should pass jscs', function () {
    ok(true, 'unit/serializers/new-platform-flexberry-g-i-s-map-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-map-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/serializers/new-platform-flexberry-g-i-s-map-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/serializers/new-platform-flexberry-g-i-s-map-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-parameter-metadata-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleForModel)('new-platform-flexberry-g-i-s-parameter-metadata', 'Unit | Serializer | new-platform-flexberry-g-i-s-parameter-metadata', {
    // Specify the other units that are required for this test.
    needs: ['serializer:new-platform-flexberry-g-i-s-parameter-metadata', 'transform:file', 'transform:decimal', 'transform:json', 'model:custom-inflector-rules', 'model:new-platform-flexberry-g-i-s-layer-link', 'model:new-platform-flexberry-g-i-s-layer-metadata', 'model:new-platform-flexberry-g-i-s-link-metadata', 'model:new-platform-flexberry-g-i-s-link-parameter', 'model:new-platform-flexberry-g-i-s-map-layer', 'model:new-platform-flexberry-g-i-s-map-object-setting', 'model:new-platform-flexberry-g-i-s-map', 'model:new-platform-flexberry-g-i-s-parameter-metadata']
  });

  // Replace this with your real tests.
  (0, _emberQunit.test)('it serializes records', function (assert) {
    var record = this.subject();

    var serializedRecord = record.serialize();

    assert.ok(serializedRecord);
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-parameter-metadata-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/serializers');
  test('unit/serializers/new-platform-flexberry-g-i-s-parameter-metadata-test.js should pass jscs', function () {
    ok(true, 'unit/serializers/new-platform-flexberry-g-i-s-parameter-metadata-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/serializers/new-platform-flexberry-g-i-s-parameter-metadata-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/serializers/new-platform-flexberry-g-i-s-parameter-metadata-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/serializers/new-platform-flexberry-g-i-s-parameter-metadata-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/services/local-storage-test', ['exports', 'ember-qunit'], function (exports, _emberQunit) {

  (0, _emberQunit.moduleFor)('service:local-storage', 'Unit | Service | local storage', {
    // Specify the other units that are required for this test.
    // needs: ['service:foo']
  });

  // Replace this with your real tests.
  (0, _emberQunit.test)('it exists', function (assert) {
    var service = this.subject();
    assert.ok(service);
  });
});
define('dummy/tests/unit/services/local-storage-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/services');
  test('unit/services/local-storage-test.js should pass jscs', function () {
    ok(true, 'unit/services/local-storage-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/services/local-storage-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/services/local-storage-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/services/local-storage-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/services/map-store-test', ['exports', 'ember', 'ember-qunit', 'dummy/tests/helpers/start-app'], function (exports, _ember, _emberQunit, _dummyTestsHelpersStartApp) {

  var App = undefined;

  (0, _emberQunit.moduleFor)('service:map-store', 'Unit | Service | map store', {
    // Specify the other units that are required for this test.
    needs: ['model:custom-inflector-rules', 'model:new-platform-flexberry-g-i-s-layer-link', 'model:new-platform-flexberry-g-i-s-layer-metadata', 'model:new-platform-flexberry-g-i-s-link-metadata', 'model:new-platform-flexberry-g-i-s-link-parameter', 'model:new-platform-flexberry-g-i-s-map-layer', 'model:new-platform-flexberry-g-i-s-map-object-setting', 'model:new-platform-flexberry-g-i-s-map', 'model:new-platform-flexberry-g-i-s-parameter-metadata'],

    beforeEach: function beforeEach() {
      App = (0, _dummyTestsHelpersStartApp['default'])();
    },

    afterEach: function afterEach() {
      _ember['default'].run(App, 'destroy');
    }
  });

  // Replace this with your real tests.
  (0, _emberQunit.test)('it exists', function (assert) {
    var _this = this;

    _ember['default'].run(function () {
      var service = _this.subject();
      assert.ok(service);
    });
  });

  (0, _emberQunit.test)('it should have property osmmap after init', function (assert) {
    var _this2 = this;

    _ember['default'].run(function () {
      assert.expect(3);
      var service = _this2.subject();
      var defaultMap = service.get('osmmap');
      assert.ok(defaultMap, 'Map created');
      assert.equal(defaultMap.get('mapLayer').length, 1, 'it have one map layer');
      assert.equal(defaultMap.get('mapLayer').objectAt(0).get('type'), 'osm', 'and this layer of type osm');
    });
  });
});
define('dummy/tests/unit/services/map-store-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/services');
  test('unit/services/map-store-test.js should pass jscs', function () {
    ok(true, 'unit/services/map-store-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/services/map-store-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/services/map-store-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/services/map-store-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/utils/download-file-test', ['exports', 'ember', 'qunit', 'sinon', 'ember-flexberry-gis/coordinate-reference-systems/epsg-4326', 'ember-flexberry-gis/utils/download-file'], function (exports, _ember, _qunit, _sinon, _emberFlexberryGisCoordinateReferenceSystemsEpsg4326, _emberFlexberryGisUtilsDownloadFile) {

  (0, _qunit.module)('Unit | Utility | download file');

  var crsFactory32640 = {
    code: 'EPSG:32640',
    definition: '+proj=utm +zone=40 +datum=WGS84 +units=m +no_defs',
    create: function create() {
      var crs = L.extend({}, new L.Proj.CRS(this.code, this.definition), {
        scale: function scale(zoom) {
          return 256 * Math.pow(2, zoom);
        },
        zoom: function zoom(scale) {
          return Math.log(scale / 256) / Math.LN2;
        }
      });
      return crs;
    }
  };

  (0, _qunit.test)('test method downloadFile for wfs', function (assert) {
    assert.expect(6);
    var done = assert.async(1);

    var layerModelWfs = _ember['default'].Object.create({
      type: 'wfs',
      settingsAsObject: {
        url: 'geoserverUrl',
        typeNS: 'testTypeNS',
        typeName: 'layerWfs',
        geometryField: 'geometryField'
      },
      name: 'layerWfsName',
      headers: {}
    });

    var stubAjax = _sinon['default'].stub(_ember['default'].$, 'ajax');
    stubAjax.yieldsTo('success', 'blob');

    var result = (0, _emberFlexberryGisUtilsDownloadFile.downloadFile)(layerModelWfs, ['1'], 'JSON', { crs: crsFactory32640.create() }, { crs: _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default'].create() }, '/api/featureexport');

    assert.ok(result instanceof _ember['default'].RSVP.Promise);
    result.then(function (res) {
      assert.equal(res.fileName, 'layerWfsName.json');
      assert.equal(res.blob, 'blob');
      assert.equal(stubAjax.callCount, 1);
      assert.equal(stubAjax.getCall(0).args[0].url, '/api/featureexport');
      var data = '<wfs:GetFeature xmlns:wfs="http://www.opengis.net/wfs" service="WFS" version="1.1.0" outputFormat="application/json">' + '<wfs:Query typeName="testTypeNS:layerWfs" srsName="EPSG:32640"><ogc:Filter xmlns:ogc="http://www.opengis.net/ogc"><Or>' + '<ogc:GmlObjectId xmlns:gml="http://www.opengis.net/gml" gml:id="1"/>' + '</Or></ogc:Filter></wfs:Query><geoserver url="geoserverUrl"/></wfs:GetFeature>';
      assert.equal(stubAjax.getCall(0).args[0].data, data);
      done();
      stubAjax.restore();
    });
  });

  (0, _qunit.test)('test method downloadFile for odata', function (assert) {
    assert.expect(6);
    var done = assert.async(1);

    var layerModelOdata = _ember['default'].Object.create({
      type: 'odata-vector',
      settingsAsObject: {
        odataClass: 'modelClassName',
        odataUrl: 'odataUrl'
      },
      name: 'layerOdataName',
      headers: {}
    });

    var stubAjax = _sinon['default'].stub(_ember['default'].$, 'ajax');
    stubAjax.yieldsTo('success', 'blob');

    var result = (0, _emberFlexberryGisUtilsDownloadFile.downloadFile)(layerModelOdata, ['1', '2'], 'CSV', { crs: _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default'].create() }, { crs: crsFactory32640.create() }, '/api/featureexport');

    assert.ok(result instanceof _ember['default'].RSVP.Promise);
    result.then(function (res) {
      assert.equal(res.fileName, 'layerOdataName.csv');
      assert.equal(res.blob, 'blob');
      assert.equal(stubAjax.callCount, 1);
      assert.equal(stubAjax.getCall(0).args[0].url, '/api/featureexport');
      var data = '<odata outputFormat="CSV"><layer odataClass="modelClassName" odataUrl="odataUrl" srsName="EPSG:4326" ' + 'layerName="layerOdataName" srslayer="EPSG:32640"><pkList><pk primarykey="1"/><pk primarykey="2"/></pkList></layer></odata>';
      assert.equal(stubAjax.getCall(0).args[0].data, data);
      done();
      stubAjax.restore();
    });
  });
});
define('dummy/tests/unit/utils/download-file-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/utils');
  test('unit/utils/download-file-test.js should pass jscs', function () {
    ok(true, 'unit/utils/download-file-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/utils/download-file-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/utils/download-file-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/utils/download-file-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/utils/get-crs-by-name-test', ['exports', 'ember', 'ember-flexberry-gis/utils/get-crs-by-name', 'qunit', 'ember-flexberry-gis/coordinate-reference-systems/epsg-4326', 'sinon'], function (exports, _ember, _emberFlexberryGisUtilsGetCrsByName, _qunit, _emberFlexberryGisCoordinateReferenceSystemsEpsg4326, _sinon) {

  (0, _qunit.module)('Unit | Utility | get crs by name');

  var crsFactory32640 = {
    code: 'EPSG:32640',
    definition: '+proj=utm +zone=40 +datum=WGS84 +units=m +no_defs',
    create: function create() {
      var crs = L.extend({}, new L.Proj.CRS(this.code, this.definition), {
        scale: function scale(zoom) {
          return 256 * Math.pow(2, zoom);
        },
        zoom: function zoom(scale) {
          return Math.log(scale / 256) / Math.LN2;
        }
      });
      return crs;
    }
  };

  (0, _qunit.test)('test method getCrsByName for EPSG:32640', function (assert) {
    var crsName = 'EPSG:32640';
    var that = {};
    var ownerStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    ownerStub.returns({
      knownForType: function knownForType() {
        return {
          'epsg4326': _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default'],
          'epsg32640': crsFactory32640
        };
      }
    });

    var crsResult = (0, _emberFlexberryGisUtilsGetCrsByName.getCrsByName)(crsName, that);

    assert.ok(crsResult.crs);
    assert.ok(crsResult.definition);
    assert.equal(crsResult.crs.code, 'EPSG:32640');
    assert.equal(crsResult.definition, '+proj=utm +zone=40 +datum=WGS84 +units=m +no_defs');
    ownerStub.restore();
  });

  (0, _qunit.test)('test method getCrsByName for EPSG:4326', function (assert) {
    var crsName = 'EPSG:4326';
    var that = {};
    var ownerStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    ownerStub.returns({
      knownForType: function knownForType() {
        return {
          'epsg4326': _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default'],
          'epsg32640': crsFactory32640
        };
      }
    });

    var crsResult = (0, _emberFlexberryGisUtilsGetCrsByName.getCrsByName)(crsName, that);

    assert.ok(crsResult.crs);
    assert.ok(crsResult.definition);
    assert.equal(crsResult.crs.code, 'EPSG:4326');
    assert.equal(crsResult.definition, '+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees');
    ownerStub.restore();
  });
});
define('dummy/tests/unit/utils/get-crs-by-name-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/utils');
  test('unit/utils/get-crs-by-name-test.js should pass jscs', function () {
    ok(true, 'unit/utils/get-crs-by-name-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/utils/get-crs-by-name-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/utils/get-crs-by-name-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/utils/get-crs-by-name-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/utils/lat-lng-to-coord-test', ['exports', 'ember-flexberry-gis/utils/lat-lng-to-coord', 'ember-flexberry-gis/coordinate-reference-systems/epsg-4326', 'qunit', 'npm:jsts'], function (exports, _emberFlexberryGisUtilsLatLngToCoord, _emberFlexberryGisCoordinateReferenceSystemsEpsg4326, _qunit, _npmJsts) {

  (0, _qunit.module)('Unit | Utility | lat lng to coord');

  var crs = _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default'].create();
  var precision = 0;

  (0, _qunit.test)('test method latLngToCoords for Point', function (assert) {
    //Arrange
    var latlng = L.latLng(30, 10);
    var latlngWithAlt = L.latLng(30, 10, 20);
    var coordinatesFunction = function coordinatesFunction(coord, altitude) {
      return altitude ? new _npmJsts['default'].geom.Coordinate(coord.x, coord.y, altitude) : new _npmJsts['default'].geom.Coordinate(coord.x, coord.y);
    };

    //Act
    var resCoord = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngToCoords)(latlng, crs, precision);
    var resCoordWithAlt = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngToCoords)(latlngWithAlt, crs, precision);
    var resCoordWithFunc = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngToCoords)(latlng, crs, precision, coordinatesFunction);
    var resCoordWithAltAndFunc = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngToCoords)(latlngWithAlt, crs, precision, coordinatesFunction);

    //Assert
    assert.deepEqual(resCoord, [10, 30]);
    assert.deepEqual(resCoordWithAlt, [10, 30, 20]);
    assert.deepEqual(resCoordWithFunc.toString(), '(10, 30, undefined)');
    assert.deepEqual(resCoordWithAltAndFunc.toString(), '(10, 30, 20)');
  });

  (0, _qunit.test)('test method latLngsToCoords for LineString', function (assert) {
    //Arrange
    var latlngs = [L.latLng(30, 10), L.latLng(10, 30), L.latLng(40, 40)];
    var latlngsWithAlt = [L.latLng(30, 10, 20), L.latLng(10, 30, 21), L.latLng(40, 40, 22)];
    var coordinatesFunction = function coordinatesFunction(coord, altitude) {
      return altitude ? new _npmJsts['default'].geom.Coordinate(coord.x, coord.y, altitude) : new _npmJsts['default'].geom.Coordinate(coord.x, coord.y);
    };

    var levelsDeep = 0;
    var closed = false;

    //Act
    var resCoord = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngs, crs, levelsDeep, closed, precision);
    var resCoordWithAlt = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngsWithAlt, crs, levelsDeep, closed, precision);
    var resCoordWithFunc = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngs, crs, levelsDeep, closed, precision, coordinatesFunction);
    var resCoordWithAltAndFunc = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngsWithAlt, crs, levelsDeep, closed, precision, coordinatesFunction);

    //Assert
    assert.deepEqual(resCoord, [[10, 30], [30, 10], [40, 40]]);
    assert.deepEqual(resCoordWithAlt, [[10, 30, 20], [30, 10, 21], [40, 40, 22]]);
    assert.deepEqual(resCoordWithFunc.toString(), '(10, 30, undefined),(30, 10, undefined),(40, 40, undefined)');
    assert.deepEqual(resCoordWithAltAndFunc.toString(), '(10, 30, 20),(30, 10, 21),(40, 40, 22)');
  });

  (0, _qunit.test)('test method latLngsToCoords for MultiLineString', function (assert) {
    //Arrange
    var latlngs = [[L.latLng(10, 10), L.latLng(20, 20), L.latLng(10, 40)], [L.latLng(40, 40), L.latLng(30, 30), L.latLng(40, 20)]];
    var latlngsWithAlt = [[L.latLng(10, 10, 20), L.latLng(20, 20, 21), L.latLng(10, 40, 22)], [L.latLng(40, 40, 23), L.latLng(30, 30, 24), L.latLng(40, 20, 25)]];
    var coordinatesFunction = function coordinatesFunction(coord, altitude) {
      return altitude ? new _npmJsts['default'].geom.Coordinate(coord.x, coord.y, altitude) : new _npmJsts['default'].geom.Coordinate(coord.x, coord.y);
    };

    var levelsDeep = 1;
    var closed = false;

    //Act
    var resCoord = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngs, crs, levelsDeep, closed, precision);
    var resCoordWithAlt = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngsWithAlt, crs, levelsDeep, closed, precision);
    var resCoordWithFunc = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngs, crs, levelsDeep, closed, precision, coordinatesFunction);
    var resCoordWithAltAndFunc = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngsWithAlt, crs, levelsDeep, closed, precision, coordinatesFunction);

    //Assert
    assert.deepEqual(resCoord, [[[10, 10], [20, 20], [40, 10]], [[40, 40], [30, 30], [20, 40]]]);
    assert.deepEqual(resCoordWithAlt, [[[10, 10, 20], [20, 20, 21], [40, 10, 22]], [[40, 40, 23], [30, 30, 24], [20, 40, 25]]]);
    assert.equal(resCoordWithFunc.length, 2);
    assert.deepEqual(resCoordWithFunc[0].toString(), '(10, 10, undefined),(20, 20, undefined),(40, 10, undefined)');
    assert.deepEqual(resCoordWithFunc[1].toString(), '(40, 40, undefined),(30, 30, undefined),(20, 40, undefined)');
    assert.equal(resCoordWithAltAndFunc.length, 2);
    assert.deepEqual(resCoordWithAltAndFunc[0].toString(), '(10, 10, 20),(20, 20, 21),(40, 10, 22)');
    assert.deepEqual(resCoordWithAltAndFunc[1].toString(), '(40, 40, 23),(30, 30, 24),(20, 40, 25)');
  });

  (0, _qunit.test)('test method latLngsToCoords for Polygon without hole', function (assert) {
    //Arrange
    var latlngs = [[L.latLng(30, 10), L.latLng(40, 40), L.latLng(20, 40), L.latLng(10, 20)]];
    var latlngsWithAlt = [[L.latLng(30, 10, 20), L.latLng(40, 40, 21), L.latLng(20, 40, 22), L.latLng(10, 20, 23)]];
    var coordinatesFunction = function coordinatesFunction(coord, altitude) {
      return altitude ? new _npmJsts['default'].geom.Coordinate(coord.x, coord.y, altitude) : new _npmJsts['default'].geom.Coordinate(coord.x, coord.y);
    };

    var levelsDeep = 1;
    var closed = true;

    //Act
    var resCoord = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngs, crs, levelsDeep, closed, precision);
    var resCoordWithAlt = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngsWithAlt, crs, levelsDeep, closed, precision);
    var resCoordWithFunc = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngs, crs, levelsDeep, closed, precision, coordinatesFunction);
    var resCoordWithAltAndFunc = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngsWithAlt, crs, levelsDeep, closed, precision, coordinatesFunction);

    //Assert
    assert.deepEqual(resCoord, [[[10, 30], [40, 40], [40, 20], [20, 10], [10, 30]]]);
    assert.deepEqual(resCoordWithAlt, [[[10, 30, 20], [40, 40, 21], [40, 20, 22], [20, 10, 23], [10, 30, 20]]]);
    assert.deepEqual(resCoordWithFunc.toString(), '(10, 30, undefined),(40, 40, undefined),(40, 20, undefined)' + ',(20, 10, undefined),(10, 30, undefined)');
    assert.deepEqual(resCoordWithAltAndFunc.toString(), '(10, 30, 20),(40, 40, 21),(40, 20, 22)' + ',(20, 10, 23),(10, 30, 20)');
  });

  (0, _qunit.test)('test method latLngsToCoords for Polygon with hole', function (assert) {
    //Arrange
    var latlngs = [[L.latLng(35, 10), L.latLng(45, 45), L.latLng(15, 40), L.latLng(10, 20)], [L.latLng(20, 30), L.latLng(35, 35), L.latLng(30, 20)]];
    var latlngsWithAlt = [[L.latLng(35, 10, 20), L.latLng(45, 45, 21), L.latLng(15, 40, 22), L.latLng(10, 20, 23)], [L.latLng(20, 30, 24), L.latLng(35, 35, 25), L.latLng(30, 20, 26)]];
    var coordinatesFunction = function coordinatesFunction(coord, altitude) {
      return altitude ? new _npmJsts['default'].geom.Coordinate(coord.x, coord.y, altitude) : new _npmJsts['default'].geom.Coordinate(coord.x, coord.y);
    };

    var levelsDeep = 1;
    var closed = true;

    //Act
    var resCoord = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngs, crs, levelsDeep, closed, precision);
    var resCoordWithAlt = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngsWithAlt, crs, levelsDeep, closed, precision);
    var resCoordWithFunc = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngs, crs, levelsDeep, closed, precision, coordinatesFunction);
    var resCoordWithAltAndFunc = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngsWithAlt, crs, levelsDeep, closed, precision, coordinatesFunction);

    //Assert
    assert.deepEqual(resCoord, [[[10, 35], [45, 45], [40, 15], [20, 10], [10, 35]], [[30, 20], [35, 35], [20, 30], [30, 20]]]);
    assert.deepEqual(resCoordWithAlt, [[[10, 35, 20], [45, 45, 21], [40, 15, 22], [20, 10, 23], [10, 35, 20]], [[30, 20, 24], [35, 35, 25], [20, 30, 26], [30, 20, 24]]]);
    assert.deepEqual(resCoordWithFunc[0].toString(), '(10, 35, undefined),(45, 45, undefined),(40, 15, undefined)' + ',(20, 10, undefined),(10, 35, undefined)');
    assert.deepEqual(resCoordWithFunc[1].toString(), '(30, 20, undefined),(35, 35, undefined),(20, 30, undefined),' + '(30, 20, undefined)');
    assert.deepEqual(resCoordWithAltAndFunc[0].toString(), '(10, 35, 20),(45, 45, 21),(40, 15, 22)' + ',(20, 10, 23),(10, 35, 20)');
    assert.deepEqual(resCoordWithAltAndFunc[1].toString(), '(30, 20, 24),(35, 35, 25),(20, 30, 26),' + '(30, 20, 24)');
  });

  (0, _qunit.test)('test method latLngsToCoords for MultiPolygon without hole', function (assert) {
    //Arrange
    var latlngs = [[[L.latLng(30, 20), L.latLng(45, 40), L.latLng(10, 40)]], [[L.latLng(15, 5), L.latLng(40, 10), L.latLng(10, 20), L.latLng(5, 10)]]];
    var latlngsWithAlt = [[[L.latLng(30, 20, 20), L.latLng(45, 40, 21), L.latLng(10, 40, 22)]], [[L.latLng(15, 5, 23), L.latLng(40, 10, 24), L.latLng(10, 20, 25), L.latLng(5, 10, 26)]]];
    var coordinatesFunction = function coordinatesFunction(coord, altitude) {
      return altitude ? new _npmJsts['default'].geom.Coordinate(coord.x, coord.y, altitude) : new _npmJsts['default'].geom.Coordinate(coord.x, coord.y);
    };

    var levelsDeep = 2;
    var closed = true;

    //Act
    var resCoord = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngs, crs, levelsDeep, closed, precision);
    var resCoordWithAlt = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngsWithAlt, crs, levelsDeep, closed, precision);
    var resCoordWithFunc = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngs, crs, levelsDeep, closed, precision, coordinatesFunction);
    var resCoordWithAltAndFunc = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngsWithAlt, crs, levelsDeep, closed, precision, coordinatesFunction);

    //Assert
    assert.deepEqual(resCoord, [[[[20, 30], [40, 45], [40, 10], [20, 30]]], [[[5, 15], [10, 40], [20, 10], [10, 5], [5, 15]]]]);
    assert.deepEqual(resCoordWithAlt, [[[[20, 30, 20], [40, 45, 21], [40, 10, 22], [20, 30, 20]]], [[[5, 15, 23], [10, 40, 24], [20, 10, 25], [10, 5, 26], [5, 15, 23]]]]);
    assert.deepEqual(resCoordWithFunc[0][0].toString(), '(20, 30, undefined),(40, 45, undefined),(40, 10, undefined),(20, 30, undefined)');
    assert.deepEqual(resCoordWithFunc[1][0].toString(), '(5, 15, undefined),(10, 40, undefined),(20, 10, undefined),(10, 5, undefined)' + ',(5, 15, undefined)');
    assert.deepEqual(resCoordWithAltAndFunc[0][0].toString(), '(20, 30, 20),(40, 45, 21),(40, 10, 22),(20, 30, 20)');
    assert.deepEqual(resCoordWithAltAndFunc[1][0].toString(), '(5, 15, 23),(10, 40, 24),(20, 10, 25),(10, 5, 26)' + ',(5, 15, 23)');
  });

  (0, _qunit.test)('test method latLngsToCoords for MultiPolygon with hole', function (assert) {
    //Arrange
    var latlngs = [[[L.latLng(40, 40), L.latLng(20, 45), L.latLng(45, 30)]], [[L.latLng(20, 35), L.latLng(10, 30), L.latLng(10, 10), L.latLng(30, 5), L.latLng(45, 20)], [L.latLng(30, 20), L.latLng(20, 15), L.latLng(20, 25)]]];
    var latlngsWithAlt = [[[L.latLng(40, 40, 20), L.latLng(20, 45, 21), L.latLng(45, 30, 22)]], [[L.latLng(20, 35, 24), L.latLng(10, 30, 25), L.latLng(10, 10, 26), L.latLng(30, 5, 27), L.latLng(45, 20, 28)], [L.latLng(30, 20, 29), L.latLng(20, 15, 30), L.latLng(20, 25, 31)]]];
    var coordinatesFunction = function coordinatesFunction(coord, altitude) {
      return altitude ? new _npmJsts['default'].geom.Coordinate(coord.x, coord.y, altitude) : new _npmJsts['default'].geom.Coordinate(coord.x, coord.y);
    };

    var levelsDeep = 2;
    var closed = true;

    //Act
    var resCoord = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngs, crs, levelsDeep, closed, precision);
    var resCoordWithAlt = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngsWithAlt, crs, levelsDeep, closed, precision);
    var resCoordWithFunc = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngs, crs, levelsDeep, closed, precision, coordinatesFunction);
    var resCoordWithAltAndFunc = (0, _emberFlexberryGisUtilsLatLngToCoord.latLngsToCoords)(latlngsWithAlt, crs, levelsDeep, closed, precision, coordinatesFunction);

    //Assert
    assert.deepEqual(resCoord, [[[[40, 40], [45, 20], [30, 45], [40, 40]]], [[[35, 20], [30, 10], [10, 10], [5, 30], [20, 45], [35, 20]], [[20, 30], [15, 20], [25, 20], [20, 30]]]]);
    assert.deepEqual(resCoordWithAlt, [[[[40, 40, 20], [45, 20, 21], [30, 45, 22], [40, 40, 20]]], [[[35, 20, 24], [30, 10, 25], [10, 10, 26], [5, 30, 27], [20, 45, 28], [35, 20, 24]], [[20, 30, 29], [15, 20, 30], [25, 20, 31], [20, 30, 29]]]]);
    assert.deepEqual(resCoordWithFunc[0][0].toString(), '(40, 40, undefined),(45, 20, undefined),(30, 45, undefined),(40, 40, undefined)');
    assert.deepEqual(resCoordWithFunc[1][0].toString(), '(35, 20, undefined),(30, 10, undefined),(10, 10, undefined)' + ',(5, 30, undefined),(20, 45, undefined),(35, 20, undefined)');
    assert.deepEqual(resCoordWithFunc[1][1].toString(), '(20, 30, undefined),(15, 20, undefined),(25, 20, undefined),' + '(20, 30, undefined)');
    assert.deepEqual(resCoordWithAltAndFunc[0][0].toString(), '(40, 40, 20),(45, 20, 21),(30, 45, 22),(40, 40, 20)');
    assert.deepEqual(resCoordWithAltAndFunc[1][0].toString(), '(35, 20, 24),(30, 10, 25),(10, 10, 26)' + ',(5, 30, 27),(20, 45, 28),(35, 20, 24)');
    assert.deepEqual(resCoordWithAltAndFunc[1][1].toString(), '(20, 30, 29),(15, 20, 30),(25, 20, 31),' + '(20, 30, 29)');
  });
});
define('dummy/tests/unit/utils/lat-lng-to-coord-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/utils');
  test('unit/utils/lat-lng-to-coord-test.js should pass jscs', function () {
    ok(true, 'unit/utils/lat-lng-to-coord-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/utils/lat-lng-to-coord-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/utils/lat-lng-to-coord-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/utils/lat-lng-to-coord-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/utils/layer-to-ewkt-test', ['exports', 'ember-flexberry-gis/utils/layer-to-ewkt', 'ember-flexberry-gis/coordinate-reference-systems/epsg-4326', 'qunit'], function (exports, _emberFlexberryGisUtilsLayerToEwkt, _emberFlexberryGisCoordinateReferenceSystemsEpsg4326, _qunit) {

  (0, _qunit.module)('Unit | Utility | layer to ewkt');

  var crs = _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default'].create();

  (0, _qunit.test)('test method latLngsToCoords for Point', function (assert) {
    //Arrange
    var latlng = L.latLng(30, 10);
    var latlngWithAlt = L.latLng(30, 10, 20);

    //Act
    var result = (0, _emberFlexberryGisUtilsLayerToEwkt.latlngToPointEWKT)(latlng, crs);
    var resultWithAlt = (0, _emberFlexberryGisUtilsLayerToEwkt.latlngToPointEWKT)(latlngWithAlt, crs);

    //Assert
    assert.equal(result, 'SRID=4326;POINT(10 30)');
    assert.equal(resultWithAlt, 'SRID=4326;POINT(10 30 20)');
  });

  (0, _qunit.test)('test method latlngToPolylineEWKT for LineString', function (assert) {
    //Arrange
    var latlng = [L.latLng(30, 10), L.latLng(10, 30), L.latLng(40, 40)];
    var latlngWithAlt = [L.latLng(30, 10, 20), L.latLng(10, 30, 21), L.latLng(40, 40, 22)];

    //Act
    var result = (0, _emberFlexberryGisUtilsLayerToEwkt.latlngToPolylineEWKT)(latlng, crs);
    var resultWithAlt = (0, _emberFlexberryGisUtilsLayerToEwkt.latlngToPolylineEWKT)(latlngWithAlt, crs);

    //Assert
    assert.equal(result, 'SRID=4326;LINESTRING(10 30, 30 10, 40 40)');
    assert.equal(resultWithAlt, 'SRID=4326;LINESTRING(10 30 20, 30 10 21, 40 40 22)');
  });

  (0, _qunit.test)('test method latlngToPolylineEWKT for MultiLineString', function (assert) {
    //Arrange
    var latlng = [[L.latLng(10, 10), L.latLng(20, 20), L.latLng(10, 40)], [L.latLng(40, 40), L.latLng(30, 30), L.latLng(40, 20)]];
    var latlngsWithAlt = [[L.latLng(10, 10, 20), L.latLng(20, 20, 21), L.latLng(10, 40, 22)], [L.latLng(40, 40, 23), L.latLng(30, 30, 24), L.latLng(40, 20, 25)]];

    //Act
    var result = (0, _emberFlexberryGisUtilsLayerToEwkt.latlngToPolylineEWKT)(latlng, crs);
    var resultWithAlt = (0, _emberFlexberryGisUtilsLayerToEwkt.latlngToPolylineEWKT)(latlngsWithAlt, crs);

    //Assert
    assert.equal(result, 'SRID=4326;MULTILINESTRING((10 10, 20 20, 40 10), (40 40, 30 30, 20 40))');
    assert.equal(resultWithAlt, 'SRID=4326;MULTILINESTRING((10 10 20, 20 20 21, 40 10 22), (40 40 23, 30 30 24, 20 40 25))');
  });

  (0, _qunit.test)('test method latlngToPolygonEWKT for Polygon without hole', function (assert) {
    //Arrange
    var latlng = [[L.latLng(30, 10), L.latLng(40, 40), L.latLng(20, 40), L.latLng(10, 20)]];
    var latlngsWithAlt = [[L.latLng(30, 10, 20), L.latLng(40, 40, 21), L.latLng(20, 40, 22), L.latLng(10, 20, 23)]];

    //Act
    var result = (0, _emberFlexberryGisUtilsLayerToEwkt.latlngToPolygonEWKT)(latlng, crs);
    var resultWithAlt = (0, _emberFlexberryGisUtilsLayerToEwkt.latlngToPolygonEWKT)(latlngsWithAlt, crs);

    //Assert
    assert.equal(result, 'SRID=4326;POLYGON((10 30, 40 40, 40 20, 20 10, 10 30))');
    assert.equal(resultWithAlt, 'SRID=4326;POLYGON((10 30 20, 40 40 21, 40 20 22, 20 10 23, 10 30 20))');
  });

  (0, _qunit.test)('test method latlngToPolygonEWKT for Polygon with hole', function (assert) {
    //Arrange
    var latlng = [[L.latLng(35, 10), L.latLng(45, 45), L.latLng(15, 40), L.latLng(10, 20)], [L.latLng(20, 30), L.latLng(35, 35), L.latLng(30, 20)]];
    var latlngsWithAlt = [[L.latLng(35, 10, 20), L.latLng(45, 45, 21), L.latLng(15, 40, 22), L.latLng(10, 20, 23)], [L.latLng(20, 30, 24), L.latLng(35, 35, 25), L.latLng(30, 20, 26)]];

    //Act
    var result = (0, _emberFlexberryGisUtilsLayerToEwkt.latlngToPolygonEWKT)(latlng, crs);
    var resultWithAlt = (0, _emberFlexberryGisUtilsLayerToEwkt.latlngToPolygonEWKT)(latlngsWithAlt, crs);

    //Assert
    assert.equal(result, 'SRID=4326;POLYGON((10 35, 45 45, 40 15, 20 10, 10 35), (30 20, 35 35, 20 30, 30 20))');
    assert.equal(resultWithAlt, 'SRID=4326;POLYGON((10 35 20, 45 45 21, 40 15 22, 20 10 23, 10 35 20), (30 20 24, 35 35 25, 20 30 26, 30 20 24))');
  });

  (0, _qunit.test)('test method latlngToPolygonEWKT for MultiPolygon without hole', function (assert) {
    //Arrange
    var latlng = [[[L.latLng(30, 20), L.latLng(45, 40), L.latLng(10, 40)]], [[L.latLng(15, 5), L.latLng(40, 10), L.latLng(10, 20), L.latLng(5, 10)]]];
    var latlngsWithAlt = [[[L.latLng(30, 20, 20), L.latLng(45, 40, 21), L.latLng(10, 40, 22)]], [[L.latLng(15, 5, 23), L.latLng(40, 10, 24), L.latLng(10, 20, 25), L.latLng(5, 10, 26)]]];

    //Act
    var result = (0, _emberFlexberryGisUtilsLayerToEwkt.latlngToPolygonEWKT)(latlng, crs);
    var resultWithAlt = (0, _emberFlexberryGisUtilsLayerToEwkt.latlngToPolygonEWKT)(latlngsWithAlt, crs);

    //Assert
    assert.equal(result, 'SRID=4326;MULTIPOLYGON(((20 30, 40 45, 40 10, 20 30)), ((5 15, 10 40, 20 10, 10 5, 5 15)))');
    assert.equal(resultWithAlt, 'SRID=4326;MULTIPOLYGON(((20 30 20, 40 45 21, 40 10 22, 20 30 20)), ((5 15 23, 10 40 24, 20 10 25, 10 5 26, 5 15 23)))');
  });

  (0, _qunit.test)('test method latlngToPolygonEWKT for MultiPolygon with hole', function (assert) {
    //Arrange
    var latlng = [[[L.latLng(40, 40), L.latLng(20, 45), L.latLng(45, 30)]], [[L.latLng(20, 35), L.latLng(10, 30), L.latLng(10, 10), L.latLng(30, 5), L.latLng(45, 20)], [L.latLng(30, 20), L.latLng(20, 15), L.latLng(20, 25)]]];
    var latlngsWithAlt = [[[L.latLng(40, 40, 20), L.latLng(20, 45, 21), L.latLng(45, 30, 22)]], [[L.latLng(20, 35, 24), L.latLng(10, 30, 25), L.latLng(10, 10, 26), L.latLng(30, 5, 27), L.latLng(45, 20, 28)], [L.latLng(30, 20, 29), L.latLng(20, 15, 30), L.latLng(20, 25, 31)]]];

    //Act
    var result = (0, _emberFlexberryGisUtilsLayerToEwkt.latlngToPolygonEWKT)(latlng, crs);
    var resultWithAlt = (0, _emberFlexberryGisUtilsLayerToEwkt.latlngToPolygonEWKT)(latlngsWithAlt, crs);

    //Assert
    assert.equal(result, 'SRID=4326;MULTIPOLYGON(((40 40, 45 20, 30 45, 40 40)), ((35 20, 30 10, 10 10, 5 30, 20 45, 35 20), (20 30, 15 20, 25 20, 20 30)))');
    assert.equal(resultWithAlt, 'SRID=4326;MULTIPOLYGON(((40 40 20, 45 20 21, 30 45 22, 40 40 20)), ' + '((35 20 24, 30 10 25, 10 10 26, 5 30 27, 20 45 28, 35 20 24), (20 30 29, 15 20 30, 25 20 31, 20 30 29)))');
  });
});
define('dummy/tests/unit/utils/layer-to-ewkt-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/utils');
  test('unit/utils/layer-to-ewkt-test.js should pass jscs', function () {
    ok(true, 'unit/utils/layer-to-ewkt-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/utils/layer-to-ewkt-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/utils/layer-to-ewkt-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/utils/layer-to-ewkt-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/utils/layer-to-jsts-test', ['exports', 'ember-flexberry-gis/utils/layer-to-jsts', 'ember-flexberry-gis/coordinate-reference-systems/epsg-4326', 'qunit'], function (exports, _emberFlexberryGisUtilsLayerToJsts, _emberFlexberryGisCoordinateReferenceSystemsEpsg4326, _qunit) {

  (0, _qunit.module)('Unit | Utility | layer to jsts');

  var crs = _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default'].create();

  (0, _qunit.test)('test method latlngToPointJsts and geometryToJsts for Point', function (assert) {
    //Arrange
    var latlng = L.latLng(30, 10);
    var feature = {
      type: 'Point',
      coordinates: [10, 30]
    };

    //Act
    var resultToJsts = (0, _emberFlexberryGisUtilsLayerToJsts.latlngToPointJsts)(latlng, crs);
    var resultFromGeoJSON = (0, _emberFlexberryGisUtilsLayerToJsts.geometryToJsts)(feature);

    //Assert
    assert.equal(resultToJsts.getNumGeometries(), 1);
    assert.equal(resultToJsts.getCoordinate().toString(), '(10, 30, undefined)');
    assert.equal(resultToJsts.getGeometryType(), 'Point');
    assert.equal(resultFromGeoJSON.getNumGeometries(), 1);
    assert.equal(resultFromGeoJSON.getCoordinate().toString(), '(10, 30, undefined)');
    assert.equal(resultFromGeoJSON.getGeometryType(), 'Point');
  });

  (0, _qunit.test)('test method latlngToPointJsts and geometryToJsts for Point with altitude', function (assert) {
    //Arrange
    var latlng = L.latLng(30, 10, 20);
    var feature = {
      type: 'Point',
      coordinates: [10, 30, 20]
    };

    //Act
    var resultToJsts = (0, _emberFlexberryGisUtilsLayerToJsts.latlngToPointJsts)(latlng, crs);
    var resultFromGeoJSON = (0, _emberFlexberryGisUtilsLayerToJsts.geometryToJsts)(feature);

    //Assert
    assert.equal(resultToJsts.getNumGeometries(), 1);
    assert.equal(resultToJsts.getCoordinate().toString(), '(10, 30, 20)');
    assert.equal(resultToJsts.getGeometryType(), 'Point');
    assert.equal(resultFromGeoJSON.getNumGeometries(), 1);
    assert.equal(resultFromGeoJSON.getCoordinate().toString(), '(10, 30, 20)');
    assert.equal(resultFromGeoJSON.getGeometryType(), 'Point');
  });

  (0, _qunit.test)('test method latlngToPolylineJsts and geometryToJsts for LineString', function (assert) {
    //Arrange
    var latlngs = [L.latLng(30, 10), L.latLng(10, 30), L.latLng(40, 40)];
    var feature = {
      type: 'LineString',
      coordinates: [[10, 30], [30, 10], [40, 40]]
    };

    //Act
    var resultToJsts = (0, _emberFlexberryGisUtilsLayerToJsts.latlngToPolylineJsts)(latlngs, crs);
    var resultFromGeoJSON = (0, _emberFlexberryGisUtilsLayerToJsts.geometryToJsts)(feature);

    //Assert
    assert.equal(resultToJsts.getNumGeometries(), 1);
    assert.equal(resultToJsts.getCoordinates().toString(), '(10, 30, undefined),(30, 10, undefined),(40, 40, undefined)');
    assert.equal(resultToJsts.getGeometryType(), 'LineString');
    assert.equal(resultFromGeoJSON.getNumGeometries(), 1);
    assert.equal(resultFromGeoJSON.getCoordinates().toString(), '(10, 30, undefined),(30, 10, undefined),(40, 40, undefined)');
    assert.equal(resultFromGeoJSON.getGeometryType(), 'LineString');
  });

  (0, _qunit.test)('test method latlngToPolylineJsts and geometryToJsts for MultiLineString', function (assert) {
    //Arrange
    var latlngs = [[L.latLng(10, 10), L.latLng(20, 20), L.latLng(10, 40)], [L.latLng(40, 40), L.latLng(30, 30), L.latLng(40, 20)]];
    var feature = {
      type: 'MultiLineString',
      coordinates: [[[10, 10], [20, 20], [40, 10]], [[40, 40], [30, 30], [20, 40]]]
    };

    //Act
    var resultToJsts = (0, _emberFlexberryGisUtilsLayerToJsts.latlngToPolylineJsts)(latlngs, crs);
    var resultFromGeoJSON = (0, _emberFlexberryGisUtilsLayerToJsts.geometryToJsts)(feature);

    //Assert
    assert.equal(resultToJsts.getNumGeometries(), 2);
    assert.equal(resultToJsts.getGeometryN(0).getCoordinates().toString(), '(10, 10, undefined),(20, 20, undefined),(40, 10, undefined)');
    assert.equal(resultToJsts.getGeometryN(1).getCoordinates().toString(), '(40, 40, undefined),(30, 30, undefined),(20, 40, undefined)');
    assert.equal(resultToJsts.getGeometryType(), 'MultiLineString');
    assert.equal(resultFromGeoJSON.getNumGeometries(), 2);
    assert.equal(resultFromGeoJSON.getGeometryN(0).getCoordinates().toString(), '(10, 10, undefined),(20, 20, undefined),(40, 10, undefined)');
    assert.equal(resultFromGeoJSON.getGeometryN(1).getCoordinates().toString(), '(40, 40, undefined),(30, 30, undefined),(20, 40, undefined)');
    assert.equal(resultFromGeoJSON.getGeometryType(), 'MultiLineString');
  });

  (0, _qunit.test)('test method latlngToPolygonJsts and geometryToJsts for Polygon without hole', function (assert) {
    //Arrange
    var latlngs = [[L.latLng(30, 10), L.latLng(40, 40), L.latLng(20, 40), L.latLng(10, 20)]];
    var feature = {
      type: 'Polygon',
      coordinates: [[[10, 30], [40, 40], [40, 20], [20, 10], [10, 30]]]
    };

    //Act
    var resultToJsts = (0, _emberFlexberryGisUtilsLayerToJsts.latlngToPolygonJsts)(latlngs, crs);
    var resultFromGeoJSON = (0, _emberFlexberryGisUtilsLayerToJsts.geometryToJsts)(feature);

    //Assert
    assert.equal(resultToJsts.getNumGeometries(), 1);
    assert.equal(resultToJsts.getGeometryN(0).getCoordinates().toString(), '(10, 30, undefined),(40, 40, undefined),(40, 20, undefined)' + ',(20, 10, undefined),(10, 30, undefined)');
    assert.equal(resultToJsts.getGeometryType(), 'Polygon');
    assert.equal(resultFromGeoJSON.getNumGeometries(), 1);
    assert.equal(resultFromGeoJSON.getGeometryN(0).getCoordinates().toString(), '(10, 30, undefined),(40, 40, undefined),(40, 20, undefined)' + ',(20, 10, undefined),(10, 30, undefined)');
    assert.equal(resultFromGeoJSON.getGeometryType(), 'Polygon');
  });

  (0, _qunit.test)('test method latlngToPolygonJsts and geometryToJsts for Polygon with hole', function (assert) {
    //Arrange
    var latlngs = [[L.latLng(35, 10), L.latLng(45, 45), L.latLng(15, 40), L.latLng(10, 20)], [L.latLng(20, 30), L.latLng(35, 35), L.latLng(30, 20)]];
    var feature = {
      type: 'Polygon',
      coordinates: [[[10, 35], [45, 45], [40, 15], [20, 10], [10, 35]], [[30, 20], [35, 35], [20, 30], [30, 20]]]
    };

    //Act
    var resultToJsts = (0, _emberFlexberryGisUtilsLayerToJsts.latlngToPolygonJsts)(latlngs, crs);
    var resultFromGeoJSON = (0, _emberFlexberryGisUtilsLayerToJsts.geometryToJsts)(feature);

    //Assert
    assert.equal(resultToJsts.getNumGeometries(), 1);
    assert.equal(resultToJsts.getExteriorRing().getCoordinates().toString(), '(10, 35, undefined),(45, 45, undefined),(40, 15, undefined)' + ',(20, 10, undefined),(10, 35, undefined)');
    assert.equal(resultToJsts.getInteriorRingN(0).getCoordinates().toString(), '(30, 20, undefined),(35, 35, undefined),(20, 30, undefined),' + '(30, 20, undefined)');
    assert.equal(resultToJsts.getGeometryType(), 'Polygon');
    assert.equal(resultFromGeoJSON.getNumGeometries(), 1);
    assert.equal(resultFromGeoJSON.getExteriorRing().getCoordinates().toString(), '(10, 35, undefined),(45, 45, undefined),(40, 15, undefined)' + ',(20, 10, undefined),(10, 35, undefined)');
    assert.equal(resultFromGeoJSON.getInteriorRingN(0).getCoordinates().toString(), '(30, 20, undefined),(35, 35, undefined),(20, 30, undefined),' + '(30, 20, undefined)');
    assert.equal(resultFromGeoJSON.getGeometryType(), 'Polygon');
  });

  (0, _qunit.test)('test method latlngToPolygonJsts and geometryToJsts for MultiPolygon without hole', function (assert) {
    //Arrange
    var latlngs = [[[L.latLng(30, 20), L.latLng(45, 40), L.latLng(10, 40)]], [[L.latLng(15, 5), L.latLng(40, 10), L.latLng(10, 20), L.latLng(5, 10)]]];
    var feature = {
      type: 'MultiPolygon',
      coordinates: [[[[20, 30], [40, 45], [40, 10], [20, 30]]], [[[5, 15], [10, 40], [20, 10], [10, 5], [5, 15]]]]
    };

    //Act
    var resultToJsts = (0, _emberFlexberryGisUtilsLayerToJsts.latlngToPolygonJsts)(latlngs, crs);
    var resultFromGeoJSON = (0, _emberFlexberryGisUtilsLayerToJsts.geometryToJsts)(feature);

    //Assert
    assert.equal(resultToJsts.getNumGeometries(), 2);
    assert.equal(resultToJsts.getGeometryN(0).getCoordinates().toString(), '(20, 30, undefined),(40, 45, undefined),(40, 10, undefined),(20, 30, undefined)');
    assert.equal(resultToJsts.getGeometryN(1).getCoordinates().toString(), '(5, 15, undefined),(10, 40, undefined),(20, 10, undefined),(10, 5, undefined)' + ',(5, 15, undefined)');
    assert.equal(resultToJsts.getGeometryType(), 'MultiPolygon');
    assert.equal(resultFromGeoJSON.getNumGeometries(), 2);
    assert.equal(resultFromGeoJSON.getGeometryN(0).getCoordinates().toString(), '(20, 30, undefined),(40, 45, undefined),(40, 10, undefined),' + '(20, 30, undefined)');
    assert.equal(resultFromGeoJSON.getGeometryN(1).getCoordinates().toString(), '(5, 15, undefined),(10, 40, undefined),(20, 10, undefined),(10, 5, undefined)' + ',(5, 15, undefined)');
    assert.equal(resultFromGeoJSON.getGeometryType(), 'MultiPolygon');
  });

  (0, _qunit.test)('test method latlngToPolygonJsts and geometryToJsts for MultiPolygon with hole', function (assert) {
    //Arrange
    var latlngs = [[[L.latLng(40, 40), L.latLng(20, 45), L.latLng(45, 30)]], [[L.latLng(20, 35), L.latLng(10, 30), L.latLng(10, 10), L.latLng(30, 5), L.latLng(45, 20)], [L.latLng(30, 20), L.latLng(20, 15), L.latLng(20, 25)]]];
    var feature = {
      type: 'MultiPolygon',
      coordinates: [[[[40, 40], [45, 20], [30, 45], [40, 40]]], [[[35, 20], [30, 10], [10, 10], [5, 30], [20, 45], [35, 20]], [[20, 30], [15, 20], [25, 20], [20, 30]]]]
    };

    //Act
    var resultToJsts = (0, _emberFlexberryGisUtilsLayerToJsts.latlngToPolygonJsts)(latlngs, crs);
    var resultFromGeoJSON = (0, _emberFlexberryGisUtilsLayerToJsts.geometryToJsts)(feature);

    //Assert
    assert.equal(resultToJsts.getNumGeometries(), 2);
    assert.equal(resultToJsts.getGeometryN(0).getCoordinates().toString(), '(40, 40, undefined),(45, 20, undefined),(30, 45, undefined),(40, 40, undefined)');
    assert.equal(resultToJsts.getGeometryN(1).getExteriorRing().getCoordinates().toString(), '(35, 20, undefined),(30, 10, undefined),(10, 10, undefined)' + ',(5, 30, undefined),(20, 45, undefined),(35, 20, undefined)');
    assert.equal(resultToJsts.getGeometryN(1).getInteriorRingN(0).getCoordinates().toString(), '(20, 30, undefined),(15, 20, undefined),(25, 20, undefined),' + '(20, 30, undefined)');
    assert.equal(resultToJsts.getGeometryType(), 'MultiPolygon');
    assert.equal(resultFromGeoJSON.getNumGeometries(), 2);
    assert.equal(resultFromGeoJSON.getGeometryN(0).getCoordinates().toString(), '(40, 40, undefined),(45, 20, undefined),(30, 45, undefined),' + '(40, 40, undefined)');
    assert.equal(resultFromGeoJSON.getGeometryN(1).getExteriorRing().getCoordinates().toString(), '(35, 20, undefined),(30, 10, undefined),(10, 10, undefined)' + ',(5, 30, undefined),(20, 45, undefined),(35, 20, undefined)');
    assert.equal(resultFromGeoJSON.getGeometryN(1).getInteriorRingN(0).getCoordinates().toString(), '(20, 30, undefined),(15, 20, undefined),' + '(25, 20, undefined),(20, 30, undefined)');
    assert.equal(resultFromGeoJSON.getGeometryType(), 'MultiPolygon');
  });
});
define('dummy/tests/unit/utils/layer-to-jsts-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/utils');
  test('unit/utils/layer-to-jsts-test.js should pass jscs', function () {
    ok(true, 'unit/utils/layer-to-jsts-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/utils/layer-to-jsts-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/utils/layer-to-jsts-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/utils/layer-to-jsts-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/utils/leaflet-opacity-test', ['exports', 'dummy/utils/leaflet-opacity', 'qunit'], function (exports, _dummyUtilsLeafletOpacity, _qunit) {

  (0, _qunit.module)('Unit | Util | Leaflet-opacity');

  (0, _qunit.test)('it works', function (assert) {

    assert.expect(6);

    var color = '#abcdef';
    var opacity = 0.42;

    var tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', { foo: 'bar' });
    tileLayer.options.color = color;
    (0, _dummyUtilsLeafletOpacity.setLeafletLayerOpacity)({ leafletLayer: tileLayer, opacity: opacity });
    assert.deepEqual([tileLayer.options.color, tileLayer.options.opacity], [color, opacity], 'Tile layer style kept and set');

    var featureGroup = L.featureGroup([L.marker([50, 30]), L.polygon([[3, -10], [4, -10], [4, -11], [3, -11]])]);
    featureGroup.eachLayer(function (l) {
      l.options.color = color;
    });
    (0, _dummyUtilsLeafletOpacity.setLeafletLayerOpacity)({ leafletLayer: featureGroup, opacity: opacity });
    var fgGeometries = featureGroup.getLayers();
    assert.deepEqual([fgGeometries[0].options.color, fgGeometries[0].options.opacity], [color, opacity], 'Marker style in featureGroup kept and set');
    assert.deepEqual([fgGeometries[1].options.color, fgGeometries[1].options.opacity], [color, opacity], 'Polygon style in featureGroup kept and set');

    var markerGroup = L.markerClusterGroup();
    markerGroup.addLayers([L.marker([0, 1]), L.marker([2, 3])]);
    markerGroup.eachLayer(function (l) {
      l.options.color = color;
    });
    (0, _dummyUtilsLeafletOpacity.setLeafletLayerOpacity)({ leafletLayer: markerGroup, opacity: opacity });
    var markers = markerGroup.getLayers();
    assert.deepEqual([markers[1].options.color, markers[1].options.opacity], [color, opacity], 'Marker style in markerCluster kept and set');

    var data = { 'type': 'FeatureCollection',
      'features': [{ 'type': 'Feature',
        'geometry': {
          'type': 'Point', 'coordinates': [2, 3] }
      }, { 'type': 'Feature',
        'geometry': {
          'type': 'Polygon',
          'coordinates': [[[10, 0], [11, 0], [11, 1], [10, 1], [10, 0]]]
        } }]
    };

    var geojson = L.geoJSON(data, {
      style: function style(feature) {
        return { color: color };
      } });

    geojson.eachLayer(function (l) {
      l.options.color = color;
    });
    (0, _dummyUtilsLeafletOpacity.setLeafletLayerOpacity)({ leafletLayer: geojson, opacity: opacity });
    var geometries = geojson.getLayers();
    assert.deepEqual([geometries[0].options.color, geometries[0].options.opacity], [color, opacity], 'feature Point style in geoJOSN kept and set');
    assert.deepEqual([geometries[1].options.color, geometries[1].options.opacity], [color, opacity * _dummyUtilsLeafletOpacity.maxGeometryOpacity], 'feature Polygon style in geoJOSN kept and set');
  });
});
define('dummy/tests/unit/utils/leaflet-opacity-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/utils');
  test('unit/utils/leaflet-opacity-test.js should pass jscs', function () {
    ok(true, 'unit/utils/leaflet-opacity-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/utils/leaflet-opacity-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/utils/leaflet-opacity-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/utils/leaflet-opacity-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/utils/polygon-intersect-check-test', ['exports', 'ember-flexberry-gis/utils/polygon-intersect-check', 'qunit'], function (exports, _emberFlexberryGisUtilsPolygonIntersectCheck, _qunit) {

  (0, _qunit.module)('Unit | Utility | polygon intersect check');

  //Test intersecting polygon, type - L.Polygon
  var intersectPolygonLeaflet = L.polygon([[56.09, 58.03], [56.02, 58.007], [56.07, 58.07], [56.08, 58.02]], { color: 'red' });

  //Test intersecting polygon, type - array of latLngs
  var intersectPolygonArray = [[[56.09, 58.03], [56.02, 58.007], [56.07, 58.07], [56.08, 58.02]]];

  //Test intersecting polygon, type - GeoJson
  var intersectPolygonGeoJson = {
    type: 'Polygon',
    coordinates: [[[56.09, 58.03], [56.02, 58.007], [56.07, 58.07], [56.08, 58.02]]]
  };

  //Test nonintersecting polygon, type - L.Polygon
  var nonIntersectPolygonLeaflet = L.polygon([[56.09, 58.03], [56.02, 58.007], [56.07, 58.07], [56.1, 58.02]], { color: 'red' });

  //Test nonintersecting polygon, type - array of latLngs
  var nonIntersectPolygonArray = [[[56.09, 58.03], [56.02, 58.007], [56.07, 58.07], [56.1, 58.02]]];

  //Test nonintersecting polygon, type - GeoJson
  var nonIntersectPolygonGeoJson = {
    type: 'Polygon',
    coordinates: [[[56.09, 58.03], [56.02, 58.007], [56.07, 58.07], [56.1, 58.02]]]
  };

  //Test intersecting multi polygon, type - L.Polygon
  var intersectMPolygonLeaflet = L.polygon([[[45.51, -122.68], [37.77, -122.43], [34.04, -118.2]], [[56.09, 58.03], [56.02, 58.007], [56.07, 58.07], [56.08, 58.02]]], { color: 'red' });

  //Test intersecting multi polygon, type - array of latLngs
  var intersectMPolygonArray = [[[45.51, -122.68], [37.77, -122.43], [34.04, -118.2]], [[56.09, 58.03], [56.02, 58.007], [56.07, 58.07], [56.08, 58.02]]];

  //Test intersecting multi polygon, type - GeoJson
  var intersectMPolygonGeoJson = {
    type: 'MultiPolygon',
    coordinates: [[[[45.51, -122.68], [37.77, -122.43], [34.04, -118.2]]], [[[56.09, 58.03], [56.02, 58.007], [56.07, 58.07], [56.08, 58.02]]]]
  };

  //Test nonintersecting multi polygon, type - L.Polygon
  var nonIntersectMPolygonLeaflet = L.polygon([[[45.51, -122.68], [37.77, -122.43], [34.04, -118.2]], [[56.09, 58.03], [56.02, 58.007], [56.07, 58.07], [56.1, 58.02]]], { color: 'red' });

  //Test nonintersecting multi polygon, type - array of latLngs
  var nonIntersectMPolygonArray = [[[45.51, -122.68], [37.77, -122.43], [34.04, -118.2]], [[56.09, 58.03], [56.02, 58.007], [56.07, 58.07], [56.1, 58.02]]];

  //Test nonintersecting multi polygon, type - GeoJson
  var nonIntersectMPolygonGeoJson = {
    type: 'MultiPolygon',
    coordinates: [[[[45.51, -122.68], [37.77, -122.43], [34.04, -118.2]]], [[[56.09, 58.03], [56.02, 58.007], [56.07, 58.07], [56.1, 58.02]]]]
  };

  (0, _qunit.test)('should define is testing polygon intersecting or not', function (assert) {

    assert.equal((0, _emberFlexberryGisUtilsPolygonIntersectCheck['default'])(intersectPolygonLeaflet), true);
    assert.equal((0, _emberFlexberryGisUtilsPolygonIntersectCheck['default'])(nonIntersectPolygonLeaflet), false);

    assert.equal((0, _emberFlexberryGisUtilsPolygonIntersectCheck['default'])(intersectPolygonArray), true);
    assert.equal((0, _emberFlexberryGisUtilsPolygonIntersectCheck['default'])(nonIntersectPolygonArray), false);

    assert.equal((0, _emberFlexberryGisUtilsPolygonIntersectCheck['default'])(intersectPolygonGeoJson), true);
    assert.equal((0, _emberFlexberryGisUtilsPolygonIntersectCheck['default'])(nonIntersectPolygonGeoJson), false);

    assert.equal((0, _emberFlexberryGisUtilsPolygonIntersectCheck['default'])(intersectMPolygonLeaflet), true);
    assert.equal((0, _emberFlexberryGisUtilsPolygonIntersectCheck['default'])(nonIntersectMPolygonLeaflet), false);

    assert.equal((0, _emberFlexberryGisUtilsPolygonIntersectCheck['default'])(intersectMPolygonArray), true);
    assert.equal((0, _emberFlexberryGisUtilsPolygonIntersectCheck['default'])(nonIntersectMPolygonArray), false);

    assert.equal((0, _emberFlexberryGisUtilsPolygonIntersectCheck['default'])(intersectMPolygonGeoJson), true);
    assert.equal((0, _emberFlexberryGisUtilsPolygonIntersectCheck['default'])(nonIntersectMPolygonGeoJson), false);
  });
});
define('dummy/tests/unit/utils/polygon-intersect-check-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/utils');
  test('unit/utils/polygon-intersect-check-test.js should pass jscs', function () {
    ok(true, 'unit/utils/polygon-intersect-check-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/utils/polygon-intersect-check-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/utils/polygon-intersect-check-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/utils/polygon-intersect-check-test.js should pass jshint.');
  });
});
define('dummy/tests/unit/utils/rhumb-operations-test', ['exports', 'ember-flexberry-gis/utils/rhumb-operations', 'ember-flexberry-gis/coordinate-reference-systems/epsg-4326', 'qunit', 'sinon', 'ember'], function (exports, _emberFlexberryGisUtilsRhumbOperations, _emberFlexberryGisCoordinateReferenceSystemsEpsg4326, _qunit, _sinon, _ember) {

  (0, _qunit.module)('Unit | Utility | rhumb operations');

  var crsFactory32640 = {
    code: 'EPSG:32640',
    definition: '+proj=utm +zone=40 +datum=WGS84 +units=m +no_defs',
    create: function create() {
      var crs = L.extend({}, new L.Proj.CRS(this.code, this.definition), {
        scale: function scale(zoom) {
          return 256 * Math.pow(2, zoom);
        },
        zoom: function zoom(scale) {
          return Math.log(scale / 256) / Math.LN2;
        }
      });
      return crs;
    }
  };

  var crs32640 = crsFactory32640.create();

  (0, _qunit.test)('test method createObjectRhumb for Polygon with startPoint in EPSG:32640', function (assert) {
    //Arrange
    var testObj = {
      type: 'Polygon',
      startPoint: [20, 20],
      crs: 'EPSG:32640',
      skip: 0,
      points: [{ rhumb: 'SE', angle: 0, distance: 10 }, { rhumb: 'NE', angle: 90, distance: 10 }, { rhumb: 'NW', angle: 0, distance: 10 }, { rhumb: 'NW', angle: 90, distance: 10 }]
    };

    var resObj = {
      type: 'Feature',
      geometry: {
        type: 'Polygon',
        coordinates: [[[20, 20], [20, 10], [30, 10], [30, 20], [20, 20]]]
      },
      properties: undefined,
      crs: {
        type: 'name',
        properties: {
          name: 'EPSG:32640'
        }
      }
    };

    var ownerStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    ownerStub.returns({
      knownForType: function knownForType() {
        return {
          'epsg4326': crsFactory32640,
          'epsg32640': _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default']
        };
      }
    });

    //Act
    var result = (0, _emberFlexberryGisUtilsRhumbOperations.createObjectRhumb)(testObj, crs32640);

    //Assert
    assert.deepEqual(result, resObj);
    ownerStub.restore();
  });

  (0, _qunit.test)('test method createObjectRhumb for Polygon with startPoint in EPSG:4326', function (assert) {
    //Arrange
    var testObj = {
      type: 'Polygon',
      startPoint: [7, 3],
      crs: 'EPSG:4326',
      skip: 0,
      points: [{ rhumb: 'SE', angle: 0, distance: 1000 }, { rhumb: 'NE', angle: 90, distance: 1000 }, { rhumb: 'NW', angle: 0, distance: 1000 }, { rhumb: 'NW', angle: 90, distance: 1000 }]
    };

    var resObj = {
      type: 'Feature',
      properties: undefined,
      geometry: {
        type: 'Polygon',
        coordinates: [[[-5936517.120908923, 517670.4443068467], [-5936517.120908923, 516670.4443068467], [-5935517.120908923, 516670.4443068467], [-5935517.120908923, 517670.4443068467], [-5936517.120908923, 517670.4443068467]]]
      },
      crs: {
        type: 'name',
        properties: {
          name: 'EPSG:32640'
        }
      }
    };

    var ownerStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    ownerStub.returns({
      knownForType: function knownForType() {
        return {
          'epsg4326': crsFactory32640,
          'epsg32640': _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default']
        };
      }
    });

    //Act
    var result = (0, _emberFlexberryGisUtilsRhumbOperations.createObjectRhumb)(testObj, crs32640);

    //Assert
    assert.deepEqual(result, resObj);
    ownerStub.restore();
  });

  (0, _qunit.test)('test method createObjectRhumb for LineString with startPoint in EPSG:32640', function (assert) {
    //Arrange
    var testObj = {
      type: 'LineString',
      startPoint: [20, 20],
      crs: 'EPSG:32640',
      skip: 0,
      points: [{ rhumb: 'SE', angle: 0, distance: 10 }, { rhumb: 'NE', angle: 90, distance: 10 }, { rhumb: 'NW', angle: 0, distance: 10 }]
    };

    var resObj = {
      type: 'Feature',
      geometry: {
        type: 'LineString',
        coordinates: [[20, 20], [20, 10], [30, 10], [30, 20]]
      },
      properties: undefined,
      crs: {
        type: 'name',
        properties: {
          name: 'EPSG:32640'
        }
      }
    };

    var ownerStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    ownerStub.returns({
      knownForType: function knownForType() {
        return {
          'epsg4326': crsFactory32640,
          'epsg32640': _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default']
        };
      }
    });

    //Act
    var result = (0, _emberFlexberryGisUtilsRhumbOperations.createObjectRhumb)(testObj, crs32640);

    //Assert
    assert.deepEqual(result, resObj);
    ownerStub.restore();
  });

  (0, _qunit.test)('test method createObjectRhumb for LineString with startPoint in EPSG:4326', function (assert) {
    //Arrange
    var testObj = {
      type: 'LineString',
      startPoint: [7, 3],
      crs: 'EPSG:4326',
      skip: 0,
      points: [{ rhumb: 'SE', angle: 0, distance: 1000 }, { rhumb: 'NE', angle: 90, distance: 1000 }, { rhumb: 'NW', angle: 0, distance: 1000 }]
    };

    var resObj = {
      type: 'Feature',
      properties: undefined,
      geometry: {
        type: 'LineString',
        coordinates: [[-5936517.120908923, 517670.4443068467], [-5936517.120908923, 516670.4443068467], [-5935517.120908923, 516670.4443068467], [-5935517.120908923, 517670.4443068467]]
      },
      crs: {
        type: 'name',
        properties: {
          name: 'EPSG:32640'
        }
      }
    };

    var ownerStub = _sinon['default'].stub(_ember['default'], 'getOwner');
    ownerStub.returns({
      knownForType: function knownForType() {
        return {
          'epsg4326': crsFactory32640,
          'epsg32640': _emberFlexberryGisCoordinateReferenceSystemsEpsg4326['default']
        };
      }
    });

    //Act
    var result = (0, _emberFlexberryGisUtilsRhumbOperations.createObjectRhumb)(testObj, crs32640);

    //Assert
    assert.deepEqual(result, resObj);
    ownerStub.restore();
  });
});
define('dummy/tests/unit/utils/rhumb-operations-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - unit/utils');
  test('unit/utils/rhumb-operations-test.js should pass jscs', function () {
    ok(true, 'unit/utils/rhumb-operations-test.js should pass jscs.');
  });
});
define('dummy/tests/unit/utils/rhumb-operations-test.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - unit/utils/rhumb-operations-test.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/utils/rhumb-operations-test.js should pass jshint.');
  });
});
define('dummy/tests/views/components-examples/flexberry-maplayers/settings-example.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - views/components-examples/flexberry-maplayers');
  test('views/components-examples/flexberry-maplayers/settings-example.js should pass jscs', function () {
    ok(true, 'views/components-examples/flexberry-maplayers/settings-example.js should pass jscs.');
  });
});
define('dummy/tests/views/components-examples/flexberry-maplayers/settings-example.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - views/components-examples/flexberry-maplayers/settings-example.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'views/components-examples/flexberry-maplayers/settings-example.js should pass jshint.');
  });
});
define('dummy/tests/views/components-examples/flexberry-tree/settings-example.jscs-test', ['exports'], function (exports) {
  'use strict';

  module('JSCS - views/components-examples/flexberry-tree');
  test('views/components-examples/flexberry-tree/settings-example.js should pass jscs', function () {
    ok(true, 'views/components-examples/flexberry-tree/settings-example.js should pass jscs.');
  });
});
define('dummy/tests/views/components-examples/flexberry-tree/settings-example.jshint', ['exports'], function (exports) {
  'use strict';

  QUnit.module('JSHint - views/components-examples/flexberry-tree/settings-example.js');
  QUnit.test('should pass jshint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'views/components-examples/flexberry-tree/settings-example.js should pass jshint.');
  });
});
/* jshint ignore:start */

require('dummy/tests/test-helper');
EmberENV.TESTS_FILE_LOADED = true;

/* jshint ignore:end */
//# sourceMappingURL=tests.map
