<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>addon/mixins/flexberry-map-model-api.js - Flexberry Documentation</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
	    <img alt="Flexberry Documentation" src="../assets/css/logo.png" style="max-height: 65%;" title="Flexberry Documentation">
            Flexberry Documentation
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>develop</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/ApplicationInitializer", "classes/ApplicationInstance", "classes/ApplicationInstanceInitializer", "classes/ArrayContainsHelper", "classes/BaseChartTypeComponent", "classes/BaseControlComponent", "classes/BaseEditMode", "classes/BaseGeoProvider", "classes/BaseLayer", "classes/BaseLayerComponent", "classes/BaseLayerStyle", "classes/BaseLayerStyleLegendComponent", "classes/BaseLayerTreenodeContentComponent", "classes/BaseLegendComponent", "classes/BaseMapCommand", "classes/BaseMapCommandComponent", "classes/BaseMapTool", "classes/BaseMapToolComponent", "classes/BaseMarkerStyle", "classes/BaseModeComponent", "classes/BaseNonclickableMapTool", "classes/BaseVectorLayerComponent", "classes/CategorizedLayersStyleGradientToolsComponent", "classes/CategorizedLayersStyleLayerBaseCategorizedLayerStyleComponent", "classes/CategorizedLayersStyleLayerPropertyDropdownComponent", "classes/CategorizedLayerStyle", "classes/CategorizedLayerStyleLegendComponent", "classes/ChartsRendererService", "classes/ColumnComponent", "classes/DefaultMarkersStyleComponent", "classes/DefaultMarkerStyle", "classes/DivControlComponent", "classes/DragMapTool", "classes/DragMapToolComponent", "classes/DrawCircleMapTool", "classes/DrawClearMapTool", "classes/DrawMapTool", "classes/DrawMapToolComponent", "classes/DrawMarkerMapTool", "classes/DrawPolygonMapTool", "classes/DrawPolylineMapTool", "classes/DrawRectangleMapTool", "classes/DynamicPropertiesMixin", "classes/EarthCrs", "classes/EditMapCommand", "classes/EditMapCommandComponent", "classes/EditMapController", "classes/EditMapNewRoute", "classes/EmberGuidHelper", "classes/EmptyLayersStyleComponent", "classes/EmptyLayerStyle", "classes/EmptyLayerStyleLegendComponent", "classes/Epsg3395Crs", "classes/Epsg3857Crs", "classes/Epsg4326Crs", "classes/ExportDownloadMapCommand", "classes/ExportMapCommand", "classes/ExportMapCommandComponent", "classes/ExportPrintMapCommand", "classes/FeatureResultItemComponent", "classes/FlexberryAddLayerDialogComponent", "classes/FlexberryBoundingboxComponent", "classes/FlexberryBoundingboxMapLoaderMixin", "classes/FlexberryCopyLayerDialogComponent", "classes/FlexberryDisplaySettingsComponent", "classes/FlexberryEditLayerAttributesDialogComponent", "classes/FlexberryEditLayerDialogComponent", "classes/FlexberryEditMapDialogComponent", "classes/FlexberryExportMapCommandDialogComponent", "classes/FlexberryGeometryAddModeDrawComponent", "classes/FlexberryGeometryAddModeGeoProviderComponent", "classes/FlexberryGeometryAddModeManualComponent", "classes/FlexberryGeometryAddModeRhumbComponent", "classes/FlexberryGoToMapCommandDialogComponent", "classes/FlexberryIdentificationSettingsComponent", "classes/FlexberryIdentifyPanelComponent", "classes/FlexberryLayersAttributesPanelComponent", "classes/FlexberryLayersComponent", "classes/FlexberryLayersDropdownComponent", "classes/FlexberryLayerslegendsComponent", "classes/FlexberryLinksEditorActionsHandlerMixin", "classes/FlexberryLinksEditorComponent", "classes/FlexberryMapActionsHandlerMixin", "classes/FlexberryMapComponent", "classes/FlexberryMapinfoComponent", "classes/FlexberryMaplayerActionsHandlerMixin", "classes/FlexberryMaplayerComponent", "classes/FlexberryMaplayersComponent", "classes/FlexberryMaptoolbarComponent", "classes/FlexberryMaptoolbarComponet", "classes/FlexberryMultipleSelectComponent", "classes/FlexberryRemoveLayerDialogComponent", "classes/FlexberrySearchComponent", "classes/FlexberrySearchMapCommandDialogComponent", "classes/FlexberryTableComponent", "classes/FullExtentMapCommand", "classes/FullExtentMapCommandComponent", "classes/GeocoderBaseLayerComponent", "classes/GeocoderOsmOverpassLayerComponent", "classes/GeocoderOsmOverpassLayerSettingsComponent", "classes/GeocoderOsmRuLayer", "classes/GeocoderOsmRuLayerComponent", "classes/GeocoderOsmRuLayerSettingsComponent", "classes/GeocoderOsmRuSearchSettingsComponent", "classes/GeoJsonFilterParserMixin", "classes/GeoJSONLayer", "classes/GeoJSONLayerComponent", "classes/GeoJSONLayerSettingsComponent", "classes/GeojsonLegendComponent", "classes/GeoJSONSearchSettingsComponent", "classes/GisSearchFormController", "classes/GisSearchFormRoute", "classes/GoToMapCommand", "classes/GoToMapCommandComponent", "classes/GradientEditComponent", "classes/GradientStylesLoadRendererService", "classes/GraduatedLayersStyleComponent", "classes/GraduatedLayerStyleLegendComponent", "classes/GroupLayer", "classes/GroupLayerComponent", "classes/GroupLayerSettingsComponent", "classes/HeaderFromProjectionHelper", "classes/HistoryControlComponent", "classes/IdentifyAllMarkerMapTool", "classes/IdentifyAllMixin", "classes/IdentifyAllPolygonMapTool", "classes/IdentifyAllPolylineMapTool", "classes/IdentifyAllRectangleMapTool", "classes/IdentifyAllVisibleMarkerMapTool", "classes/IdentifyAllVisiblePolygonMapTool", "classes/IdentifyAllVisiblePolylineMapTool", "classes/IdentifyAllVisibleRectangleMapTool", "classes/IdentifyMapTool", "classes/IdentifyMapToolComponent", "classes/IdentifyTopMixin", "classes/IdentifyTopVisibleMarkerMapTool", "classes/IdentifyTopVisiblePolygonMapTool", "classes/IdentifyTopVisiblePolylineMapTool", "classes/IdentifyTopVisibleRectangleMapTool", "classes/IdentifyVisibleMixin", "classes/ImageMarkersStyleComponent", "classes/ImageMarkersStyleIconEditorComponent", "classes/ImageMarkerStyle", "classes/IndexChartComponent", "classes/IsNoneHelper", "classes/JsonTransform", "classes/KmlLayer", "classes/KmlLayerComponent", "classes/KmlLayerSettingsComponent", "classes/KmlLegendComponent", "classes/KMLSearchSettingsComponent", "classes/KnownForTypeHelper", "classes/LayerModelMixin", "classes/LayerResultListActionsHandlerMixin", "classes/LayerResultListComponent", "classes/LayersStylesEditorComponent", "classes/LayersStylesRendererService", "classes/LeafletCrsMixin", "classes/LeafletEventsMixin", "classes/LeafletMapCommandsMixin", "classes/LeafletMapInteractionMixin", "classes/LeafletMapLoaderMixin", "classes/LeafletMapToolsMixin", "classes/LeafletMapVisibilityMixin", "classes/LeafletOptionsMixin", "classes/LeafletPropertiesMixin", "classes/LeafletZoomToFeatureMixin", "classes/LegendControlComponent", "classes/LineComponent", "classes/ListMapController", "classes/ListMapRoute", "classes/LocalStorageBindingMixin", "classes/LocalStorageService", "classes/LocateMapCommand", "classes/LocateMapCommandComponent", "classes/MapApiService", "classes/MapInfoComponent", "classes/MapRoute", "classes/MapStoreService", "classes/MarkerIdentifyMapTool", "classes/MarkersStylesEditorComponent", "classes/MarkersStylesRendererService", "classes/MeasureAreaMapTool", "classes/MeasureClearMapTool", "classes/MeasureCoordinatesMapTool", "classes/MeasureDistanceMapTool", "classes/MeasureMapTool", "classes/MeasureMapToolComponent", "classes/MeasureRadiusMapTool", "classes/MetadataEditMode", "classes/MetadataModeComponent", "classes/MiniMapComponent", "classes/NewNewPlatformFlexberryGISLayerMetadataERoute", "classes/NewPlatformFlexberrtGISLayerMetadataEController", "classes/NewPlatformFlexberrtGISLayerMetadataLController", "classes/NewPlatformFlexberryGISLayerLayerMetadataOfflineSerializer", "classes/NewPlatformFlexberryGISLayerLinkModel", "classes/NewPlatformFlexberryGISLayerLinkOfflineSerializer", "classes/NewPlatformFlexberryGISLayerLinkSerializer", "classes/NewPlatformFlexberryGISLayerMetadataERoute", "classes/NewPlatformFlexberryGISLayerMetadataLRoute", "classes/NewPlatformFlexberryGISLayerMetadataModel", "classes/NewPlatformFlexberryGISLayerMetadataSerializer", "classes/NewPlatformFlexberryGISLinkMetadataModel", "classes/NewPlatformFlexberryGISLinkMetadataOfflineSerializer", "classes/NewPlatformFlexberryGISLinkMetadataSerializer", "classes/NewPlatformFlexberryGISLinkParameterModel", "classes/NewPlatformFlexberryGISLinkParameterOfflineSerializer", "classes/NewPlatformFlexberryGISLinkParameterSerializer", "classes/NewPlatformFlexberryGISMapLayerModel", "classes/NewPlatformFlexberryGISMapLayerOfflineSerializer", "classes/NewPlatformFlexberryGISMapLayerSerializer", "classes/NewPlatformFlexberryGISMapModel", "classes/NewPlatformFlexberryGISMapObjectSettingModel", "classes/NewPlatformFlexberryGISMapObjectSettingOfflineSerializer", "classes/NewPlatformFlexberryGISMapObjectSettingSerializer", "classes/NewPlatformFlexberryGISMapOfflineSerializer", "classes/NewPlatformFlexberryGISMapSerializer", "classes/NewPlatformFlexberryGISParameterMetadataOfflineSerializer", "classes/NewPlatformFlexberryGISParameterMetadataSerializer", "classes/NewPlatformFlexberyGISLayerLinkModelMixin", "classes/NewPlatformFlexberyGISLayerLinkOfflineSerializerMixin", "classes/NewPlatformFlexberyGISLayerLinkSerializerMixin", "classes/NewPlatformFlexberyGISLayerMetadataModelMixin", "classes/NewPlatformFlexberyGISLayerMetadataOfflineSerializerMixin", "classes/NewPlatformFlexberyGISLayerMetadataSerializerMixin", "classes/NewPlatformFlexberyGISLinkMetadataModelMixin", "classes/NewPlatformFlexberyGISLinkMetadataOfflineSerializerMixin", "classes/NewPlatformFlexberyGISLinkMetadataSerializerMixin", "classes/NewPlatformFlexberyGISLinkParameterModelMixin", "classes/NewPlatformFlexberyGISLinkParameterOfflineSerializerMixin", "classes/NewPlatformFlexberyGISLinkParameterSerializerMixin", "classes/NewPlatformFlexberyGISMapLayerModelMixin", "classes/NewPlatformFlexberyGISMapLayerOfflineSerializerMixin", "classes/NewPlatformFlexberyGISMapLayerSerializerMixin", "classes/NewPlatformFlexberyGISMapModelMixin", "classes/NewPlatformFlexberyGISMapObjectSettingModelMixin", "classes/NewPlatformFlexberyGISMapObjectSettingOfflineSerializerMixin", "classes/NewPlatformFlexberyGISMapObjectSettingSerializerMixin", "classes/NewPlatformFlexberyGISMapOfflineSerializerMixin", "classes/NewPlatformFlexberyGISMapSerializerMixin", "classes/NewPlatformFlexberyGISParameterMetadataModelMixin", "classes/NewPlatformFlexberyGISParameterMetadataOfflineSerializerMixin", "classes/NewPlatformFlexberyGISParameterMetadataSerializerMixin", "classes/ObjectContainsHelper", "classes/ODataSettingsComponent", "classes/ODataVectorlayer", "classes/ODataVectorLayerComponent", "classes/ODataVectorSearchSettingsComponent", "classes/OSMLayerComponent", "classes/PieComponent", "classes/PolygonIdentifyMapTool", "classes/PolylineIdentifyMapTool", "classes/Proj4Crs", "classes/RectangleIdentifyMapTool", "classes/RectangleMapTool", "classes/RegexTestHelper", "classes/ScaleControlComponent", "classes/SearchAttributesMapCommand", "classes/SearchClearMapCommand", "classes/SearchMapCommand", "classes/SearchMapCommandComponent", "classes/SearchShowMapCommand", "classes/SimpleCrs", "classes/SimpleLayersStyleComponent", "classes/SimpleLayersStyleFillEditorComponent", "classes/SimpleLayersStylePathEditorComponent", "classes/SimpleLayersStyleStrokeDashArrayDropdownComponent", "classes/SimpleLayersStyleStrokeEditorComponent", "classes/SimpleLayersStyleStrokeLineCapDropdownComponent", "classes/SimpleLayersStyleStrokeLineJoinDropdownComponent", "classes/SimpleLayerStyle", "classes/SimpleLayerStyleLegendComponent", "classes/SpatialBookmarkComponent", "classes/SwitchScaleControlComponent", "classes/TileLayer", "classes/TileLayerComponent", "classes/TileLayerSettingsComponent", "classes/UniqueLayersStyleComponent", "classes/UniqueLayerStyle", "classes/UniqueLayerStyleLegendComponent", "classes/Utils.CheckIntersect", "classes/Utils.Convertor", "classes/Utils.Interpolator", "classes/Utils.LayerCopy", "classes/Utils.LayerCreate", "classes/Utils.Layers", "classes/Utils.LeafletOpacity", "classes/VectorLayer", "classes/VectorLegendComponent", "classes/WfsFilterParserMixin", "classes/WfsLayer", "classes/WfsLayerComponent", "classes/WfsLayerSettingsComponent", "classes/WfsLegendComponent", "classes/WFSSearchSettingsComponent", "classes/WmsLayer", "classes/WMSLayerComponent", "classes/WmsLayerSettingsComponent", "classes/WmsLegendComponent", "classes/WmsSingleTileLayer", "classes/WMSSingleTileLayerComponent", "classes/WmsSingleTileLayerSettingsComponent", "classes/WmsSingleTileLegendComponent", "classes/WmsWfsLayer", "classes/WmsWfsLayerComponent", "classes/YandexMapsGeoCoder", "classes/ZoomInMapTool", "classes/ZoomInMapToolComponent", "classes/ZoomOutMaptool", "classes/ZoomOutMapToolComponent", "classes/ZoomsliderControlComponent", "modules/ember-flexberry", "modules/ember-flexberry-gis", "modules/ember-flexberry-gis-csw", "modules/ember-flexberry-gis-dummy"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
	    <div>
	        <h3>APIs</h3>
	        <div id="sidebar">
	            <ul id="main-nav" class="nav nav-tabs" style="margin-bottom:0;">
	                <li class="active"><a href="#classes" data-toggle="tab">Classes</a></li>
	                <li><a href="#modules" data-toggle="tab">Modules</a></li>
	            </ul>
	    
	            <div id="api-tabview-filter">
	                <input type="search" placeholder="Type to filter APIs">
	            </div>
	    
	            <div class="tab-content" style="border: 1px solid #DDD; border-top:0;">
	                <div class="tab-pane active" id="classes">
	                    <ul id="api-classes" class="nav nav-list">
	                            <li><a href="../classes/ApplicationInitializer.html">ApplicationInitializer</a></li>
	                            <li><a href="../classes/ApplicationInstance.html">ApplicationInstance</a></li>
	                            <li><a href="../classes/ApplicationInstanceInitializer.html">ApplicationInstanceInitializer</a></li>
	                            <li><a href="../classes/ArrayContainsHelper.html">ArrayContainsHelper</a></li>
	                            <li><a href="../classes/BaseChartTypeComponent.html">BaseChartTypeComponent</a></li>
	                            <li><a href="../classes/BaseControlComponent.html">BaseControlComponent</a></li>
	                            <li><a href="../classes/BaseEditMode.html">BaseEditMode</a></li>
	                            <li><a href="../classes/BaseGeoProvider.html">BaseGeoProvider</a></li>
	                            <li><a href="../classes/BaseLayer.html">BaseLayer</a></li>
	                            <li><a href="../classes/BaseLayerComponent.html">BaseLayerComponent</a></li>
	                            <li><a href="../classes/BaseLayerStyle.html">BaseLayerStyle</a></li>
	                            <li><a href="../classes/BaseLayerStyleLegendComponent.html">BaseLayerStyleLegendComponent</a></li>
	                            <li><a href="../classes/BaseLayerTreenodeContentComponent.html">BaseLayerTreenodeContentComponent</a></li>
	                            <li><a href="../classes/BaseLegendComponent.html">BaseLegendComponent</a></li>
	                            <li><a href="../classes/BaseMapCommand.html">BaseMapCommand</a></li>
	                            <li><a href="../classes/BaseMapCommandComponent.html">BaseMapCommandComponent</a></li>
	                            <li><a href="../classes/BaseMapTool.html">BaseMapTool</a></li>
	                            <li><a href="../classes/BaseMapToolComponent.html">BaseMapToolComponent</a></li>
	                            <li><a href="../classes/BaseMarkerStyle.html">BaseMarkerStyle</a></li>
	                            <li><a href="../classes/BaseModeComponent.html">BaseModeComponent</a></li>
	                            <li><a href="../classes/BaseNonclickableMapTool.html">BaseNonclickableMapTool</a></li>
	                            <li><a href="../classes/BaseVectorLayerComponent.html">BaseVectorLayerComponent</a></li>
	                            <li><a href="../classes/CategorizedLayersStyleGradientToolsComponent.html">CategorizedLayersStyleGradientToolsComponent</a></li>
	                            <li><a href="../classes/CategorizedLayersStyleLayerBaseCategorizedLayerStyleComponent.html">CategorizedLayersStyleLayerBaseCategorizedLayerStyleComponent</a></li>
	                            <li><a href="../classes/CategorizedLayersStyleLayerPropertyDropdownComponent.html">CategorizedLayersStyleLayerPropertyDropdownComponent</a></li>
	                            <li><a href="../classes/CategorizedLayerStyle.html">CategorizedLayerStyle</a></li>
	                            <li><a href="../classes/CategorizedLayerStyleLegendComponent.html">CategorizedLayerStyleLegendComponent</a></li>
	                            <li><a href="../classes/ChartsRendererService.html">ChartsRendererService</a></li>
	                            <li><a href="../classes/ColumnComponent.html">ColumnComponent</a></li>
	                            <li><a href="../classes/DefaultMarkersStyleComponent.html">DefaultMarkersStyleComponent</a></li>
	                            <li><a href="../classes/DefaultMarkerStyle.html">DefaultMarkerStyle</a></li>
	                            <li><a href="../classes/DivControlComponent.html">DivControlComponent</a></li>
	                            <li><a href="../classes/DragMapTool.html">DragMapTool</a></li>
	                            <li><a href="../classes/DragMapToolComponent.html">DragMapToolComponent</a></li>
	                            <li><a href="../classes/DrawCircleMapTool.html">DrawCircleMapTool</a></li>
	                            <li><a href="../classes/DrawClearMapTool.html">DrawClearMapTool</a></li>
	                            <li><a href="../classes/DrawMapTool.html">DrawMapTool</a></li>
	                            <li><a href="../classes/DrawMapToolComponent.html">DrawMapToolComponent</a></li>
	                            <li><a href="../classes/DrawMarkerMapTool.html">DrawMarkerMapTool</a></li>
	                            <li><a href="../classes/DrawPolygonMapTool.html">DrawPolygonMapTool</a></li>
	                            <li><a href="../classes/DrawPolylineMapTool.html">DrawPolylineMapTool</a></li>
	                            <li><a href="../classes/DrawRectangleMapTool.html">DrawRectangleMapTool</a></li>
	                            <li><a href="../classes/DynamicPropertiesMixin.html">DynamicPropertiesMixin</a></li>
	                            <li><a href="../classes/EarthCrs.html">EarthCrs</a></li>
	                            <li><a href="../classes/EditMapCommand.html">EditMapCommand</a></li>
	                            <li><a href="../classes/EditMapCommandComponent.html">EditMapCommandComponent</a></li>
	                            <li><a href="../classes/EditMapController.html">EditMapController</a></li>
	                            <li><a href="../classes/EditMapNewRoute.html">EditMapNewRoute</a></li>
	                            <li><a href="../classes/EmberGuidHelper.html">EmberGuidHelper</a></li>
	                            <li><a href="../classes/EmptyLayersStyleComponent.html">EmptyLayersStyleComponent</a></li>
	                            <li><a href="../classes/EmptyLayerStyle.html">EmptyLayerStyle</a></li>
	                            <li><a href="../classes/EmptyLayerStyleLegendComponent.html">EmptyLayerStyleLegendComponent</a></li>
	                            <li><a href="../classes/Epsg3395Crs.html">Epsg3395Crs</a></li>
	                            <li><a href="../classes/Epsg3857Crs.html">Epsg3857Crs</a></li>
	                            <li><a href="../classes/Epsg4326Crs.html">Epsg4326Crs</a></li>
	                            <li><a href="../classes/ExportDownloadMapCommand.html">ExportDownloadMapCommand</a></li>
	                            <li><a href="../classes/ExportMapCommand.html">ExportMapCommand</a></li>
	                            <li><a href="../classes/ExportMapCommandComponent.html">ExportMapCommandComponent</a></li>
	                            <li><a href="../classes/ExportPrintMapCommand.html">ExportPrintMapCommand</a></li>
	                            <li><a href="../classes/FeatureResultItemComponent.html">FeatureResultItemComponent</a></li>
	                            <li><a href="../classes/FlexberryAddLayerDialogComponent.html">FlexberryAddLayerDialogComponent</a></li>
	                            <li><a href="../classes/FlexberryBoundingboxComponent.html">FlexberryBoundingboxComponent</a></li>
	                            <li><a href="../classes/FlexberryBoundingboxMapLoaderMixin.html">FlexberryBoundingboxMapLoaderMixin</a></li>
	                            <li><a href="../classes/FlexberryCopyLayerDialogComponent.html">FlexberryCopyLayerDialogComponent</a></li>
	                            <li><a href="../classes/FlexberryDisplaySettingsComponent.html">FlexberryDisplaySettingsComponent</a></li>
	                            <li><a href="../classes/FlexberryEditLayerAttributesDialogComponent.html">FlexberryEditLayerAttributesDialogComponent</a></li>
	                            <li><a href="../classes/FlexberryEditLayerDialogComponent.html">FlexberryEditLayerDialogComponent</a></li>
	                            <li><a href="../classes/FlexberryEditMapDialogComponent.html">FlexberryEditMapDialogComponent</a></li>
	                            <li><a href="../classes/FlexberryExportMapCommandDialogComponent.html">FlexberryExportMapCommandDialogComponent</a></li>
	                            <li><a href="../classes/FlexberryGeometryAddModeDrawComponent.html">FlexberryGeometryAddModeDrawComponent</a></li>
	                            <li><a href="../classes/FlexberryGeometryAddModeGeoProviderComponent.html">FlexberryGeometryAddModeGeoProviderComponent</a></li>
	                            <li><a href="../classes/FlexberryGeometryAddModeManualComponent.html">FlexberryGeometryAddModeManualComponent</a></li>
	                            <li><a href="../classes/FlexberryGeometryAddModeRhumbComponent.html">FlexberryGeometryAddModeRhumbComponent</a></li>
	                            <li><a href="../classes/FlexberryGoToMapCommandDialogComponent.html">FlexberryGoToMapCommandDialogComponent</a></li>
	                            <li><a href="../classes/FlexberryIdentificationSettingsComponent.html">FlexberryIdentificationSettingsComponent</a></li>
	                            <li><a href="../classes/FlexberryIdentifyPanelComponent.html">FlexberryIdentifyPanelComponent</a></li>
	                            <li><a href="../classes/FlexberryLayersAttributesPanelComponent.html">FlexberryLayersAttributesPanelComponent</a></li>
	                            <li><a href="../classes/FlexberryLayersComponent.html">FlexberryLayersComponent</a></li>
	                            <li><a href="../classes/FlexberryLayersDropdownComponent.html">FlexberryLayersDropdownComponent</a></li>
	                            <li><a href="../classes/FlexberryLayerslegendsComponent.html">FlexberryLayerslegendsComponent</a></li>
	                            <li><a href="../classes/FlexberryLinksEditorActionsHandlerMixin.html">FlexberryLinksEditorActionsHandlerMixin</a></li>
	                            <li><a href="../classes/FlexberryLinksEditorComponent.html">FlexberryLinksEditorComponent</a></li>
	                            <li><a href="../classes/FlexberryMapActionsHandlerMixin.html">FlexberryMapActionsHandlerMixin</a></li>
	                            <li><a href="../classes/FlexberryMapComponent.html">FlexberryMapComponent</a></li>
	                            <li><a href="../classes/FlexberryMapinfoComponent.html">FlexberryMapinfoComponent</a></li>
	                            <li><a href="../classes/FlexberryMaplayerActionsHandlerMixin.html">FlexberryMaplayerActionsHandlerMixin</a></li>
	                            <li><a href="../classes/FlexberryMaplayerComponent.html">FlexberryMaplayerComponent</a></li>
	                            <li><a href="../classes/FlexberryMaplayersComponent.html">FlexberryMaplayersComponent</a></li>
	                            <li><a href="../classes/FlexberryMaptoolbarComponent.html">FlexberryMaptoolbarComponent</a></li>
	                            <li><a href="../classes/FlexberryMaptoolbarComponet.html">FlexberryMaptoolbarComponet</a></li>
	                            <li><a href="../classes/FlexberryMultipleSelectComponent.html">FlexberryMultipleSelectComponent</a></li>
	                            <li><a href="../classes/FlexberryRemoveLayerDialogComponent.html">FlexberryRemoveLayerDialogComponent</a></li>
	                            <li><a href="../classes/FlexberrySearchComponent.html">FlexberrySearchComponent</a></li>
	                            <li><a href="../classes/FlexberrySearchMapCommandDialogComponent.html">FlexberrySearchMapCommandDialogComponent</a></li>
	                            <li><a href="../classes/FlexberryTableComponent.html">FlexberryTableComponent</a></li>
	                            <li><a href="../classes/FullExtentMapCommand.html">FullExtentMapCommand</a></li>
	                            <li><a href="../classes/FullExtentMapCommandComponent.html">FullExtentMapCommandComponent</a></li>
	                            <li><a href="../classes/GeocoderBaseLayerComponent.html">GeocoderBaseLayerComponent</a></li>
	                            <li><a href="../classes/GeocoderOsmOverpassLayerComponent.html">GeocoderOsmOverpassLayerComponent</a></li>
	                            <li><a href="../classes/GeocoderOsmOverpassLayerSettingsComponent.html">GeocoderOsmOverpassLayerSettingsComponent</a></li>
	                            <li><a href="../classes/GeocoderOsmRuLayer.html">GeocoderOsmRuLayer</a></li>
	                            <li><a href="../classes/GeocoderOsmRuLayerComponent.html">GeocoderOsmRuLayerComponent</a></li>
	                            <li><a href="../classes/GeocoderOsmRuLayerSettingsComponent.html">GeocoderOsmRuLayerSettingsComponent</a></li>
	                            <li><a href="../classes/GeocoderOsmRuSearchSettingsComponent.html">GeocoderOsmRuSearchSettingsComponent</a></li>
	                            <li><a href="../classes/GeoJsonFilterParserMixin.html">GeoJsonFilterParserMixin</a></li>
	                            <li><a href="../classes/GeoJSONLayer.html">GeoJSONLayer</a></li>
	                            <li><a href="../classes/GeoJSONLayerComponent.html">GeoJSONLayerComponent</a></li>
	                            <li><a href="../classes/GeoJSONLayerSettingsComponent.html">GeoJSONLayerSettingsComponent</a></li>
	                            <li><a href="../classes/GeojsonLegendComponent.html">GeojsonLegendComponent</a></li>
	                            <li><a href="../classes/GeoJSONSearchSettingsComponent.html">GeoJSONSearchSettingsComponent</a></li>
	                            <li><a href="../classes/GisSearchFormController.html">GisSearchFormController</a></li>
	                            <li><a href="../classes/GisSearchFormRoute.html">GisSearchFormRoute</a></li>
	                            <li><a href="../classes/GoToMapCommand.html">GoToMapCommand</a></li>
	                            <li><a href="../classes/GoToMapCommandComponent.html">GoToMapCommandComponent</a></li>
	                            <li><a href="../classes/GradientEditComponent.html">GradientEditComponent</a></li>
	                            <li><a href="../classes/GradientStylesLoadRendererService.html">GradientStylesLoadRendererService</a></li>
	                            <li><a href="../classes/GraduatedLayersStyleComponent.html">GraduatedLayersStyleComponent</a></li>
	                            <li><a href="../classes/GraduatedLayerStyleLegendComponent.html">GraduatedLayerStyleLegendComponent</a></li>
	                            <li><a href="../classes/GroupLayer.html">GroupLayer</a></li>
	                            <li><a href="../classes/GroupLayerComponent.html">GroupLayerComponent</a></li>
	                            <li><a href="../classes/GroupLayerSettingsComponent.html">GroupLayerSettingsComponent</a></li>
	                            <li><a href="../classes/HeaderFromProjectionHelper.html">HeaderFromProjectionHelper</a></li>
	                            <li><a href="../classes/HistoryControlComponent.html">HistoryControlComponent</a></li>
	                            <li><a href="../classes/IdentifyAllMarkerMapTool.html">IdentifyAllMarkerMapTool</a></li>
	                            <li><a href="../classes/IdentifyAllMixin.html">IdentifyAllMixin</a></li>
	                            <li><a href="../classes/IdentifyAllPolygonMapTool.html">IdentifyAllPolygonMapTool</a></li>
	                            <li><a href="../classes/IdentifyAllPolylineMapTool.html">IdentifyAllPolylineMapTool</a></li>
	                            <li><a href="../classes/IdentifyAllRectangleMapTool.html">IdentifyAllRectangleMapTool</a></li>
	                            <li><a href="../classes/IdentifyAllVisibleMarkerMapTool.html">IdentifyAllVisibleMarkerMapTool</a></li>
	                            <li><a href="../classes/IdentifyAllVisiblePolygonMapTool.html">IdentifyAllVisiblePolygonMapTool</a></li>
	                            <li><a href="../classes/IdentifyAllVisiblePolylineMapTool.html">IdentifyAllVisiblePolylineMapTool</a></li>
	                            <li><a href="../classes/IdentifyAllVisibleRectangleMapTool.html">IdentifyAllVisibleRectangleMapTool</a></li>
	                            <li><a href="../classes/IdentifyMapTool.html">IdentifyMapTool</a></li>
	                            <li><a href="../classes/IdentifyMapToolComponent.html">IdentifyMapToolComponent</a></li>
	                            <li><a href="../classes/IdentifyTopMixin.html">IdentifyTopMixin</a></li>
	                            <li><a href="../classes/IdentifyTopVisibleMarkerMapTool.html">IdentifyTopVisibleMarkerMapTool</a></li>
	                            <li><a href="../classes/IdentifyTopVisiblePolygonMapTool.html">IdentifyTopVisiblePolygonMapTool</a></li>
	                            <li><a href="../classes/IdentifyTopVisiblePolylineMapTool.html">IdentifyTopVisiblePolylineMapTool</a></li>
	                            <li><a href="../classes/IdentifyTopVisibleRectangleMapTool.html">IdentifyTopVisibleRectangleMapTool</a></li>
	                            <li><a href="../classes/IdentifyVisibleMixin.html">IdentifyVisibleMixin</a></li>
	                            <li><a href="../classes/ImageMarkersStyleComponent.html">ImageMarkersStyleComponent</a></li>
	                            <li><a href="../classes/ImageMarkersStyleIconEditorComponent.html">ImageMarkersStyleIconEditorComponent</a></li>
	                            <li><a href="../classes/ImageMarkerStyle.html">ImageMarkerStyle</a></li>
	                            <li><a href="../classes/IndexChartComponent.html">IndexChartComponent</a></li>
	                            <li><a href="../classes/IsNoneHelper.html">IsNoneHelper</a></li>
	                            <li><a href="../classes/JsonTransform.html">JsonTransform</a></li>
	                            <li><a href="../classes/KmlLayer.html">KmlLayer</a></li>
	                            <li><a href="../classes/KmlLayerComponent.html">KmlLayerComponent</a></li>
	                            <li><a href="../classes/KmlLayerSettingsComponent.html">KmlLayerSettingsComponent</a></li>
	                            <li><a href="../classes/KmlLegendComponent.html">KmlLegendComponent</a></li>
	                            <li><a href="../classes/KMLSearchSettingsComponent.html">KMLSearchSettingsComponent</a></li>
	                            <li><a href="../classes/KnownForTypeHelper.html">KnownForTypeHelper</a></li>
	                            <li><a href="../classes/LayerModelMixin.html">LayerModelMixin</a></li>
	                            <li><a href="../classes/LayerResultListActionsHandlerMixin.html">LayerResultListActionsHandlerMixin</a></li>
	                            <li><a href="../classes/LayerResultListComponent.html">LayerResultListComponent</a></li>
	                            <li><a href="../classes/LayersStylesEditorComponent.html">LayersStylesEditorComponent</a></li>
	                            <li><a href="../classes/LayersStylesRendererService.html">LayersStylesRendererService</a></li>
	                            <li><a href="../classes/LeafletCrsMixin.html">LeafletCrsMixin</a></li>
	                            <li><a href="../classes/LeafletEventsMixin.html">LeafletEventsMixin</a></li>
	                            <li><a href="../classes/LeafletMapCommandsMixin.html">LeafletMapCommandsMixin</a></li>
	                            <li><a href="../classes/LeafletMapInteractionMixin.html">LeafletMapInteractionMixin</a></li>
	                            <li><a href="../classes/LeafletMapLoaderMixin.html">LeafletMapLoaderMixin</a></li>
	                            <li><a href="../classes/LeafletMapToolsMixin.html">LeafletMapToolsMixin</a></li>
	                            <li><a href="../classes/LeafletMapVisibilityMixin.html">LeafletMapVisibilityMixin</a></li>
	                            <li><a href="../classes/LeafletOptionsMixin.html">LeafletOptionsMixin</a></li>
	                            <li><a href="../classes/LeafletPropertiesMixin.html">LeafletPropertiesMixin</a></li>
	                            <li><a href="../classes/LeafletZoomToFeatureMixin.html">LeafletZoomToFeatureMixin</a></li>
	                            <li><a href="../classes/LegendControlComponent.html">LegendControlComponent</a></li>
	                            <li><a href="../classes/LineComponent.html">LineComponent</a></li>
	                            <li><a href="../classes/ListMapController.html">ListMapController</a></li>
	                            <li><a href="../classes/ListMapRoute.html">ListMapRoute</a></li>
	                            <li><a href="../classes/LocalStorageBindingMixin.html">LocalStorageBindingMixin</a></li>
	                            <li><a href="../classes/LocalStorageService.html">LocalStorageService</a></li>
	                            <li><a href="../classes/LocateMapCommand.html">LocateMapCommand</a></li>
	                            <li><a href="../classes/LocateMapCommandComponent.html">LocateMapCommandComponent</a></li>
	                            <li><a href="../classes/MapApiService.html">MapApiService</a></li>
	                            <li><a href="../classes/MapInfoComponent.html">MapInfoComponent</a></li>
	                            <li><a href="../classes/MapRoute.html">MapRoute</a></li>
	                            <li><a href="../classes/MapStoreService.html">MapStoreService</a></li>
	                            <li><a href="../classes/MarkerIdentifyMapTool.html">MarkerIdentifyMapTool</a></li>
	                            <li><a href="../classes/MarkersStylesEditorComponent.html">MarkersStylesEditorComponent</a></li>
	                            <li><a href="../classes/MarkersStylesRendererService.html">MarkersStylesRendererService</a></li>
	                            <li><a href="../classes/MeasureAreaMapTool.html">MeasureAreaMapTool</a></li>
	                            <li><a href="../classes/MeasureClearMapTool.html">MeasureClearMapTool</a></li>
	                            <li><a href="../classes/MeasureCoordinatesMapTool.html">MeasureCoordinatesMapTool</a></li>
	                            <li><a href="../classes/MeasureDistanceMapTool.html">MeasureDistanceMapTool</a></li>
	                            <li><a href="../classes/MeasureMapTool.html">MeasureMapTool</a></li>
	                            <li><a href="../classes/MeasureMapToolComponent.html">MeasureMapToolComponent</a></li>
	                            <li><a href="../classes/MeasureRadiusMapTool.html">MeasureRadiusMapTool</a></li>
	                            <li><a href="../classes/MetadataEditMode.html">MetadataEditMode</a></li>
	                            <li><a href="../classes/MetadataModeComponent.html">MetadataModeComponent</a></li>
	                            <li><a href="../classes/MiniMapComponent.html">MiniMapComponent</a></li>
	                            <li><a href="../classes/NewNewPlatformFlexberryGISLayerMetadataERoute.html">NewNewPlatformFlexberryGISLayerMetadataERoute</a></li>
	                            <li><a href="../classes/NewPlatformFlexberrtGISLayerMetadataEController.html">NewPlatformFlexberrtGISLayerMetadataEController</a></li>
	                            <li><a href="../classes/NewPlatformFlexberrtGISLayerMetadataLController.html">NewPlatformFlexberrtGISLayerMetadataLController</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISLayerLayerMetadataOfflineSerializer.html">NewPlatformFlexberryGISLayerLayerMetadataOfflineSerializer</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISLayerLinkModel.html">NewPlatformFlexberryGISLayerLinkModel</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISLayerLinkOfflineSerializer.html">NewPlatformFlexberryGISLayerLinkOfflineSerializer</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISLayerLinkSerializer.html">NewPlatformFlexberryGISLayerLinkSerializer</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISLayerMetadataERoute.html">NewPlatformFlexberryGISLayerMetadataERoute</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISLayerMetadataLRoute.html">NewPlatformFlexberryGISLayerMetadataLRoute</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISLayerMetadataModel.html">NewPlatformFlexberryGISLayerMetadataModel</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISLayerMetadataSerializer.html">NewPlatformFlexberryGISLayerMetadataSerializer</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISLinkMetadataModel.html">NewPlatformFlexberryGISLinkMetadataModel</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISLinkMetadataOfflineSerializer.html">NewPlatformFlexberryGISLinkMetadataOfflineSerializer</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISLinkMetadataSerializer.html">NewPlatformFlexberryGISLinkMetadataSerializer</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISLinkParameterModel.html">NewPlatformFlexberryGISLinkParameterModel</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISLinkParameterOfflineSerializer.html">NewPlatformFlexberryGISLinkParameterOfflineSerializer</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISLinkParameterSerializer.html">NewPlatformFlexberryGISLinkParameterSerializer</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISMapLayerModel.html">NewPlatformFlexberryGISMapLayerModel</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISMapLayerOfflineSerializer.html">NewPlatformFlexberryGISMapLayerOfflineSerializer</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISMapLayerSerializer.html">NewPlatformFlexberryGISMapLayerSerializer</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISMapModel.html">NewPlatformFlexberryGISMapModel</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISMapObjectSettingModel.html">NewPlatformFlexberryGISMapObjectSettingModel</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISMapObjectSettingOfflineSerializer.html">NewPlatformFlexberryGISMapObjectSettingOfflineSerializer</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISMapObjectSettingSerializer.html">NewPlatformFlexberryGISMapObjectSettingSerializer</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISMapOfflineSerializer.html">NewPlatformFlexberryGISMapOfflineSerializer</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISMapSerializer.html">NewPlatformFlexberryGISMapSerializer</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISParameterMetadataOfflineSerializer.html">NewPlatformFlexberryGISParameterMetadataOfflineSerializer</a></li>
	                            <li><a href="../classes/NewPlatformFlexberryGISParameterMetadataSerializer.html">NewPlatformFlexberryGISParameterMetadataSerializer</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISLayerLinkModelMixin.html">NewPlatformFlexberyGISLayerLinkModelMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISLayerLinkOfflineSerializerMixin.html">NewPlatformFlexberyGISLayerLinkOfflineSerializerMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISLayerLinkSerializerMixin.html">NewPlatformFlexberyGISLayerLinkSerializerMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISLayerMetadataModelMixin.html">NewPlatformFlexberyGISLayerMetadataModelMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISLayerMetadataOfflineSerializerMixin.html">NewPlatformFlexberyGISLayerMetadataOfflineSerializerMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISLayerMetadataSerializerMixin.html">NewPlatformFlexberyGISLayerMetadataSerializerMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISLinkMetadataModelMixin.html">NewPlatformFlexberyGISLinkMetadataModelMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISLinkMetadataOfflineSerializerMixin.html">NewPlatformFlexberyGISLinkMetadataOfflineSerializerMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISLinkMetadataSerializerMixin.html">NewPlatformFlexberyGISLinkMetadataSerializerMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISLinkParameterModelMixin.html">NewPlatformFlexberyGISLinkParameterModelMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISLinkParameterOfflineSerializerMixin.html">NewPlatformFlexberyGISLinkParameterOfflineSerializerMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISLinkParameterSerializerMixin.html">NewPlatformFlexberyGISLinkParameterSerializerMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISMapLayerModelMixin.html">NewPlatformFlexberyGISMapLayerModelMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISMapLayerOfflineSerializerMixin.html">NewPlatformFlexberyGISMapLayerOfflineSerializerMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISMapLayerSerializerMixin.html">NewPlatformFlexberyGISMapLayerSerializerMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISMapModelMixin.html">NewPlatformFlexberyGISMapModelMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISMapObjectSettingModelMixin.html">NewPlatformFlexberyGISMapObjectSettingModelMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISMapObjectSettingOfflineSerializerMixin.html">NewPlatformFlexberyGISMapObjectSettingOfflineSerializerMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISMapObjectSettingSerializerMixin.html">NewPlatformFlexberyGISMapObjectSettingSerializerMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISMapOfflineSerializerMixin.html">NewPlatformFlexberyGISMapOfflineSerializerMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISMapSerializerMixin.html">NewPlatformFlexberyGISMapSerializerMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISParameterMetadataModelMixin.html">NewPlatformFlexberyGISParameterMetadataModelMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISParameterMetadataOfflineSerializerMixin.html">NewPlatformFlexberyGISParameterMetadataOfflineSerializerMixin</a></li>
	                            <li><a href="../classes/NewPlatformFlexberyGISParameterMetadataSerializerMixin.html">NewPlatformFlexberyGISParameterMetadataSerializerMixin</a></li>
	                            <li><a href="../classes/ObjectContainsHelper.html">ObjectContainsHelper</a></li>
	                            <li><a href="../classes/ODataSettingsComponent.html">ODataSettingsComponent</a></li>
	                            <li><a href="../classes/ODataVectorlayer.html">ODataVectorlayer</a></li>
	                            <li><a href="../classes/ODataVectorLayerComponent.html">ODataVectorLayerComponent</a></li>
	                            <li><a href="../classes/ODataVectorSearchSettingsComponent.html">ODataVectorSearchSettingsComponent</a></li>
	                            <li><a href="../classes/OSMLayerComponent.html">OSMLayerComponent</a></li>
	                            <li><a href="../classes/PieComponent.html">PieComponent</a></li>
	                            <li><a href="../classes/PolygonIdentifyMapTool.html">PolygonIdentifyMapTool</a></li>
	                            <li><a href="../classes/PolylineIdentifyMapTool.html">PolylineIdentifyMapTool</a></li>
	                            <li><a href="../classes/Proj4Crs.html">Proj4Crs</a></li>
	                            <li><a href="../classes/RectangleIdentifyMapTool.html">RectangleIdentifyMapTool</a></li>
	                            <li><a href="../classes/RectangleMapTool.html">RectangleMapTool</a></li>
	                            <li><a href="../classes/RegexTestHelper.html">RegexTestHelper</a></li>
	                            <li><a href="../classes/ScaleControlComponent.html">ScaleControlComponent</a></li>
	                            <li><a href="../classes/SearchAttributesMapCommand.html">SearchAttributesMapCommand</a></li>
	                            <li><a href="../classes/SearchClearMapCommand.html">SearchClearMapCommand</a></li>
	                            <li><a href="../classes/SearchMapCommand.html">SearchMapCommand</a></li>
	                            <li><a href="../classes/SearchMapCommandComponent.html">SearchMapCommandComponent</a></li>
	                            <li><a href="../classes/SearchShowMapCommand.html">SearchShowMapCommand</a></li>
	                            <li><a href="../classes/SimpleCrs.html">SimpleCrs</a></li>
	                            <li><a href="../classes/SimpleLayersStyleComponent.html">SimpleLayersStyleComponent</a></li>
	                            <li><a href="../classes/SimpleLayersStyleFillEditorComponent.html">SimpleLayersStyleFillEditorComponent</a></li>
	                            <li><a href="../classes/SimpleLayersStylePathEditorComponent.html">SimpleLayersStylePathEditorComponent</a></li>
	                            <li><a href="../classes/SimpleLayersStyleStrokeDashArrayDropdownComponent.html">SimpleLayersStyleStrokeDashArrayDropdownComponent</a></li>
	                            <li><a href="../classes/SimpleLayersStyleStrokeEditorComponent.html">SimpleLayersStyleStrokeEditorComponent</a></li>
	                            <li><a href="../classes/SimpleLayersStyleStrokeLineCapDropdownComponent.html">SimpleLayersStyleStrokeLineCapDropdownComponent</a></li>
	                            <li><a href="../classes/SimpleLayersStyleStrokeLineJoinDropdownComponent.html">SimpleLayersStyleStrokeLineJoinDropdownComponent</a></li>
	                            <li><a href="../classes/SimpleLayerStyle.html">SimpleLayerStyle</a></li>
	                            <li><a href="../classes/SimpleLayerStyleLegendComponent.html">SimpleLayerStyleLegendComponent</a></li>
	                            <li><a href="../classes/SpatialBookmarkComponent.html">SpatialBookmarkComponent</a></li>
	                            <li><a href="../classes/SwitchScaleControlComponent.html">SwitchScaleControlComponent</a></li>
	                            <li><a href="../classes/TileLayer.html">TileLayer</a></li>
	                            <li><a href="../classes/TileLayerComponent.html">TileLayerComponent</a></li>
	                            <li><a href="../classes/TileLayerSettingsComponent.html">TileLayerSettingsComponent</a></li>
	                            <li><a href="../classes/UniqueLayersStyleComponent.html">UniqueLayersStyleComponent</a></li>
	                            <li><a href="../classes/UniqueLayerStyle.html">UniqueLayerStyle</a></li>
	                            <li><a href="../classes/UniqueLayerStyleLegendComponent.html">UniqueLayerStyleLegendComponent</a></li>
	                            <li><a href="../classes/Utils.CheckIntersect.html">Utils.CheckIntersect</a></li>
	                            <li><a href="../classes/Utils.Convertor.html">Utils.Convertor</a></li>
	                            <li><a href="../classes/Utils.Interpolator.html">Utils.Interpolator</a></li>
	                            <li><a href="../classes/Utils.LayerCopy.html">Utils.LayerCopy</a></li>
	                            <li><a href="../classes/Utils.LayerCreate.html">Utils.LayerCreate</a></li>
	                            <li><a href="../classes/Utils.Layers.html">Utils.Layers</a></li>
	                            <li><a href="../classes/Utils.LeafletOpacity.html">Utils.LeafletOpacity</a></li>
	                            <li><a href="../classes/VectorLayer.html">VectorLayer</a></li>
	                            <li><a href="../classes/VectorLegendComponent.html">VectorLegendComponent</a></li>
	                            <li><a href="../classes/WfsFilterParserMixin.html">WfsFilterParserMixin</a></li>
	                            <li><a href="../classes/WfsLayer.html">WfsLayer</a></li>
	                            <li><a href="../classes/WfsLayerComponent.html">WfsLayerComponent</a></li>
	                            <li><a href="../classes/WfsLayerSettingsComponent.html">WfsLayerSettingsComponent</a></li>
	                            <li><a href="../classes/WfsLegendComponent.html">WfsLegendComponent</a></li>
	                            <li><a href="../classes/WFSSearchSettingsComponent.html">WFSSearchSettingsComponent</a></li>
	                            <li><a href="../classes/WmsLayer.html">WmsLayer</a></li>
	                            <li><a href="../classes/WMSLayerComponent.html">WMSLayerComponent</a></li>
	                            <li><a href="../classes/WmsLayerSettingsComponent.html">WmsLayerSettingsComponent</a></li>
	                            <li><a href="../classes/WmsLegendComponent.html">WmsLegendComponent</a></li>
	                            <li><a href="../classes/WmsSingleTileLayer.html">WmsSingleTileLayer</a></li>
	                            <li><a href="../classes/WMSSingleTileLayerComponent.html">WMSSingleTileLayerComponent</a></li>
	                            <li><a href="../classes/WmsSingleTileLayerSettingsComponent.html">WmsSingleTileLayerSettingsComponent</a></li>
	                            <li><a href="../classes/WmsSingleTileLegendComponent.html">WmsSingleTileLegendComponent</a></li>
	                            <li><a href="../classes/WmsWfsLayer.html">WmsWfsLayer</a></li>
	                            <li><a href="../classes/WmsWfsLayerComponent.html">WmsWfsLayerComponent</a></li>
	                            <li><a href="../classes/YandexMapsGeoCoder.html">YandexMapsGeoCoder</a></li>
	                            <li><a href="../classes/ZoomInMapTool.html">ZoomInMapTool</a></li>
	                            <li><a href="../classes/ZoomInMapToolComponent.html">ZoomInMapToolComponent</a></li>
	                            <li><a href="../classes/ZoomOutMaptool.html">ZoomOutMaptool</a></li>
	                            <li><a href="../classes/ZoomOutMapToolComponent.html">ZoomOutMapToolComponent</a></li>
	                            <li><a href="../classes/ZoomsliderControlComponent.html">ZoomsliderControlComponent</a></li>
	                    </ul>
	                </div>
	    
	                <div class="tab-pane" id="modules">
	                    <ul id="api-modules" class="nav nav-list">
	                            <li><a href="../modules/ember-flexberry.html">ember-flexberry</a></li>
	                            <li><a href="../modules/ember-flexberry-gis.html">ember-flexberry-gis</a></li>
	                            <li><a href="../modules/ember-flexberry-gis-csw.html">ember-flexberry-gis-csw</a></li>
	                            <li><a href="../modules/ember-flexberry-gis-dummy.html">ember-flexberry-gis-dummy</a></li>
	                    </ul>
	                </div>
	            </div>
	        </div>
	    </div>
        </div>
        <div class="span9">
                <form id="options-form" class="form-inline pull-right">
                    Show:
                    <label for="api-show-inherited" class="checkbox">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected" class="checkbox">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private" class="checkbox">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated" class="checkbox">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </form>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<div class="page-header">
    <h1>addon/mixins/flexberry-map-model-api.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
import Ember from &#x27;ember&#x27;;
import distance from &#x27;npm:@turf/distance&#x27;;
import helpers from &#x27;npm:@turf/helpers&#x27;;
import booleanContains from &#x27;npm:@turf/boolean-contains&#x27;;
import area from &#x27;npm:@turf/area&#x27;;
import intersect from &#x27;npm:@turf/intersect&#x27;;
import rhumbBearing from &#x27;npm:@turf/rhumb-bearing&#x27;;
import rhumbDistance from &#x27;npm:@turf/rhumb-distance&#x27;;
import { getLeafletCrs } from &#x27;../utils/leaflet-crs&#x27;;
import VectorLayer from &#x27;../layers/-private/vector&#x27;;
import WfsLayer from &#x27;../layers/wfs&#x27;;
import OdataLayer from &#x27;../layers/odata-vector&#x27;;
import html2canvasClone from &#x27;../utils/html2canvas-clone&#x27;;
import state from &#x27;../utils/state&#x27;;
import SnapDraw from &#x27;./snap-draw&#x27;;
import ClipperLib from &#x27;npm:clipper-lib&#x27;;
import jsts from &#x27;npm:jsts&#x27;;

export default Ember.Mixin.create(SnapDraw, {
  /**
    Service for managing map API.
    @property mapApi
    @type MapApiService
  */
  mapApi: Ember.inject.service(),

  /*
    Shows layers specified by IDs.

    @method showLayers.
    @param {Array} layerIds Array of layer IDs.
    @return nothing
  */
  showLayers(layerIds) {
    this._setVisibility(layerIds, true);
  },

  /**
    Hides layers specified by IDs.

    @method hideLayers.
    @param {Array} layerIds Array of layer IDs.
    @return nothing
  */
  hideLayers(layerIds) {
    this._setVisibility(layerIds);
  },

  /**
    Shows objects for layer.

    @method showLayerObjects
    @param {string} layerId Layer id.
    @param {string[]} objectIds Array of objects IDs.
    @return nothing
  */
  showLayerObjects(layerId, objectIds) {
    this._setVisibilityObjects(layerId, objectIds, true);
  },

  /**
    Hides objects for layer.

    @method hideLayerObjects
    @param {string} layerId Layer id.
    @param {Array} objectIds Array of objects IDs.
    @return nothing
  */
  hideLayerObjects(layerId, objectIds) {
    this._setVisibilityObjects(layerId, objectIds, false);
  },

  /**
    Show all layer objects.

    @method showAllLayerObjects
    @param {string} layerId Layer id.
    @return nothing
  */
  showAllLayerObjects(layerId) {
    const layer = this.get(&#x27;mapLayer&#x27;).findBy(&#x27;id&#x27;, layerId);
    if (Ember.isNone(layer)) {
      throw &#x60;Layer &#x27;${layerId}&#x27; not found.&#x60;;
    }

    if (this._getTypeLayer(layer) instanceof VectorLayer) {
      const leafletObject = Ember.get(layer, &#x27;_leafletObject&#x27;);
      let map = this.get(&#x27;mapApi&#x27;).getFromApi(&#x27;leafletMap&#x27;);

      let showExisting = leafletObject.options.showExisting;
      let continueLoading = leafletObject.options.continueLoading;
      if (!showExisting &amp;&amp; !continueLoading) {
        if (!Ember.isNone(leafletObject)) {
          leafletObject.eachLayer((layerShape) =&gt; {
            if (map.hasLayer(layerShape)) {
              map.removeLayer(layerShape);
            }
          });
          leafletObject.clearLayers();
        }

        leafletObject.promiseLoadLayer = new Ember.RSVP.Promise((resolve) =&gt; {
          this._getModelLayerFeature(layerId, null, true).then(() =&gt; {
            resolve();
          });
        });
      } else {
        leafletObject.showLayerObjects = true;
        leafletObject.statusLoadLayer = true;
        map.fire(&#x27;moveend&#x27;);

        if (Ember.isNone(leafletObject.promiseLoadLayer) || !(leafletObject.promiseLoadLayer instanceof Ember.RSVP.Promise)) {
          leafletObject.promiseLoadLayer = Ember.RSVP.resolve();
        }
      }

      leafletObject.promiseLoadLayer.then(() =&gt; {
        leafletObject.statusLoadLayer = false;
        leafletObject.promiseLoadLayer = null;
        leafletObject.eachLayer(function (layerShape) {
          if (!map.hasLayer(layerShape)) {
            map.addLayer(layerShape);
          }
        });
        let labelLayer = leafletObject._labelsLayer;
        if (layer.get(&#x27;settingsAsObject.labelSettings.signMapObjects&#x27;) &amp;&amp; !Ember.isNone(labelLayer) &amp;&amp; !map.hasLayer(labelLayer)) {
          map.addLayer(labelLayer);
        }
      });
    }
  },

  /**
    Hide all layer objects.

    @method hideAllLayerObjects
    @param {string} layerId Layer id.
    @return nothing
  */
  hideAllLayerObjects(layerId) {
    const layer = this.get(&#x27;mapLayer&#x27;).findBy(&#x27;id&#x27;, layerId);
    if (Ember.isNone(layer)) {
      throw &#x60;Layer &#x27;${layerId}&#x27; not found.&#x60;;
    }

    if (this._getTypeLayer(layer) instanceof VectorLayer) {
      const leafletObject = Ember.get(layer, &#x27;_leafletObject&#x27;);
      var map = this.get(&#x27;mapApi&#x27;).getFromApi(&#x27;leafletMap&#x27;);
      leafletObject.showLayerObjects = false;

      leafletObject.eachLayer(function (layerShape) {
        if (map.hasLayer(layerShape)) {
          map.removeLayer(layerShape);
        }
      });
      let labelLayer = leafletObject._labelsLayer;
      if (layer.get(&#x27;settingsAsObject.labelSettings.signMapObjects&#x27;) &amp;&amp; !Ember.isNone(labelLayer) &amp;&amp; map.hasLayer(labelLayer)) {
        map.removeLayer(labelLayer);
      }
    }
  },

  /**
    Creates new layer with specified options.
    @method createNewLayer.
    @param {Object} options
    @return Layer ID.
  */
  createNewLayer(options) {
    options = options || {};
    const store = this.get(&#x27;store&#x27;);
    let layer = store.createRecord(&#x27;new-platform-flexberry-g-i-s-map-layer&#x27;, options);
    layer.set(&#x27;map&#x27;, this);
    return layer.save().then(() =&gt; {
      const layers = this.get(&#x27;hierarchy&#x27;);
      layers.addObject(layer);
      return layer.get(&#x27;id&#x27;);
    });
  },

  /**
    Remove object from layer.
    @method deleteLayerObject.
    @param {String} layerId Layer ID.
    @param {String} featureId Object ID.
    @return Promise.
  */
  deleteLayerObject(layerId, featureId) {
    this.deleteLayerObjects(layerId, [featureId]);
  },

  /**
    Remove shapes from layer.
    @method deleteLayerObjects.
    @param {string} layerId Layer ID.
    @param {Object[]} featureIds Array of objects IDs.
    @return Promise.
  */
  deleteLayerObjects(layerId, featureIds) {
    return new Ember.RSVP.Promise((resolve, reject) =&gt; {
      let ids = [];
      this._getModelLayerFeature(layerId, featureIds, true).then(([layer, leafletObject]) =&gt; {
        leafletObject.eachLayer(function (shape) {
          const id = this._getLayerFeatureId(layer, shape);

          if (!Ember.isNone(id) &amp;&amp; featureIds.indexOf(id) !== -1) {
            ids.push(id);
            leafletObject.removeLayer(shape);
          }
        }.bind(this));

        const deleteLayerFromAttrPanelFunc = this.get(&#x27;mapApi&#x27;).getFromApi(&#x27;_deleteLayerFromAttrPanel&#x27;);
        ids.forEach((id) =&gt; {
          if (typeof deleteLayerFromAttrPanelFunc === &#x27;function&#x27;) {
            deleteLayerFromAttrPanelFunc(id, layer);
          }
        });
        resolve();
      }).catch((e) =&gt; {
        reject(e);
      });
    });
  },

  /**
    Gets intersected features.
    @method getIntersectionObjects
    @param {Object} feature GeoJson Feature.
    @param {string} crsName Name of coordinate reference system, in which to give coordinates.
    @param {Array} layerIds Array of layers IDs.
    @return {Promise} Array of layers and objects which intersected selected object.
  */
  getIntersectionObjects(feature, crsName, layerIds) {
    return new Ember.RSVP.Promise((resolve, reject) =&gt; {
      if (!Ember.isNone(feature) &amp;&amp; feature.hasOwnProperty(&#x27;geometry&#x27;)) {
        const leafletMap = this.get(&#x27;mapApi&#x27;).getFromApi(&#x27;leafletMap&#x27;);
        let layersIntersect = [];
        layerIds.forEach(id =&gt; {
          const layer = this.get(&#x27;mapLayer&#x27;).findBy(&#x27;id&#x27;, id);
          if (!Ember.isNone(layer)) {
            let layerType = this._getTypeLayer(layer);
            if (layerType instanceof VectorLayer) {
              layersIntersect.push(layer);
            }
          }
        });

        let crs = crsName || &#x27;EPSG:4326&#x27;;
        let featureCrs = crs === &#x27;EPSG:4326&#x27; ? feature : this._convertObjectCoordinates(crs, feature);
        let featureLayer = L.GeoJSON.geometryToLayer(featureCrs);
        let latlng = featureLayer instanceof L.Marker || featureLayer instanceof L.CircleMarker ?
          featureLayer.getLatLng() : featureLayer.getBounds().getCenter();
        let e = {
          latlng: latlng,
          polygonLayer: featureLayer,
          bufferedMainPolygonLayer: featureLayer,
          excludedLayers: [],
          layers: layersIntersect,
          results: Ember.A()
        };

        if (e.layers.length &gt; 0) {
          leafletMap.fire(&#x27;flexberry-map:identify&#x27;, e);
        }

        e.results = Ember.isArray(e.results) ? e.results : Ember.A();
        let promises = Ember.A();

        // Handle each result.
        // Detach promises from already received features.
        e.results.forEach((result) =&gt; {
          if (Ember.isNone(result)) {
            return;
          }

          promises.pushObject(Ember.get(result, &#x27;features&#x27;));
        });

        // Wait for all promises to be settled &amp; call &#x27;_finishIdentification&#x27; hook.
        Ember.RSVP.allSettled(promises).then(() =&gt; {
          resolve(e.results);
        });
      }
    });
  },

  /**
    Get the nearest object
    @method getNearObject
    @param {string} layerId Layer ID of the selected object.
    @param {string} layerObjectId Object ID of the selected object.
    @param {Array} layerIdsArray Array of layers IDs in which to search.
    @return {Promise} Object constains distance, layer and layer object.
  */
  getNearObject(layerId, layerObjectId, layerIdsArray) {
    return new Ember.RSVP.Promise((resolve, reject) =&gt; {
      this._getModelLayerFeature(layerId, [layerObjectId]).then(([, leafletObject, layerObject]) =&gt; {
        let result = null;
        let promises = layerIdsArray.map(lid =&gt; {
          return new Ember.RSVP.Promise((resolve, reject) =&gt; {
            let layerModel = this.getLayerModel(lid);
            let layerType = this._getTypeLayer(layerModel);
            if (layerType instanceof OdataLayer) {
              let table = null;
              Ember.$.ajax({
                url: &#x27;assets/flexberry/models/&#x27; + layerModel.get(&#x27;_leafletObject.modelName&#x27;) + &#x27;.json&#x27;,
                async: false,
                success: function (data) {
                  table = data.className;
                }
              });
              let center = this.getObjectCenter(layerObject[0]);
              let geom = &#x60;SRID=4326;POINT(${center.lng} ${center.lat})&#x60;;
              geom = geom.replace(&#x27;.&#x27;, &#x27;,&#x27;).replace(&#x27;.&#x27;, &#x27;,&#x27;);
              let config = Ember.getOwner(this).resolveRegistration(&#x27;config:environment&#x27;);
              let _this = this;
              Ember.$.ajax({
                url: &#x60;${config.APP.backendUrls.getNearDistance}(geom=&#x27;${geom}&#x27;, table=&#x27;${table}&#x27;)&#x60;,
                type: &#x27;GET&#x27;,
                success: function (data) {
                  _this._getModelLayerFeature(lid, [data.pk]).then(([, leafletObject, layerObject]) =&gt; {
                    resolve({
                      distance: data.distance,
                      layer: layerModel,
                      object: layerObject[0],
                    });
                  });
                }
              });
            } else {
              this._getModelLayerFeature(lid, null).then(([layer, lObject, featuresLayer]) =&gt; {
                featuresLayer.forEach(obj =&gt; {
                  const id = this._getLayerFeatureId(layer, obj);
                  const distance = this._getDistanceBetweenObjects(layerObject[0], obj);

                  if (layerId === lid &amp;&amp; layerObjectId === id) {
                    return;
                  }

                  if (Ember.isNone(result) || distance &lt; result.distance) {
                    result = {
                      distance: distance,
                      layer: layer,
                      object: obj,
                    };
                  }
                });

                resolve(result);
              });
            }
          });
        });

        Ember.RSVP.allSettled(promises).then((results) =&gt; {
          let res = null;
          results.forEach((item) =&gt; {
            if (Ember.isNone(res) || item.value.distance &lt; res.distance) {
              res = item.value;
            }
          });
          resolve(res);
        });
      }).catch((e) =&gt; {
        reject(e);
      });
    });
  },

  getObjectCenter(object) {
    const type = Ember.get(object, &#x27;feature.geometry.type&#x27;);
    if (type === &#x27;Point&#x27;) {
      return object._latlng;
    } else {
      return object.getBounds().getCenter();
    }
  },

  /**
    Get distance between objects
    @method _getDistanceBetweenObjects
    @param {Object} firstLayerObject First layer object.
    @param {Object} secondLayerObject Second layer object.
    @return {number} Distance between objects in meters.
  */
  _getDistanceBetweenObjects(firstLayerObject, secondLayerObject) {
    const firstPoint = this.getObjectCenter(firstLayerObject);
    const firstObject = helpers.point([firstPoint.lat, firstPoint.lng]);

    const secondPoint = this.getObjectCenter(secondLayerObject);
    const secondObject = helpers.point([secondPoint.lat, secondPoint.lng]);

    // Get distance in meters.
    return distance.default(firstObject, secondObject, { units: &#x27;kilometers&#x27; }) * 1000;
  },

  /**
    Get distance between objects
    @method getDistanceBetweenObjects
    @param {string} firstLayerId First layer id.
    @param {string} firstLayerObjectId First layer object id.
    @param {string} secondLayerId Second layer id.
    @param {string} secondLayerObjectId Second layer object id.
    @return {Promise} Distance between objects in meters.
  */
  getDistanceBetweenObjects(firstLayerId, firstLayerObjectId, secondLayerId, secondLayerObjectId) {
    return new Ember.RSVP.Promise((resolve, reject) =&gt; {
      Ember.RSVP.all([
        this._getModelLayerFeature(firstLayerId, [firstLayerObjectId]),
        this._getModelLayerFeature(secondLayerId, [secondLayerObjectId])
      ]).then((result) =&gt; {
        let objA = result[0][2][0];
        let objB = result[1][2][0];
        resolve(this._getDistanceBetweenObjects(objA, objB));
      }).catch((e) =&gt; {
        reject(e);
      });
    });
  },

  /**
    Get layer object attributes and coordinates.
    @method getLayerObjectOptions
    @param {String} layerId Layer ID.
    @param {String} featureId Object ID.
    @param {String} crsName Name of coordinate reference system, in which to give coordinates.
    @return {Promise} Attributes and coordinates
  */
  getLayerObjectOptions(layerId, featureId, crsName) {
    return new Ember.RSVP.Promise((resolve, reject) =&gt; {
      let result;
      this._getModelLayerFeature(layerId, [featureId]).then(([, leafletLayer, features]) =&gt; {
        let featureLayer = features[0];
        if (leafletLayer &amp;&amp; featureLayer) {
          result = Object.assign({}, featureLayer.feature.properties);
          if (crsName) {
            let NewObjCrs = this._convertObjectCoordinates(leafletLayer.options.crs.code, featureLayer.feature, crsName);
            result.geometry = NewObjCrs.geometry.coordinates;
          } else {
            result.geometry = featureLayer.feature.geometry.coordinates;
          }

          let jstsGeoJSONReader = new jsts.io.GeoJSONReader();
          let featureLayerGeoJSON = featureLayer.toProjectedGeoJSON(leafletLayer.options.crs);
          let jstsGeoJSON = jstsGeoJSONReader.read(featureLayerGeoJSON);
          result.area = jstsGeoJSON.geometry.getArea();
          resolve(result);
        }
      }).catch((e) =&gt; {
        reject(e);
      });
    });
  },

  /**
    Check if object A contains object B.
    @method isContainsObject
    @param {String} layerAId First layer ID.
    @param {String} objectAId First object ID.
    @param {String} layerBId Second layer ID.
    @param {String} objectBId Second object ID.
    @return {Promise} true or false.
  */
  isContainsObject(layerAId, objectAId, layerBId, objectBId) {
    return new Ember.RSVP.Promise((resolve, reject) =&gt; {
      Ember.RSVP.all([
        this._getModelLayerFeature(layerAId, [objectAId]),
        this._getModelLayerFeature(layerBId, [objectBId])
      ]).then((result) =&gt; {
        let objA = result[0][2][0].feature;
        let objB = result[1][2][0].feature;
        let leafletLayerA = result[0][1];
        let leafletLayerB = result[1][1];
        if (objA &amp;&amp; objB &amp;&amp; leafletLayerA &amp;&amp; leafletLayerB) {
          let feature1 = leafletLayerA.options.crs.code === &#x27;EPSG:4326&#x27; ? objA : this._convertObjectCoordinates(leafletLayerA.options.crs.code, objA);
          let feature2 = leafletLayerB.options.crs.code === &#x27;EPSG:4326&#x27; ? objB : this._convertObjectCoordinates(leafletLayerB.options.crs.code, objB);

          if (feature1.geometry.type === &#x27;MultiPolygon&#x27;) {
            feature1 = L.polygon(feature1.geometry.coordinates[0]).toGeoJSON();
          }

          if (feature2.geometry.type === &#x27;MultiPolygon&#x27;) {
            feature2 = L.polygon(feature2.geometry.coordinates[0]).toGeoJSON();
          }

          resolve(booleanContains(feature1, feature2));
        }

      }).catch((e) =&gt; {
        reject(e);
      });
    });
  },

  /**
    Calculate the area of object B that extends beyond the boundaries of object A.
    @method getAreaExtends
    @param {String} layerAId First layer ID.
    @param {String} objectAId First object ID.
    @param {String} layerBId Second layer ID.
    @param {String} objectBId Second object ID.
    @return {Promise} Area
  */
  getAreaExtends(layerAId, objectAId, layerBId, objectBId) {
    return new Ember.RSVP.Promise((resolve, reject) =&gt; {
      Ember.RSVP.all([
        this._getModelLayerFeature(layerAId, [objectAId]),
        this._getModelLayerFeature(layerBId, [objectBId])
      ]).then((result) =&gt; {
        let objA = result[0][2][0].feature;
        let objB = result[1][2][0].feature;
        let layerObjectA = result[0][1];
        let layerObjectB = result[1][1];
        let feature1 = layerObjectA.options.crs.code === &#x27;EPSG:4326&#x27; ? objA : this._convertObjectCoordinates(layerObjectA.options.crs.code, objA);
        let feature2 = layerObjectB.options.crs.code === &#x27;EPSG:4326&#x27; ? objB : this._convertObjectCoordinates(layerObjectB.options.crs.code, objB);
        let intersectionRes = intersect.default(feature2, feature1);
        if (intersectionRes) {
          let resultArea = area(feature2) - area(intersectionRes);
          resolve(resultArea);
        } else {
          resolve(area(feature2));
        }
      }).catch((e) =&gt; {
        reject(e);
      });
    });
  },

  /**
    Get layer type.
    @method _getTypeLayer
    @param {Object} layerModel layer model.
    @return {Object} layer type
  */
  _getTypeLayer(layerModel) {
    let className = Ember.get(layerModel, &#x27;type&#x27;);
    let layerType = Ember.getOwner(this).knownForType(&#x27;layer&#x27;, className);
    return layerType;
  },

  _setVisibility(layerIds, visibility = false) {
    if (Ember.isArray(layerIds)) {
      const layers = this.get(&#x27;mapLayer&#x27;);
      let leafletMap = this.get(&#x27;mapApi&#x27;).getFromApi(&#x27;leafletMap&#x27;);
      layerIds.forEach(id =&gt; {
        const layer = layers.findBy(&#x27;id&#x27;, id);
        if (layer) {
          layer.set(&#x27;visibility&#x27;, visibility);
          if (visibility &amp;&amp; this._getTypeLayer(layer) instanceof VectorLayer) {
            let leafletObject = Ember.get(layer, &#x27;_leafletObject&#x27;);
            let showExisting = leafletObject.options.showExisting;
            let continueLoading = leafletObject.options.continueLoading;
            if (!showExisting &amp;&amp; !continueLoading) {
              this._getModelLayerFeature(id, null, true).then(() =&gt; {
                layer.set(&#x27;visibility&#x27;, visibility);
              });
            } else {
              leafletMap.fire(&#x27;moveend&#x27;);
            }
          }
        }
      });
    }
  },

  /**
    Get object id by object and layer.

    @method _getLayerFeatureId
    @param {Object} layer Layer.
    @param {Object} layerObject Object.
    @return {number} Object ID.
  */
  _getLayerFeatureId(layer, layerObject) {
    let field = this._getPkField(layer);
    if (layerObject.state !== state.insert) {
      if (layerObject.feature.properties.hasOwnProperty(field)) {
        return Ember.get(layerObject, &#x27;feature.properties.&#x27; + field);
      }

      return Ember.get(layerObject, &#x27;feature.id&#x27;);
    } else {
      return null;
    }
  },

  /**
    Determine the visibility of the specified objects by id for the layer.

    @method _setVisibilityObjects
    @param {string} layerId Layer ID.
    @param {string[]} objectIds Array of objects IDs.
    @param {boolean} [visibility=false] visibility Object Visibility.
  */
  _setVisibilityObjects(layerId, objectIds, visibility = false) {
    if (Ember.isArray(objectIds)) {
      const layers = this.get(&#x27;mapLayer&#x27;);
      const layer = layers.findBy(&#x27;id&#x27;, layerId);
      if (Ember.isNone(layer)) {
        throw &#x60;Layer &#x27;${layerId}&#x27; not found.&#x60;;
      }

      if (this._getTypeLayer(layer) instanceof VectorLayer) {
        const leafletObject = Ember.get(layer, &#x27;_leafletObject&#x27;);

        if (Ember.isNone(leafletObject)) {
          throw &#x27;Layer type not supported&#x27;;
        }

        const map = this.get(&#x27;mapApi&#x27;).getFromApi(&#x27;leafletMap&#x27;);
        if (visibility) {
          let showExisting = leafletObject.options.showExisting;
          let continueLoading = leafletObject.options.continueLoading;
          if (!showExisting &amp;&amp; !continueLoading) {
            leafletObject.promiseLoadLayer = new Ember.RSVP.Promise((resolve) =&gt; {
              this._getModelLayerFeature(layerId, objectIds, true).then(() =&gt; {
                resolve();
              });
            });
          } else {
            leafletObject.showLayerObjects = visibility;
            leafletObject.statusLoadLayer = true;
            map.fire(&#x27;moveend&#x27;);
            if (Ember.isNone(leafletObject.promiseLoadLayer) || !(leafletObject.promiseLoadLayer instanceof Ember.RSVP.Promise)) {
              leafletObject.promiseLoadLayer = Ember.RSVP.resolve();
            }
          }
        } else {
          leafletObject.promiseLoadLayer = Ember.RSVP.resolve();
        }

        leafletObject.promiseLoadLayer.then(() =&gt; {
          leafletObject.statusLoadLayer = false;
          leafletObject.promiseLoadLayer = null;
          objectIds.forEach(objectId =&gt; {
            let objects = Object.values(leafletObject._layers).filter(shape =&gt; {
              return this._getLayerFeatureId(layer, shape) === objectId;
            });
            if (objects.length &gt; 0) {
              objects.forEach(obj =&gt; {
                if (visibility) {
                  map.addLayer(obj);
                } else {
                  map.removeLayer(obj);
                }
              });
            }
          });
          let labelLayer = leafletObject._labelsLayer;
          if (layer.get(&#x27;settingsAsObject.labelSettings.signMapObjects&#x27;) &amp;&amp; !Ember.isNone(labelLayer) &amp;&amp; !map.hasLayer(labelLayer)) {
            objectIds.forEach(objectId =&gt; {
              let objects = Object.values(labelLayer._layers).filter(shape =&gt; {
                return this._getLayerFeatureId(layer, shape) === objectId;
              });
              if (objects.length &gt; 0) {
                objects.forEach(obj =&gt; {
                  if (visibility) {
                    map.addLayer(obj);
                  } else {
                    map.removeLayer(obj);
                  }
                });
              }
            });
          }
        });
      }
    }
  },

  /**
    To copy Object from Source layer to Destination.
    @method copyObject
    @param {Object} source Object with source settings
    {
      layerId, //{string} Layer ID
      objectId, //{string} Object ID
      shouldRemove //{Bool} Should remove object from source layer
    }
    @param {Object} destination Object with destination settings
    {
      layerId, //{string} Layer ID
      properties //{Object} Properties of new object.
    }
    @return {Promise} Object in Destination layer
  */
  copyObject(source, destination) {
    return new Ember.RSVP.Promise((resolve, reject) =&gt; {
      this._getModelLayerFeature(source.layerId, [source.objectId], source.shouldRemove).then(([, sourceLeafletLayer, obj]) =&gt; {
        let sourceFeature = obj[0];
        let [destLayerModel, destLeafletLayer] = this._getModelLeafletObject(destination.layerId);
        let destFeature;
        switch (destLayerModel.get(&#x27;settingsAsObject.typeGeometry&#x27;).toLowerCase()) {
          case &#x27;polygon&#x27;:
            destFeature = L.polygon(sourceFeature.getLatLngs());
            break;
          case &#x27;polyline&#x27;:
            destFeature = L.polyline(sourceFeature.getLatLngs());
            break;
          case &#x27;marker&#x27;:
            destFeature = L.marker(sourceFeature.getLatLng());
            break;
          default:
            reject(&#x60;Unknown layer type: &#x27;${destLayerModel.get(&#x27;settingsAsObject.typeGeometry&#x27;)}&#x60;);
        }

        if (!Ember.isNone(destFeature)) {
          destFeature.feature = {
            properties: Object.assign({}, sourceFeature.feature.properties, destination.properties || {})
          };

          if (sourceLeafletLayer.geometryField) {
            delete destFeature.feature.properties[sourceLeafletLayer.geometryField];
          }

          if (destLeafletLayer.geometryField) {
            delete destFeature.feature.properties[destLeafletLayer.geometryField];
          }

          let e = { layers: [destFeature], results: Ember.A() };
          destLeafletLayer.fire(&#x27;load&#x27;, e);

          Ember.RSVP.allSettled(e.results).then(() =&gt; {
            if (source.shouldRemove) {
              sourceLeafletLayer.removeLayer(sourceFeature);
            }

            resolve(destFeature);
          });
        }
      }).catch((e) =&gt; {
        reject(e);
      });
    });
  },

  /**
    Calculate the area of intersection between object A and objects in array B.
    @method getIntersectionArea
    @param {String} layerAId First layer ID.
    @param {String} objectAId First object ID.
    @param {String} layerBId Second layer ID.
    @param {Array} objectBIds Array of object IDs in second layer.
    @param {Bool} showOnMap flag indicates if intersection area will be displayed on map.
    @return {Promise} If showOnMap = true, return objects, which show on map in serviceLayer, and area, else only area.
  */
  getIntersectionArea(layerAId, objectAId, layerBId, objectBIds, showOnMap) {
    return new Ember.RSVP.Promise((resolve, reject) =&gt; {
      let result = Ember.A();
      Ember.RSVP.all([
        this._getModelLayerFeature(layerAId, [objectAId]),
        this._getModelLayerFeature(layerBId, objectBIds)
      ]).then((res) =&gt; {
        let layerObjectA = res[0][1];
        let layerObjectB = res[1][1];
        let objA = res[0][2][0].feature;
        let feature1 = layerObjectA.options.crs.code === &#x27;EPSG:4326&#x27; ? objA : this._convertObjectCoordinates(layerObjectA.options.crs.code, objA);
        let featuresB = res[1][2];
        featuresB.forEach((feat) =&gt; {
          let objB = feat.feature;
          let feature2 = layerObjectB.options.crs.code === &#x27;EPSG:4326&#x27; ? objB : this._convertObjectCoordinates(layerObjectB.options.crs.code, objB);
          let intersectionRes = intersect.default(feature1, feature2);
          if (intersectionRes) {
            let object = {
              id: objB.properties.primarykey,
              area: area(intersectionRes)
            };
            if (showOnMap) {
              let obj = L.geoJSON(intersectionRes, {
                style: { color: &#x27;green&#x27; }
              });
              let serviceLayer = this.get(&#x27;mapApi&#x27;).getFromApi(&#x27;serviceLayer&#x27;);
              obj.addTo(serviceLayer);
              object.objectIntesect = obj;
            }

            result.pushObject(object);
          } else {
            result.pushObject({
              id: objB.properties.primarykey,
              area: &#x27;Intersection not found&#x27;
            });
          }
        });
        if (!Ember.isNone(result)) {
          resolve(result);
        }
      }).catch((e) =&gt; {
        reject(e);
      });
    });
  },

  /**
    Cleans the service layer.
    @method clearServiceLayer
    @return nothing
  */
  clearServiceLayer() {
    let serviceLayer = this.get(&#x27;mapApi&#x27;).getFromApi(&#x27;serviceLayer&#x27;);
    serviceLayer.clearLayers();
  },

  /**
    Create image for layer object.
    @method  getSnapShot
    @param {Object} source Object with settings
    {
      layerId, //{string} Layer ID.
      objectId, //{string} Object ID.
      layerArrIds, //{Array} Array of layers IDs.
      options {
        width, //{number} width image
        height //{number} height image
      }
    }
    @return {Promise} Image url.
  */
  getSnapShot({ layerId, objectId, layerArrIds, options }) {
    return new Ember.RSVP.Promise((resolve, reject) =&gt; {
      this._getModelLayerFeature(layerId, [objectId]).then(([layerModel, leafletObject, featureLayer]) =&gt; {
        let allLayers = this.get(&#x27;mapLayer.canonicalState&#x27;);
        let allLayersIds = allLayers.map((l) =&gt; l.id);
        if (layerArrIds) {
          let showLayersIds = layerArrIds;
          showLayersIds.push(layerId);

          this.showLayers(showLayersIds);
          let hideLayersIds = allLayersIds.filter((i) =&gt; { return showLayersIds.indexOf(i) &lt; 0; });
          this.hideLayers(hideLayersIds);
        }

        const leafletMap = this.get(&#x27;mapApi&#x27;).getFromApi(&#x27;leafletMap&#x27;);

        let $mapPicture = Ember.$(leafletMap._container);
        let heightMap = $mapPicture.height();
        let widthMap = $mapPicture.width();
        let heightNew = heightMap;
        let widthNew = widthMap;
        if (!Ember.isNone(options)) {
          heightNew = Ember.isNone(options.height) ? heightMap : options.height;
          widthNew = Ember.isNone(options.width) ? widthMap : options.width;
        }

        $mapPicture.height(heightNew);
        $mapPicture.width(widthNew);

        let load = [];
        let ids = Ember.isEmpty(layerArrIds) ? allLayersIds : layerArrIds;
        if (ids) {
          ids.forEach((lid) =&gt; {
            if (lid !== layerId) {
              let [layer, layerObject] = this._getModelLeafletObject(lid);
              let layerType = this._getTypeLayer(layer);
              if ((layerType instanceof WfsLayer || layerType instanceof OdataLayer) &amp;&amp; !Ember.isNone(layerObject)) {
                layerObject.statusLoadLayer = true;
                load.push(layerObject);
              }
            }
          });
        }

        let layerType = this._getTypeLayer(layerModel);
        if (layerType instanceof WfsLayer || layerType instanceof OdataLayer) {
          leafletObject.statusLoadLayer = true;
          load.push(leafletObject);
        }

        leafletMap.once(&#x27;moveend&#x27;, () =&gt; {
          Ember.run.later(() =&gt; {
            document.getElementsByClassName(&#x27;leaflet-control-zoom leaflet-bar leaflet-control&#x27;)[0].style.display = &#x27;none&#x27;;
            document.getElementsByClassName(&#x27;history-control leaflet-bar leaflet-control horizontal&#x27;)[0].style.display = &#x27;none&#x27;;
            Ember.$(document).find(&#x27;.leaflet-top.leaflet-left&#x27;).css(&#x27;display&#x27;, &#x27;none&#x27;);
            Ember.$(document).find(&#x27;.leaflet-top.leaflet-right&#x27;).css(&#x27;display&#x27;, &#x27;none&#x27;);
            Ember.$(document).find(&#x27;.leaflet-bottom.leaflet-right&#x27;).css(&#x27;display&#x27;, &#x27;none&#x27;);

            let promises = load.map((object) =&gt; {
              return object.promiseLoadLayer;
            });

            Ember.RSVP.allSettled(promises).then((e) =&gt; {
              load.forEach((obj) =&gt; {
                obj.statusLoadLayer = false;
                obj.promiseLoadLayer = null;
              });

              let html2canvasOptions = Object.assign({
                useCORS: true,
                onclone: function (clonedDoc) {
                  html2canvasClone(clonedDoc);
                }
              });
              window.html2canvas($mapPicture[0], html2canvasOptions)
                .then((canvas) =&gt; {
                  let type = &#x27;image/png&#x27;;
                  var image64 = canvas.toDataURL(type);
                  resolve(image64);
                })
                .catch((e) =&gt; reject(e))
                .finally(() =&gt; {
                  document.getElementsByClassName(&#x27;leaflet-control-zoom leaflet-bar leaflet-control&#x27;)[0].style.display = &#x27;block&#x27;;
                  document.getElementsByClassName(&#x27;history-control leaflet-bar leaflet-control horizontal&#x27;)[0].style.display = &#x27;block&#x27;;
                  Ember.$(document).find(&#x27;.leaflet-top.leaflet-left&#x27;).css(&#x27;display&#x27;, &#x27;block&#x27;);
                  Ember.$(document).find(&#x27;.leaflet-top.leaflet-right&#x27;).css(&#x27;display&#x27;, &#x27;block&#x27;);
                  Ember.$(document).find(&#x27;.leaflet-bottom.leaflet-right&#x27;).css(&#x27;display&#x27;, &#x27;block&#x27;);
                  $mapPicture.height(heightMap);
                  $mapPicture.width(widthMap);
                });
            });
          });
        });

        let bounds = featureLayer[0].getBounds();
        if (!Ember.isNone(bounds)) {
          leafletMap.fitBounds(bounds.pad(0.5));
        }
      }).catch((e) =&gt; {
        reject(e);
      });
    });
  },

  /**
    Download image for layer object.
    @method  downloadSnapShot
    @param {Object} source Object with settings
    {
      layerId, //{string} Layer ID.
      objectId, //{string} Object ID.
      layerArrIds, //{Array} Array of layers IDs.
      options {
        width, //{number} width image
        height //{number} height image
      },
      fileName //{string} File name.
    }
    @return {File} Image file.
  */
  downloadSnapShot({ layerId, objectId, layerArrIds, options, fileName }) {
    this.getSnapShot({ layerId, objectId, layerArrIds, options }).then((uri) =&gt; {
      var link = document.createElement(&#x27;a&#x27;);
      if (typeof link.download === &#x27;string&#x27;) {
        link.href = uri;
        link.download = fileName;

        //Firefox requires the link to be in the body
        document.body.appendChild(link);

        //simulate click
        link.click();

        //remove the link when done
        document.body.removeChild(link);
      } else {
        window.open(uri);
      }
    });
  },

  /**
    Get a rhumb object for [LineString, MultiLineString, Polygon, MultiPolygon]. Parameters is object in GeoJSON
    format and name of coordinate reference system. Calculates rhumb between points. Use @turf/rhumb-bearing and
    @turf/rhumb-distance libraries to calculate angle and distance between points. Distance calculation is
    approximate and in meters. Names of direction is [NE, SE, NW, SW]. Angle calculation in degree.
    Returns array of object:

    &#x60;&#x60;&#x60;javascript
    [{
      type - type of object is [LineString, Polygon],
      crs - name of coordinate reference system of start point,
      startPoint - coordinates of start point,
      skip - how many rhumb skip from beginning (always 0),
      points - array objects of rhumbs,
      hole - if this part is hole then true else false. Only Polygon and MultiPolygon have it.
    }]
    &#x60;&#x60;&#x60;

    Objects of rhumbs consist from angle, distance and direction of rhumb. Example:

    &#x60;&#x60;&#x60;javascript
    {
      rhumb: &#x27;NE&#x27;,
      angle: 45,
      distance: 1000
    }
    &#x60;&#x60;&#x60;

    Example of method call:

    &#x60;&#x60;&#x60;javascript
    var feature = {
      type: &quot;Feature&quot;,
      geometry:
      {
        &quot;type&quot;: &quot;Polygon&quot;,
        &quot;coordinates&quot;: [
          [[56.09419, 58.08895], [56.093588, 58.088632], [56.094269, 58.088632], [56.094269, 58.088902], [56.09419, 58.08895]]
        ]
      }
    };

    var result = mapApi.mapModel.getRhumb(feature, &#x27;EPSG:4326&#x27;);
    &#x60;&#x60;&#x60;
    @method  getRhumb
    @param {Object} feature GeoJson Feature.
    @param {string} crsName Name of coordinate reference system, in which to give coordinates.
    @return {Array} Array object rhumb.
  */
  getRhumb(feature, crsName) {
    let coords = feature.geometry.coordinates;
    let result = [];

    var calcRhumb = function (point1, point2) {
      const pointFrom = helpers.point([point2[0], point2[1]]);
      const pointTo = helpers.point([point1[0], point1[1]]);

      // We get the distance and translate into meters. Distance calculattion is approximate.
      const distance = rhumbDistance.default(pointFrom, pointTo, { units: &#x27;kilometers&#x27; }) * 1000;

      // Get the angle.
      const bearing = rhumbBearing.default(pointTo, pointFrom);

      let rhumb;
      let angle;

      // Calculates rhumb.
      if (bearing &lt;= 90 &amp;&amp; bearing &gt;= 0) {
        // NE
        rhumb = &#x27;NE&#x27;;
        angle = bearing;
      } else if (bearing &lt;= 180 &amp;&amp; bearing &gt;= 90) {
        // SE
        rhumb = &#x27;SE&#x27;;
        angle = (180 - bearing);
      } else if (bearing &gt;= -180 &amp;&amp; bearing &lt;= -90) {
        // SW
        rhumb = &#x27;SW&#x27;;
        angle = (180 + bearing);
      } if (bearing &lt;= 0 &amp;&amp; bearing &gt;= -90) {
        // NW
        rhumb = &#x27;NW&#x27;;
        angle = (-1 * bearing);
      }

      return {
        rhumb: rhumb,
        angle: angle,
        distance: distance
      };
    };

    let coordToRhumbs = function(type, coords) {
      let startPoint = null;
      let n;
      let point1;
      let point2;
      let rhumbs = [];
      for (let i = 0; i &lt; coords.length - 1; i++) {
        startPoint = i === 0 ? coords[i] : startPoint;
        point1 = coords[i];
        n = !Ember.isNone(coords[i + 1]) ? i + 1 : 0;
        point2 = coords[n];
        rhumbs.push(calcRhumb(point1, point2));
      }

      return {
        type: type,
        crs: crsName,
        startPoint: startPoint,
        skip: 0,
        points: rhumbs
      };
    };

    switch (feature.geometry.type) {
      case &#x27;LineString&#x27;:
        result.push(coordToRhumbs(&#x27;LineString&#x27;, coords));
        break;
      case &#x27;MultiLineString&#x27;:
        for (let i = 0; i &lt; coords.length; i++) {
          result.push(coordToRhumbs(&#x27;LineString&#x27;, coords[i]));
        }

        break;
      case &#x27;Polygon&#x27;:
        for (let i = 0; i &lt; coords.length; i++) {
          result.push(coordToRhumbs(&#x27;Polygon&#x27;, coords[i]));
          result[i].hole = i &gt; 0 ? true : false;
        }

        break;
      case &#x27;MultiPolygon&#x27;:
        let k = 0;
        for (let i = 0; i &lt; coords.length; i++) {
          for (let j = 0; j &lt; coords[i].length; j++) {
            result.push(coordToRhumbs(&#x27;Polygon&#x27;, coords[i][j]));
            result[result.length - 1].hole = j &gt; 0 ? true : false;
          }
        }

        break;
    }

    return result;
  },

  /**
    Add a layer to the group.

    @method layerToGroup
    @parm {string} layerId Layer ID.
    @parm {string} layerGroupId Group layer ID.
    @return nothing
  */
  moveLayerToGroup(layerId, layerGroupId) {
    const layer = this.get(&#x27;mapLayer&#x27;).findBy(&#x27;id&#x27;, layerGroupId);
    if (Ember.isNone(layer)) {
      throw (&#x60;Group layer &#x27;${layerGroupId}&#x27; not found&#x60;);
    }

    let layerModel = this.getLayerModel(layerId);
    if (Ember.isNone(layerModel)) {
      throw (&#x60;Layer &#x27;${layerId}&#x27; not found&#x60;);
    }

    layerModel.set(&#x27;parent&#x27;, layer);
  },

  /**
    Edit object layer.
    @method editLayerObject
    @param {String} layerId Layer ID.
    @param {String} objectId Object ID.
    @param {String} polygon oordinates of the new object in geoJSON format.
    @param {String} crsName Name of coordinate reference system.
    @return {Promise} Layer object.
  */
  editLayerObject(layerId, objectId, polygon, crsName) {
    return new Ember.RSVP.Promise((resolve, reject) =&gt; {
      if (polygon) {
        this._getModelLayerFeature(layerId, [objectId], true).then(([, leafletLayer, featureLayer]) =&gt; {
          if (leafletLayer &amp;&amp; featureLayer) {
            let crs = leafletLayer.options.crs;
            if (!Ember.isNone(crsName)) {
              crs = getLeafletCrs(&#x27;{ &quot;code&quot;: &quot;&#x27; + crsName.toUpperCase() + &#x27;&quot;, &quot;definition&quot;: &quot;&quot; }&#x27;, this);
            }

            let coordsToLatLng = function (coords) {
              return crs.unproject(L.point(coords));
            };

            let geoJSON = null;
            if (!Ember.isNone(crs) &amp;&amp; crs.code !== &#x27;EPSG:4326&#x27;) {
              geoJSON = L.geoJSON(polygon, { coordsToLatLng: coordsToLatLng.bind(this) }).getLayers()[0];
            } else {
              geoJSON = L.geoJSON(polygon).getLayers()[0];
            }

            if (!Ember.isNone(Ember.get(geoJSON, &#x27;feature.geometry&#x27;))) {
              if (Ember.get(geoJSON, &#x27;feature.geometry.type&#x27;).toLowerCase() !== &#x27;point&#x27;) {
                featureLayer[0].setLatLngs(geoJSON._latlngs);
              } else {
                featureLayer[0].setLatLng(geoJSON._latlng);
              }

              if (typeof leafletLayer.editLayer === &#x27;function&#x27;) {
                leafletLayer.editLayer(featureLayer[0]);
                resolve(featureLayer[0]);
              }
            } else {
              reject(&#x60;Unable to convert coordinates for this CRS &#x27;${crsName}&#x27;&#x60;);
            }
          } else if (leafletLayer) {
            reject(&#x60;Layer &#x27;${layerId}&#x27; not found&#x60;);
          } else if (featureLayer[0]) {
            reject(&#x60;Object &#x27;${objectId}&#x27; not found&#x60;);
          }
        }).catch((e) =&gt; {
          reject(e);
        });
      } else {
        reject(&#x27;new object settings not passed&#x27;);
      }
    });
  },

  /**
    Upload file.
    @method uploadFile
    @param {File} file.
    @return {Promise} Object in geoJSON format
  */
  uploadFile(file) {
    let config = Ember.getOwner(this).resolveRegistration(&#x27;config:environment&#x27;);

    return new Ember.RSVP.Promise((resolve, reject) =&gt; {
      Ember.$.ajax({
        url: &#x60;${config.APP.backendUrl}/controls/FileUploaderHandler.ashx?FileName=${file.name}&#x60;,
        type: &#x27;POST&#x27;,
        data: file,
        cache: false,
        processData: false,
        success: function (data) {
          resolve(data);
        },
        error: function (e) {
          reject(e);
        }
      });
    });
  },

  _isObject(item) {
    return (item &amp;&amp; typeof item === &#x27;object&#x27; &amp;&amp; !Array.isArray(item));
  },

  /**
    Convert coordinates of object to wgs84, or other crsName.
    @method convertObjectCoordinates
    @param {featureLayer} object.
    @return {featureLayer} Returns provided object with converted coordinates
    @private
  */
  _convertObjectCoordinates(projection, object, crsName = null) {

    // copy from https://stackoverflow.com/a/48218209/2014079 for replace $.extend
    // such as it is not properly work with Proxy properties
    var mergeDeep = function (...objects) {
      const isObject = obj =&gt; obj &amp;&amp; typeof obj === &#x27;object&#x27;;

      return objects.reduce((prev, obj) =&gt; {
        Object.keys(obj).forEach(key =&gt; {
          const pVal = prev[key];
          const oVal = obj[key];

          if (Array.isArray(pVal) &amp;&amp; Array.isArray(oVal)) {
            prev[key] = pVal.concat(...oVal);
          } else if (isObject(pVal) &amp;&amp; isObject(oVal)) {
            prev[key] = mergeDeep(pVal, oVal);
          } else {
            prev[key] = oVal;
          }
        });

        return prev;
      }, {});
    };

    let knownCrs = Ember.getOwner(this).knownForType(&#x27;coordinate-reference-system&#x27;);
    let knownCrsArray = Ember.A(Object.values(knownCrs));
    let firstProjection = projection ? projection : &#x27;EPSG:4326&#x27;;
    let secondProjection = crsName ? crsName : &#x27;EPSG:4326&#x27;;
    let firstCrs = knownCrsArray.findBy(&#x27;code&#x27;, firstProjection);
    let secondCrs = knownCrsArray.findBy(&#x27;code&#x27;, secondProjection);
    if (firstCrs &amp;&amp; secondCrs) {
      let firstDefinition = Ember.get(firstCrs, &#x27;definition&#x27;);
      let secondDefinition = Ember.get(secondCrs, &#x27;definition&#x27;);
      if (firstDefinition &amp;&amp; secondDefinition) {
        if (firstDefinition !== secondDefinition) {
          let result = mergeDeep({}, object);
          let coordinatesArray = [];
          if (result.geometry.type !== &#x27;Point&#x27;) {
            result.geometry.coordinates.forEach(arr =&gt; {
              var arr1 = [];
              arr.forEach(pair =&gt; {
                if (result.geometry.type === &#x27;MultiPolygon&#x27;) {
                  let arr2 = [];
                  pair.forEach(cords =&gt; {
                    let transdormedCords = proj4(firstDefinition, secondDefinition, cords);
                    arr2.push(transdormedCords);
                  });
                  arr1.push(arr2);
                } else {
                  let cords = proj4(firstDefinition, secondDefinition, pair);
                  arr1.push(cords);
                }
              });
              coordinatesArray.push(arr1);
            });
          } else {
            coordinatesArray = proj4(firstDefinition, secondDefinition, result.geometry.coordinates);
          }

          result.geometry.coordinates = coordinatesArray;
          return result;
        } else {
          return object;
        }
      }
    } else {
      throw &#x27;unknown coordinate reference system&#x27;;
    }
  },

  /*
    Get the field to search for objects
    @method getPkField
    @param {Object} layer.
    @return {String} Field name.
  */
  _getPkField(layer) {
    let layerType = this._getTypeLayer(layer);
    if (layerType instanceof VectorLayer) {
      const getPkField = this.get(&#x27;mapApi&#x27;).getFromApi(&#x27;getPkField&#x27;);
      if (typeof getPkField === &#x27;function&#x27;) {
        return getPkField(layer);
      }

      let field = Ember.get(layer, &#x27;settingsAsObject.pkField&#x27;);
      return Ember.isNone(field) ? &#x27;primarykey&#x27; : field;
    } else {
      throw &#x27;Layer is not VectorLayer&#x27;;
    }
  },

  /**
    Get coordinates point.
    @method getCoordPoint
    @param {String} crsName Name of coordinate reference system, in which to give coordinates.
    @param {Boolean} snap Snap or not
    @param {Array} snapLayers Layers for snap
    @param {Integer} snapDistance in pixels
    @param {Boolean} snapOnlyVertex or segments too
    @return {Promise} Coordinate.
  */
  getCoordPoint(crsName, snap, snapLayers, snapDistance, snapOnlyVertex) {
    return new Ember.RSVP.Promise((resolve, reject) =&gt; {
      const leafletMap = this.get(&#x27;mapApi&#x27;).getFromApi(&#x27;leafletMap&#x27;);
      Ember.$(leafletMap._container).css(&#x27;cursor&#x27;, &#x27;crosshair&#x27;);

      var getCoord = (e) =&gt; {
        if (snap) {
          this._drawClick(e);
        }

        leafletMap.off(&#x27;mousemove&#x27;, this._handleSnapping, this);
        let layers = this.get(&#x27;_snapLayersGroups&#x27;);
        if (layers) {
          layers.forEach((l, i) =&gt; {
            l.off(&#x27;load&#x27;, this._setSnappingFeatures, this);
          });
        }

        this._cleanupSnapping();

        Ember.$(leafletMap._container).css(&#x27;cursor&#x27;, &#x27;&#x27;);
        let crs = Ember.get(leafletMap, &#x27;options.crs&#x27;);
        if (!Ember.isNone(crsName)) {
          crs = getLeafletCrs(&#x27;{ &quot;code&quot;: &quot;&#x27; + crsName.toUpperCase() + &#x27;&quot;, &quot;definition&quot;: &quot;&quot; }&#x27;, this);
        }

        resolve(crs.project(e.latlng));
      };

      if (snap) {
        let layers = snapLayers.map((id) =&gt; {
          let [, leafletObject] = this._getModelLeafletObject(id);
          return leafletObject;
        }).filter(l =&gt; !!l);

        layers.forEach((l, i) =&gt; {
          l.on(&#x27;load&#x27;, this._setSnappingFeatures, this);
        });

        this.set(&#x27;_snapLayersGroups&#x27;, layers);
        this._setSnappingFeatures();

        if (snapDistance) {
          this.set(&#x27;_snapDistance&#x27;, snapDistance);
        }

        if (!Ember.isNone(snapOnlyVertex)) {
          this.set(&#x27;_snapOnlyVertex&#x27;, snapOnlyVertex);
        }

        let editTools = this._getEditTools();
        leafletMap.on(&#x27;mousemove&#x27;, this._handleSnapping, this);
        this.set(&#x27;_snapMarker&#x27;, L.marker(leafletMap.getCenter(), {
          icon: editTools.createVertexIcon({ className: &#x27;leaflet-div-icon leaflet-drawing-icon&#x27; }),
          opacity: 1,
          zIndexOffset: 1000
        }));
      }

      leafletMap.once(&#x27;click&#x27;, getCoord);
    });
  },

  /**
    Loading features by packages
    @method loadingFeaturesByPackages
    @param {String} layerId Layer ID.
    @param {Array} objectIds Object IDs.
    @return {Promise}
  */
  loadingFeaturesByPackages(layerId, objectIds) {
    let packageSize = 100;

    let layerPromises = [];

    let startPackage = 0;
    while (startPackage &lt; objectIds.length) {
      let endPackage = (startPackage + packageSize) &lt;= objectIds.length ? startPackage + packageSize : objectIds.length;
      let objectsPackage = [];
      for (var i = startPackage; i &lt; endPackage; i++) {
        objectsPackage.push(objectIds[i]);
      }

      layerPromises.push(this._getModelLayerFeature(layerId, objectsPackage));
      startPackage = endPackage;
    }

    return layerPromises;
  },

  /**
    Calculate geometry
    @method getMergedGeometry
    @param {String} layerAId First layer ID.
    @param {Array} objectAIds First layer object IDs.
    @param {String} layerBId Second layer ID.
    @param {Array} objectBIds Second layer object IDs.
    @param {Boolean} failIfInvalid Fail when has invalid geometry.
    @return {Promise} GeoJson Feature in EPSG:4326
  */
  getMergedGeometry(layerAId, objectAIds, layerBId, objectBIds, isUnion = false, failIfInvalid = false) {
    return new Ember.RSVP.Promise((resolve, reject) =&gt; {
      let layerAPromises = this.loadingFeaturesByPackages(layerAId, objectAIds);
      let layerBPromises = this.loadingFeaturesByPackages(layerBId, objectBIds);

      Ember.RSVP.allSettled(
        layerAPromises.concat(layerBPromises)
      ).then((layerFeatures) =&gt; {
        const rejected = layerFeatures.filter((item) =&gt; { return item.state === &#x27;rejected&#x27;; }).length &gt; 0;

        if (rejected) {
          reject(&#x27;Error loading objects&#x27;);
        }

        let count = 0;

        let resultObjs = Ember.A();

        layerFeatures.forEach((r, i) =&gt; {
          let geometries = Ember.A();
          r.value[2].forEach((obj, ind) =&gt; {
            if (Ember.get(obj, &#x27;feature.geometry&#x27;) &amp;&amp; Ember.get(obj, &#x27;options.crs.code&#x27;)) {
              let feature = {
                type: &#x27;Feature&#x27;,
                geometry: obj.feature.geometry,
                crs: {
                  type: &#x27;name&#x27;,
                  properties: {
                    name: obj.options.crs.code
                  }
                }
              };

              geometries.pushObject(feature);
            }
          });

          count += 1;

          //    ,   null
          let merged = this.createMulti(geometries, isUnion, failIfInvalid);
          if (merged) {
            resultObjs.pushObject(merged);
          }
        });

        let resultObj = resultObjs.length &gt; 0 ? this.createMulti(resultObjs, isUnion, failIfInvalid) : null;
        resolve(resultObj ? resultObj : null);
      }).catch((e) =&gt; {
        reject(e);
      });
    });
  },

  /**
    Add to array points and feature.
    @method _addToArrayPointsAndFeature
    @param {String} layerId Layer ID.
    @param {String} crsName Name of coordinate reference system, in which to conver coordinates.
    @return {Promise} array of points and feature.
  */
  _addToArrayPointsAndFeature(layerId, crsName) {
    return new Ember.RSVP.Promise((resolve, reject) =&gt; {
      this._getModelLayerFeature(layerId, null).then(([, layerObject, layerFeatures]) =&gt; {
        if (!Ember.isEmpty(layerFeatures)) {
          let arrPoints = Ember.A();
          let features = Ember.A();
          layerFeatures.forEach((layer) =&gt; {
            let obj = layer.feature;
            if (!Ember.isNone(crsName)) {
              obj = this._convertObjectCoordinates(layerObject.options.crs.code, obj, crsName);
            }

            let featureLayer = L.GeoJSON.geometryToLayer(obj);
            arrPoints.push(this._coordsToPoints(featureLayer.getLatLngs()));
            features.push(layer);
          });

          resolve({ arrPoints, features });
        } else {
          reject(&#x27;Error to load objects&#x27;);
        }
      }).catch((e) =&gt; {
        reject(e);
      });
    });
  },

  /**
    Difference layers.
    @method differenceLayers
    @param {String} layerAId First layer ID.
    @param {String} layerBId Second layer ID.
    @return {Promise} array of Object { diffFeatures, layerAFeatures, layerBFeatures }.
  */
  differenceLayers(layerAId, layerBId) {
    return new Ember.RSVP.Promise((resolve, reject) =&gt; {
      let result = Ember.A();
      let crsA = this._getModelLeafletObject(layerAId)[1].options.crs.code;
      let crsB = this._getModelLeafletObject(layerBId)[1].options.crs.code;
      let arrayPointsAndFeaturePromises = [this._addToArrayPointsAndFeature(layerAId), this._addToArrayPointsAndFeature(layerBId)];
      if (crsA !== crsB) {
        arrayPointsAndFeaturePromises = [this._addToArrayPointsAndFeature(layerAId), this._addToArrayPointsAndFeature(layerBId, crsA)];
      }

      Ember.RSVP.all(arrayPointsAndFeaturePromises).then((res) =&gt; {
        let subj = res[0].arrPoints; // layer A
        let clip = res[1].arrPoints; // layer B
        let solution = ClipperLib.Paths();
        let cpr = new ClipperLib.Clipper(); // The Clipper constructor creates an instance of the Clipper class

        // Add &#x27;Subject&#x27; paths - layer A
        for (let s = 0, slen = subj.length; s &lt; slen; s++) {
          if (Ember.isArray(subj[s])) { // multipolygon
            for (let k = 0, klen = subj[s].length; k &lt; klen; k++) {
              cpr.AddPaths(subj[s][k], ClipperLib.PolyType.ptSubject, true);
            }
          } else { // polygon
            cpr.AddPaths(subj[s], ClipperLib.PolyType.ptSubject, true);
          }
        }

        // Add &#x27;Clipping&#x27; paths - layer B
        for (let c = 0, clen = clip.length; c &lt; clen; c++) {
          if (Ember.isArray(clip[c])) { // multipolygon
            for (let k = 0, klen = clip[c].length; k &lt; klen; k++) {
              cpr.AddPaths(clip[c][k], ClipperLib.PolyType.ptClip, true);
            }
          } else { // polygon
            cpr.AddPaths(clip[c], ClipperLib.PolyType.ptClip, true);
          }
        }

        // Performing the clipping operation - Difference, result operation be return in solution
        cpr.Execute(ClipperLib.ClipType.ctDifference, solution);

        // filtering &#x27;solution&#x27; by area !== 0, transformating of geometry in jsts for comparison and calculate area, filtering after transformation by area &gt; 0
        if (!Ember.isEmpty(solution)) {
          let jstsGeoJSONReader = new jsts.io.GeoJSONReader();
          let diffNotNullArea = solution.filter((geom) =&gt; {
            return ClipperLib.Clipper.Area(geom) !== 0;
          }).map((geom) =&gt; {
            let feature = {
              type: &#x27;Feature&#x27;,
              geometry: {
                type: &#x27;Polygon&#x27;,
                coordinates: [this._pointsToCoords(geom)],
              }
            };
            let jstsFeature = jstsGeoJSONReader.read(feature);
            if (jstsFeature.geometry.isValid()) {
              let area = jstsFeature.geometry.getArea();
              return { feature, jstsGeometry: jstsFeature.geometry, area };
            } else {
              return { feature, jstsGeometry: jstsFeature.geometry, area: 0 };
            }
          }).filter((diff) =&gt; {
            return diff.area &gt; 0;
          });

          resolve({ diffFeatures: diffNotNullArea, layerA: res[0].features, layerB: res[1].features });
        } else {
          resolve(&#x27;The difference is not found&#x27;);
        }
      }).catch((e) =&gt; {
        reject(e);
      });
    });
  },

  /**
    Compare layers.
    @method compareLayers
    @param {String} layerAId First layer ID.
    @param {String} layerBId Second layer ID.
    @param {String} condition Comparison conditions [&quot;contains&quot;, &quot;intersects&quot;, &quot;notIntersects&quot;].
    @param {Boolean} showOnMap flag indicates if difference area will be displayed on map.
    @return {Promise} array of objects with {areaDifference, objectDifference, id of layerB, that matches the condition}.
  */
  compareLayers(layerAId, layerBId, condition, showOnMap) {
    return new Ember.RSVP.Promise((resolve, reject) =&gt; {
      let result = Ember.A();
      let cond = [&#x27;contains&#x27;, &#x27;intersects&#x27;, &#x27;notIntersects&#x27;];
      let diffLayerPromise = this.differenceLayers(layerAId, layerBId);
      if (!cond.includes(condition)) {
        reject(&#x27;The comparison condition is set incorrectly. It must be [&quot;contains&quot;, &quot;intersects&quot;, &quot;notIntersects&quot;].&#x27;);
      } else if (condition === cond[2]) {
        diffLayerPromise = this.differenceLayers(layerBId, layerAId);
      }

      diffLayerPromise.then((res) =&gt; {
        if (res.hasOwnProperty(&#x27;diffFeatures&#x27;)) {
          let jstsGeoJSONReader = new jsts.io.GeoJSONReader();
          res.diffFeatures.forEach((diff) =&gt; {
            if (!cond.includes(condition)) {
              reject(&#x27;The comparison condition is set incorrectly. It must be [&quot;contains&quot;, &quot;intersects&quot;, &quot;notIntersects&quot;].&#x27;);
            }

            let layerFeatures = res.layerB;
            if (condition === cond[2]) {
              layerFeatures = res.layerA;
            }

            let crs = res.layerA[0].options.crs;
            let coordsToLatLng = function(coords) {
              return crs.unproject(L.point(coords));
            };

            let featureLayer = L.geoJSON(diff.feature, { coordsToLatLng: coordsToLatLng.bind(this) }).getLayers()[0];
            let object = {
              areaDifference: diff.area,
              objectDifference: featureLayer
            };

            let filterByCondition = layerFeatures.every((feat) =&gt; {
              let jstsFeat = jstsGeoJSONReader.read(feat.feature);
              if (jstsFeat.geometry.isValid()) {
                switch (condition) {
                  case cond[0]:
                    if (jstsFeat.geometry.contains(diff.jstsGeometry)) {
                      object.id = jstsFeat.properties.primarykey;
                      return false;
                    } else {
                      return true;
                    }

                    break;
                  case cond[1]:
                    if (jstsFeat.geometry.intersects(diff.jstsGeometry) &amp;&amp; !jstsFeat.geometry.contains(diff.jstsGeometry)) {
                      object.id = jstsFeat.properties.primarykey;
                      return false;
                    } else {
                      return true;
                    }

                    break;
                  case cond[2]:
                    if (jstsFeat.geometry.intersects(diff.jstsGeometry)) {
                      object.id = jstsFeat.properties.primarykey;
                      return false;
                    } else {
                      return true;
                    }

                    break;
                  default:
                    return true;
                }
              } else {
                return true;
              }
            });

            if (showOnMap) {
              let serviceLayer = this.get(&#x27;mapApi&#x27;).getFromApi(&#x27;serviceLayer&#x27;);
              featureLayer.addTo(serviceLayer);
            }

            result.pushObject(object);
          });
          resolve(result);
        } else {
          reject(res);
        }
      }).catch((e) =&gt; {
        reject(e);
      });
    });
  },

  /**
    Exponentiation.
    @method _pointAmplifier
    @return {Number} 100000000.
  */
  _pointAmplifier() {
    return Math.pow(10, 8);
  },

  /**
    Transform coordinates in points.
    @method _coordsToPoints
    @param {Array} polygons Array of coordinates.
    @return {Array} Array of points.
  */
  _coordsToPoints(polygons) {
    let amp = this._pointAmplifier();
    if (Array.isArray(polygons[0]) || (!(polygons instanceof L.LatLng) &amp;&amp; (polygons[0] instanceof L.LatLng))) {
      let coords = [];
      for (let i = 0; i &lt; polygons.length; i++) {
        coords.push(this._coordsToPoints(polygons[i]));
      }

      return coords;
    }

    return { X: Math.round(polygons.lng * amp), Y: Math.round(polygons.lat * amp) };
  },

  /**
    Transform points in coordinates.
    @method _pointsToCoords
    @param {Array} points Array of points.
    @return {Array} Array of coordinates.
  */
  _pointsToCoords(points) {
    let amp = this._pointAmplifier();
    if (Array.isArray(points[0]) || (!(points instanceof ClipperLib.IntPoint) &amp;&amp; (points[0] instanceof ClipperLib.IntPoint))) {
      let coord = [];
      for (let i = 0; i &lt; points.length; i++) {
        coord.push(this._pointsToCoords(points[i]));
      }

      // closing polygon
      if (!Array.isArray(coord[0][0])) {
        let first = coord[0];
        coord.push(first);
      }

      return coord;
    }

    return [points.X / amp, points.Y / amp];
  }
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
